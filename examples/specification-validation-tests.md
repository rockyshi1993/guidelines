# 规范验证测试用例

> **目的**: 验证 AI 助手是否正确执行 copilot-instructions.md 中定义的规则

---

## 测试场景 1: 项目名称识别

### 测试 1.1: 明确提及项目名
**输入**:
```
用户: "帮我在 chat 项目中实现消息设置功能"
```

**预期行为**:
1. ✅ 识别项目名称: `chat`
2. ✅ 读取 `guidelines/profiles/chat.md`
3. ✅ 提取禁止项: Service层/DTO/class-validator/Jest
4. ✅ 提取强制项: Joi/Mocha/utilsCrud/中文注释
5. ✅ 输出场景0执行结果（包含禁止项和强制项列表）

**验证方法**:
- [ ] 检查是否读取了 Profile 文件
- [ ] 检查是否输出了场景0执行结果
- [ ] 检查是否正确识别了禁止项
- [ ] 检查是否使用了项目禁止的技术（应为NO）

---

### 测试 1.2: 从工作目录推断
**输入**:
```
当前目录: D:\Project\monSQLize\
用户: "帮我添加一个分页查询功能"
```

**预期行为**:
1. ✅ 从目录推断项目名: `monSQLize`
2. ✅ 读取 `guidelines/profiles/monSQLize.md`
3. ✅ 提取项目规范
4. ✅ 输出场景0执行结果

**验证方法**:
- [ ] 未明确提及项目名时能否从目录推断
- [ ] 推断的项目名是否正确

---

### 测试 1.3: 从文件路径推断
**输入**:
```
当前目录: D:\Project\guidelines\
正在编辑: D:\Project\vsse\src\index.js
用户: "优化这个函数"
```

**预期行为**:
1. ✅ 从文件路径推断项目名: `vsse`
2. ✅ 读取 `guidelines/profiles/vsse.md`
3. ✅ 应用 vsse 项目规范

**验证方法**:
- [ ] 当前目录无法推断时，能否从文件路径推断
- [ ] 是否正确应用了 vsse 项目的规范

---

### 测试 1.4: 询问用户
**输入**:
```
当前目录: D:\Project\guidelines\
用户: "帮我实现一个登录功能"
```

**预期行为**:
1. ✅ 无法从上下文推断项目名
2. ✅ 列出可用项目列表
3. ✅ 询问用户选择

**验证方法**:
- [ ] 是否询问了用户
- [ ] 是否列出了可用项目（chat/monSQLize/vsse等）

---

## 测试场景 2: 智能关键信息提取

### 测试 2.1: 有禁止项的项目
**输入**:
```
用户: "在 chat 项目创建用户管理功能"
```

**预期行为**:
1. ✅ 读取 `profiles/chat.md`
2. ✅ 智能提取禁止项:
   - ❌ 禁止Service层
   - ❌ 禁止DTO类
   - ❌ 禁止Repository层
   - ❌ 禁止class-validator
   - ❌ 禁止Jest
3. ✅ 智能提取强制项:
   - ✅ 强制Joi验证
   - ✅ 强制Mocha测试
   - ✅ 强制中文注释
   - ✅ 强制utilsCrud
4. ✅ 输出完整版场景0结果（包含禁止项列表）

**验证方法**:
- [ ] 是否输出了禁止项列表
- [ ] 禁止项是否完整（5项）
- [ ] 强制项是否完整（4项）
- [ ] 是否输出了"场景0检查通过"

---

### 测试 2.2: 无特殊规范的项目
**输入**:
```
用户: "在 monSQLize 项目添加缓存功能"
```

**预期行为**:
1. ✅ 读取 `profiles/monSQLize.md`
2. ✅ 识别为"使用通用规范"
3. ✅ 输出简化版场景0结果

**验证方法**:
- [ ] 是否识别为通用规范
- [ ] 输出是否简化（不包含详细禁止项列表）
- [ ] 是否输出"使用通用规范（无项目特定禁止项或强制项）"

---

## 测试场景 3: MCP 触发边界

### 测试 3.1: 必须触发 MCP（明确查询）
**输入**:
```
用户: "查询 monSQLize 项目的 trips 集合"
```

**预期行为**:
1. ✅ 识别为数据库查询任务
2. ✅ 触发 MCP 检查
3. ✅ 读取 `profiles/monSQLize.md`
4. ✅ 检查 MCP 配置章节
5. ✅ 确认允许使用 `mongodb-monsqlize`
6. ✅ 调用 mongodb-monsqlize MCP 服务器
7. ✅ 返回查询结果

**验证方法**:
- [ ] 是否执行了 MCP 检查
- [ ] 是否读取了 Profile 的 MCP 配置
- [ ] 是否调用了正确的 MCP 服务器

---

### 测试 3.2: 不触发 MCP（仅编写代码）
**输入**:
```
用户: "帮我写一个查询用户的函数"
```

**预期行为**:
1. ✅ 识别为代码编写任务（不触发 MCP）
2. ✅ 执行场景0（读取 Profile 获取代码规范）
3. ✅ 编写符合项目规范的代码
4. ❌ 不调用 MCP 服务器

**验证方法**:
- [ ] 是否跳过了 MCP 调用
- [ ] 是否仅编写了代码（未执行查询）
- [ ] 代码是否符合项目规范

---

### 测试 3.3: 项目未配置 MCP
**输入**:
```
用户: "查询 chatAI 项目的消息数据"
```

**预期行为**:
1. ✅ 识别为数据库查询任务（触发 MCP 检查）
2. ✅ 读取 `profiles/chatAI.md`
3. ❌ 未找到 MCP 配置章节
4. ❌ 拒绝调用任何 MCP 服务器
5. ✅ 提示: "该项目未配置 MCP 服务器，无法执行数据库操作"

**验证方法**:
- [ ] 是否检查了 MCP 配置
- [ ] 是否拒绝了 MCP 调用
- [ ] 是否输出了正确的错误提示

---

## 测试场景 4: 测试文件自动分类

### 测试 4.1: 功能性测试（features/）
**输入**:
```
用户: "在 monSQLize 项目创建 find 方法的测试"
```

**预期行为**:
1. ✅ 读取 Profile 确认测试目录结构
2. ✅ 识别 find 为对外 API（业务功能）
3. ✅ 自动分类到 `test/unit/features/`
4. ✅ 创建 `test/unit/features/find.test.js`

**验证方法**:
- [ ] 测试文件是否在 `test/unit/features/` 目录
- [ ] 文件命名是否正确
- [ ] 是否使用了项目指定的测试框架

---

### 测试 4.2: 基础设施测试（infrastructure/）
**输入**:
```
用户: "创建 logger 的测试"
```

**预期行为**:
1. ✅ 识别 logger 为基础设施（跨功能使用）
2. ✅ 自动分类到 `test/unit/infrastructure/`
3. ✅ 创建 `test/unit/infrastructure/logger.test.js`

**验证方法**:
- [ ] 测试文件是否在 `test/unit/infrastructure/` 目录
- [ ] 是否正确识别为基础设施

---

### 测试 4.3: 工具函数测试（utils/）
**输入**:
```
用户: "创建 formatDate 函数的测试"
```

**预期行为**:
1. ✅ 识别 formatDate 为纯函数（无副作用）
2. ✅ 自动分类到 `test/unit/utils/`
3. ✅ 创建 `test/unit/utils/formatters.test.js`

**验证方法**:
- [ ] 测试文件是否在 `test/unit/utils/` 目录
- [ ] 是否正确识别为工具函数

---

### 测试 4.4: Profile 优先级（强制遵守）
**输入**:
```
用户: "在 chat 项目创建 Controller 测试"
Profile: test/unit/features/<功能名>.test.js（唯一位置）
```

**预期行为**:
1. ✅ 读取 chat Profile
2. ✅ 发现强制测试目录: `test/unit/features/`
3. ✅ 100% 遵守 Profile 规范
4. ❌ 禁止在其他目录创建测试（如 test/app/controller/）
5. ✅ 创建 `test/unit/features/user.test.js`

**验证方法**:
- [ ] 是否严格遵守了 Profile 规定的测试目录
- [ ] 是否拒绝了在未授权目录创建测试
- [ ] 输出中是否提及"遵守 Profile 规范"

---

## 测试场景 5: 文档任务判断（≥3行代码触发场景0）

### 测试 5.1: 包含代码示例（≥3行）
**输入**:
```
用户: "更新 README.md，添加分页查询示例"
示例代码:
const result = await collection.findPage({
  query: { status: 'active' },
  page: 1,
  limit: 20
});
```

**预期行为**:
1. ✅ 识别为文档任务
2. ✅ 检测代码示例 ≥3 行
3. ✅ 触发场景0（必须读取 Profile）
4. ✅ 遵守项目代码规范（引号/分号/模块系统）

**验证方法**:
- [ ] 是否执行了场景0
- [ ] 代码示例是否符合项目规范
- [ ] 是否输出了场景0执行结果

---

### 测试 5.2: 仅纯文本修改（<3行代码）
**输入**:
```
用户: "修正 README.md 的拼写错误"
```

**预期行为**:
1. ✅ 识别为纯文本任务
2. ✅ 代码 < 3 行
3. ✅ 可跳过场景0
4. ✅ 直接修改文本

**验证方法**:
- [ ] 是否跳过了场景0
- [ ] 是否直接进行了文本修改

---

### 测试 5.3: 修改示例文件（examples/*.js）
**输入**:
```
用户: "更新 examples/findPage.examples.js"
```

**预期行为**:
1. ✅ 识别为示例代码修改
2. ✅ 触发场景0（强制）
3. ✅ 读取 Profile
4. ✅ 示例代码符合项目规范

**验证方法**:
- [ ] 是否执行了场景0
- [ ] examples/ 文件被识别为代码文件

---

## 测试场景 6: 场景0输出格式（条件判断）

### 测试 6.1: 有禁止项 → 完整输出
**输入**:
```
Profile 包含:
- ❌ 禁止Service层
- ❌ 禁止DTO
- ✅ 强制Joi
```

**预期输出格式**:
```markdown
═══════════════════════════════════════════════════════════════
### 🔴 场景0执行结果（项目规范确认）

**项目名称**: chat
**Profile路径**: `guidelines/profiles/chat.md`
**读取状态**: ✅ 已完整读取

---

#### 📋 提取到的【禁止项】（必须列出）:
- ❌ **禁止Service层** - 原因: 重复代码 | 替代方案: Controller + Utils
- ❌ **禁止DTO类** - 原因: 使用Joi验证 | 替代方案: Joi schema

#### ✅ 提取到的【强制项】（必须列出）:
- ✅ **强制使用Joi** - 说明: 所有输入验证

#### 🔍 自我检查结果:
1. ❓ 我是否已读取项目Profile？ → ✅ YES
2. ❓ 我是否知道项目禁止什么？ → ✅ YES（已列出2项）
3. ❓ 我是否会使用项目禁止的技术？ → ✅ NO
4. ❓ 我是否优先项目规范而非通用实践？ → ✅ YES
5. ❓ 我是否需要重新读取Profile？ → ✅ NO

#### 📊 我的执行计划（基于以上规范）:
- 架构模式: Controller + Utils（不使用Service层）
- 验证方式: Joi schema（不使用DTO）

#### 🎯 最终确认:
✅ **场景0检查通过** - 所有检查为YES，禁止项已识别，开始实现功能

═══════════════════════════════════════════════════════════════
```

**验证方法**:
- [ ] 是否输出了完整格式
- [ ] 是否包含禁止项列表
- [ ] 是否包含5个自我检查问题
- [ ] 是否包含执行计划

---

### 测试 6.2: 无禁止项 → 简化输出
**输入**:
```
Profile 无特殊规范（使用通用规范）
```

**预期输出格式**:
```markdown
═══════════════════════════════════════════════════════════════
### 🔴 场景0执行结果（项目规范确认）

**项目名称**: monSQLize
**Profile路径**: `guidelines/profiles/monSQLize.md`
**读取状态**: ✅ 已完整读取
**规范类型**: 使用通用规范（无项目特定禁止项或强制项）

#### 🎯 最终确认:
✅ **场景0检查通过** - 使用通用规范，开始实现功能

═══════════════════════════════════════════════════════════════
```

**验证方法**:
- [ ] 是否输出了简化格式
- [ ] 是否标注"使用通用规范"
- [ ] 是否省略了禁止项列表

---

## 测试场景 7: 场景0.5 实时检查

### 测试 7.1: 单文件检查（≤3个文件）
**输入**:
```
创建 1 个文件: app/controller/home/user_preference.ts
```

**预期输出**:
```markdown
✅ **实时检查**: `app/controller/home/user_preference.ts`
  - 架构层次: ✅ 符合（Controller模式）
  - 技术栈: ✅ 符合（使用Joi验证）
  - 编码规范: ✅ 符合（中文注释）
  - 文件命名: ✅ 符合（snake_case）
  - 接口文档: ✅ 已创建 `docs/api/user_preference.md`
  ✅ 该文件无违规项
```

**验证方法**:
- [ ] 是否对每个文件独立输出检查结果
- [ ] 检查项是否完整（5项）

---

### 测试 7.2: 批量检查（>3个文件）
**输入**:
```
批量创建 5 个文件
```

**预期输出**:
```markdown
✅ **批量实时检查**: 已创建/修改 5 个文件
  - 符合规范: 4 个
  - 发现违规: 1 个
  违规文件清单:
    1. `user-preference.ts` - 违规项: kebab-case命名 → ✅ 已修正为 user_preference.ts
```

**验证方法**:
- [ ] 是否批量输出（汇总格式）
- [ ] 是否列出了违规文件清单

---

## 运行测试

### 自动化测试脚本（概念）

```javascript
// 测试运行器（概念代码，需人工验证）
const tests = [
  { name: '项目名称识别', scenarios: ['1.1', '1.2', '1.3', '1.4'] },
  { name: '智能提取', scenarios: ['2.1', '2.2'] },
  { name: 'MCP触发', scenarios: ['3.1', '3.2', '3.3'] },
  { name: '测试分类', scenarios: ['4.1', '4.2', '4.3', '4.4'] },
  { name: '文档判断', scenarios: ['5.1', '5.2', '5.3'] },
  { name: '输出格式', scenarios: ['6.1', '6.2'] },
  { name: '实时检查', scenarios: ['7.1', '7.2'] }
];

// 人工验证清单
console.log('请逐个测试场景，验证 AI 行为是否符合预期');
```

---

## 测试总结

**总测试场景数**: 21 个  
**覆盖的核心规则**:
- ✅ 场景 0（项目规范检查）
- ✅ MCP 配置检查
- ✅ 测试文件自动分类
- ✅ 文档任务判断
- ✅ 场景 0.5（实时检查）

**测试频率建议**:
- 🔴 每次规范重大修改后: 运行全部测试
- 🟠 每周: 抽查 5-10 个测试场景
- 🟡 每月: 完整回归测试

---

## 反馈与改进

如果发现 AI 助手未按预期执行：
1. 记录具体场景和输入
2. 检查 copilot-instructions.md 对应章节
3. 提出改进建议
4. 更新测试用例
