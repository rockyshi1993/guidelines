# v3 测试规范

> **文件**: specs/rules/测试规范.md  
> **版本**: v3.0  
> **日期**: 2025-11-20  
> **说明**: AI 生成测试的质量规范

---

## 📑 目录导航

> 🔴 = 必须达到 | 🟡 = 建议达到 | 🟢 = 参考

- [测试覆盖率要求](#-测试覆盖率要求) 🔴 - 单元≥80%，核心100%
  - [覆盖率目标](#覆盖率目标) 🔴 - 各类测试的最低要求
  - [覆盖率类型](#覆盖率类型) 🔴 - 行/分支/函数/语句覆盖率
- [5种测试类型](#-5种测试类型) 🔴 - 单元/集成/E2E/API/基准测试
  - [单元测试（Unit Test）](#单元测试unit-test) 🔴 - 最基础，必须≥80%
  - [集成测试（Integration Test）](#集成测试integration-test) 🟡 - 模块间交互测试
  - [E2E测试（End-to-End Test）](#e2e测试end-to-end-test) 🟡 - 主流程必须覆盖
  - [API测试（API Test）](#api测试api-test) 🔴 - 所有接口必须测试
  - [基准测试（Benchmark Test）](#基准测试benchmark-test) 🟢 - 性能优化时需要
- [测试命名规范](#-测试命名规范) 🔴 - should {action} when {condition}
- [AAA模式](#-aaa模式) 🔴 - Arrange/Act/Assert结构
- [Mock规范](#-mock规范) 🔴 - 何时Mock，何时不Mock
  - [何时使用Mock](#何时使用mock) 🔴 - 外部依赖/数据库/API调用
  - [何时不使用Mock](#何时不使用mock) 🔴 - 纯函数/业务逻辑
- [测试文件组织](#-测试文件组织) 🔴 - test/目录结构
- [测试质量检查](#-测试质量检查) 🔴 - 必须100%通过
- [Profile 优先](#-profile-优先) 🟡 - 项目可定义更高要求

---

## 📚 相关规范文件

**测试生成时必须配合使用**:
- 📦 [流程.md](../core/流程.md) 🔴 - STEP 11使用本规范
- 📦 [目录结构.md](../core/目录结构.md) 🔴 - test/目录命名规范
- 📐 [代码规范.md](./代码规范.md) 🔴 - 测试代码也需要遵守质量标准

**相关规范**:
- 📐 [API规范.md](./API规范.md) 🔴 - API测试需要
- 📄 [报告模板.md](../output/报告模板.md) 🔴 - STEP 14测试结果报告

**Profile优先**:
- 🔴 如果项目Profile定义了更高的覆盖率要求，必须遵守
- 🔴 如果项目指定了测试框架（Jest/Mocha等），优先使用

---

## 📋 测试覆盖率要求

### 覆盖率目标

```yaml
单元测试覆盖率:
  最低要求: 80%
  建议目标: 90%
  
  IF: 覆盖率 < 80%
  THEN: 
    - 必须补充测试
    - 阻止提交

集成测试覆盖率:
  最低要求: 60%
  建议目标: 75%

E2E测试覆盖率:
  最低要求: 主流程100%
  建议目标: 关键流程100%

核心业务逻辑:
  要求: 100%覆盖
  
  包括:
    - 支付流程
    - 订单流程
    - 用户认证
    - 权限验证
    - 数据计算逻辑
```

### 覆盖率类型

```yaml
行覆盖率（Line Coverage）:
  定义: 执行到的代码行数 / 总代码行数
  最低: 80%

分支覆盖率（Branch Coverage）:
  定义: 执行到的分支数 / 总分支数
  最低: 75%
  
  说明: 所有if/else分支都要测试

函数覆盖率（Function Coverage）:
  定义: 调用的函数数 / 总函数数
  最低: 90%

语句覆盖率（Statement Coverage）:
  定义: 执行的语句数 / 总语句数
  最低: 80%
```

---

## 🧪 测试类型规范

### 单元测试（Unit Test）

**定义**: 测试单个函数/方法/类的功能

**范围**:
```yaml
必须测试:
  - 所有 public 函数/方法
  - 所有业务逻辑函数
  - 所有工具函数
  - 所有数据处理函数

可以跳过:
  - 简单的 getter/setter
  - 仅调用其他函数的 wrapper
  - 纯配置文件
  - 类型定义文件
```

**测试文件位置**:
```
test/{模块名}-unit.test.js
```

**测试用例结构**:
```javascript
describe('UserService', () => {
  describe('getUserById', () => {
    it('should return user when id exists', async () => {
      // Arrange
      const userId = '123';
      const expectedUser = { id: '123', name: 'Test' };
      
      // Act
      const result = await userService.getUserById(userId);
      
      // Assert
      expect(result).toEqual(expectedUser);
    });
    
    it('should throw NotFoundError when id does not exist', async () => {
      // Arrange
      const userId = 'nonexistent';
      
      // Act & Assert
      await expect(
        userService.getUserById(userId)
      ).rejects.toThrow(NotFoundError);
    });
    
    it('should handle null id', async () => {
      // Arrange
      const userId = null;
      
      // Act & Assert
      await expect(
        userService.getUserById(userId)
      ).rejects.toThrow(ValidationError);
    });
  });
});
```

**必须测试的场景**:
```yaml
正常场景（Happy Path）:
  - 输入有效数据
  - 预期返回正确结果

边界场景（Edge Cases）:
  - 空值: null, undefined, ''
  - 零值: 0, [], {}
  - 最大值/最小值
  - 边界条件

异常场景（Error Cases）:
  - 无效输入
  - 类型错误
  - 业务规则违反
  - 网络错误
  - 超时

特殊场景:
  - 并发操作
  - 重复调用
  - 竞态条件
```

---

### 集成测试（Integration Test）

**定义**: 测试多个模块/组件的协作

**范围**:
```yaml
必须测试:
  - 模块间交互
  - 数据库操作
  - 外部API调用
  - 文件系统操作
  - 缓存操作
```

**测试文件位置**:
```
test/{模块名}-integration.test.js
```

**测试用例示例**:
```javascript
describe('User Registration Flow', () => {
  beforeEach(async () => {
    // 清理数据库
    await db.clean();
  });
  
  it('should create user and send welcome email', async () => {
    // Arrange
    const userData = {
      email: 'test@example.com',
      password: 'Test123!',
      name: 'Test User'
    };
    
    // Act
    const user = await userService.register(userData);
    
    // Assert
    expect(user.id).toBeDefined();
    expect(user.email).toBe(userData.email);
    
    // 验证数据库
    const dbUser = await db.users.findById(user.id);
    expect(dbUser).toBeDefined();
    
    // 验证邮件
    const emails = await emailService.getSentEmails();
    expect(emails).toHaveLength(1);
    expect(emails[0].to).toBe(userData.email);
  });
});
```

**必须测试的场景**:
```yaml
数据流:
  - 数据正确传递
  - 数据格式转换
  - 数据验证

事务:
  - 提交成功
  - 回滚正确
  - 并发安全

依赖:
  - 依赖正常工作
  - 依赖失败处理
  - 超时处理
```

---

### E2E测试（End-to-End Test）

**定义**: 测试完整的用户流程

**范围**:
```yaml
必须测试的流程:
  - 用户注册和登录
  - 核心业务流程
  - 支付流程
  - 数据提交流程

建议测试的流程:
  - 常见用户路径
  - 关键功能组合
```

**测试文件位置**:
```
test/{模块名}-e2e.test.js
```

**测试用例示例**:
```javascript
describe('Order Creation Flow', () => {
  it('should complete full order process', async () => {
    // 1. 登录
    await page.goto('/login');
    await page.fill('#email', 'user@example.com');
    await page.fill('#password', 'password');
    await page.click('#login-btn');
    
    // 2. 选择商品
    await page.goto('/products');
    await page.click('.product:first-child .add-to-cart');
    
    // 3. 结算
    await page.goto('/checkout');
    await page.fill('#address', 'Test Address');
    await page.click('#submit-order');
    
    // 4. 验证
    await expect(page.locator('.success-message')).toBeVisible();
    const orderId = await page.locator('.order-id').textContent();
    expect(orderId).toMatch(/^ORD-\d+$/);
  });
});
```

---

### API测试

**定义**: 测试HTTP接口

**范围**:
```yaml
必须测试:
  - 所有 API 端点
  - 各种 HTTP 方法
  - 请求/响应格式
  - 状态码
  - 错误处理
```

**测试文件位置**:
```
test/{模块名}-api.test.js
```

**测试用例示例**:
```javascript
describe('User API', () => {
  describe('GET /api/users/:id', () => {
    it('should return user when id exists', async () => {
      const response = await request(app)
        .get('/api/users/123')
        .expect(200);
      
      expect(response.body).toMatchObject({
        id: '123',
        email: expect.any(String),
        name: expect.any(String)
      });
    });
    
    it('should return 404 when user not found', async () => {
      const response = await request(app)
        .get('/api/users/nonexistent')
        .expect(404);
      
      expect(response.body).toMatchObject({
        error: 'User not found',
        code: 'USER_NOT_FOUND'
      });
    });
    
    it('should return 400 for invalid id format', async () => {
      await request(app)
        .get('/api/users/invalid-id')
        .expect(400);
    });
  });
  
  describe('POST /api/users', () => {
    it('should create user with valid data', async () => {
      const userData = {
        email: 'new@example.com',
        password: 'Test123!',
        name: 'New User'
      };
      
      const response = await request(app)
        .post('/api/users')
        .send(userData)
        .expect(201);
      
      expect(response.body).toMatchObject({
        id: expect.any(String),
        email: userData.email,
        name: userData.name
      });
      expect(response.body.password).toBeUndefined();
    });
  });
});
```

**必须测试的场景**:
```yaml
HTTP方法:
  - GET: 获取数据
  - POST: 创建数据
  - PUT/PATCH: 更新数据
  - DELETE: 删除数据

状态码:
  - 200: 成功
  - 201: 创建成功
  - 400: 请求错误
  - 401: 未认证
  - 403: 无权限
  - 404: 不存在
  - 500: 服务器错误

认证授权:
  - 无token访问
  - 无效token
  - 过期token
  - 权限不足

数据验证:
  - 必填字段
  - 字段类型
  - 字段格式
  - 字段长度
```

---

### 基准测试（Benchmark Test）

**定义**: 测试性能指标

**范围**:
```yaml
必须测试:
  - 核心算法性能
  - 数据库查询性能
  - API响应时间
  - 并发处理能力
```

**测试文件位置**:
```
test/{模块名}-benchmark.test.js
```

**测试用例示例**:
```javascript
describe('Performance Benchmarks', () => {
  it('should process 1000 items in under 100ms', async () => {
    const items = generateTestData(1000);
    
    const startTime = Date.now();
    const result = await processor.processItems(items);
    const endTime = Date.now();
    
    const duration = endTime - startTime;
    expect(duration).toBeLessThan(100);
  });
  
  it('should handle 100 concurrent requests', async () => {
    const requests = Array(100).fill(null).map(() =>
      request(app).get('/api/data')
    );
    
    const startTime = Date.now();
    await Promise.all(requests);
    const endTime = Date.now();
    
    const duration = endTime - startTime;
    expect(duration).toBeLessThan(1000);
  });
});
```

**性能指标**:
```yaml
响应时间:
  优秀: < 50ms
  良好: 50-100ms
  可接受: 100-500ms
  警告: > 500ms

吞吐量:
  优秀: > 1000 req/s
  良好: 500-1000 req/s
  可接受: 100-500 req/s
  警告: < 100 req/s

内存使用:
  优秀: < 100MB
  良好: 100-500MB
  警告: > 500MB
```

---

## 📝 测试命名规范

### 测试文件命名

```yaml
格式: {模块名}-{类型}.test.{ext}

示例:
  user-auth-unit.test.js
  order-integration.test.js
  payment-e2e.test.js
  api-api.test.js
  search-benchmark.test.js

禁止:
  userAuth.test.js
  user_auth_test.js
  test-user-auth.js
```

### 测试用例命名

```yaml
格式: should {action} when {condition}

示例:
  ✅ 好的命名:
    it('should return user when id exists')
    it('should throw error when password is invalid')
    it('should update status when payment succeeds')
  
  ❌ 不好的命名:
    it('test user')
    it('getUserById')
    it('works correctly')

describe命名:
  格式: 模块名/类名/函数名
  
  示例:
    describe('UserService', () => {
      describe('getUserById', () => {
        it('should...')
      })
    })
```

---

## 🛠️ 测试工具和框架

### 推荐工具

```yaml
JavaScript/TypeScript:
  测试框架: Jest, Mocha
  断言库: Jest (内置), Chai
  Mock工具: Jest (内置), Sinon
  E2E工具: Playwright, Cypress
  覆盖率: Jest (内置), NYC
  
Python:
  测试框架: pytest, unittest
  Mock工具: unittest.mock, pytest-mock
  覆盖率: pytest-cov
  
HTTP测试:
  supertest (Node.js)
  requests (Python)
```

### Mock规范

```yaml
什么时候Mock:
  必须Mock:
    - 外部API调用
    - 数据库操作（单元测试）
    - 文件系统操作
    - 时间相关操作
    - 随机数生成
  
  不应该Mock:
    - 被测试的代码
    - 简单的工具函数
    - 常量和配置

Mock示例:
  // Mock 外部API
  jest.mock('axios');
  axios.get.mockResolvedValue({ data: mockData });
  
  // Mock 数据库
  jest.mock('./database');
  database.query.mockResolvedValue(mockResult);
  
  // Mock 时间
  jest.useFakeTimers();
  jest.setSystemTime(new Date('2025-01-01'));
```

---

## ✅ 测试质量检查

### 测试代码质量

```yaml
必须遵守:
  - 测试代码也要遵守代码规范
  - 测试要清晰易懂
  - 避免测试之间相互依赖
  - 每个测试只测试一件事
  - 使用有意义的测试数据

测试结构 (AAA模式):
  Arrange (准备):
    - 设置测试数据
    - 配置mock
    - 初始化状态
  
  Act (执行):
    - 调用被测函数
    - 执行操作
  
  Assert (断言):
    - 验证结果
    - 检查副作用
    - 确认状态变化
```

### 测试独立性

```yaml
原则: 每个测试应该独立运行

避免:
  ❌ 测试顺序依赖:
    it('test 1', () => {
      globalState.value = 1;
    });
    
    it('test 2', () => {
      expect(globalState.value).toBe(1);  // 依赖test 1
    });
  
  ✅ 正确做法:
    beforeEach(() => {
      globalState.value = 1;
    });
    
    it('test 2', () => {
      expect(globalState.value).toBe(1);
    });

清理资源:
  afterEach(async () => {
    await db.clean();
    await cache.clear();
    jest.clearAllMocks();
  });
```

---

## 📊 测试报告

### 测试结果格式

```yaml
必须包含:
  - 测试通过/失败数量
  - 测试覆盖率
  - 失败的测试详情
  - 测试执行时间

报告示例:
  Test Suites: 5 passed, 5 total
  Tests:       42 passed, 42 total
  Snapshots:   0 total
  Time:        5.234s
  
  Coverage:
    Statements   : 85.23% ( 245/287 )
    Branches     : 78.45% ( 112/143 )
    Functions    : 91.67% ( 55/60 )
    Lines        : 84.89% ( 235/277 )
```

### 失败测试处理

```yaml
IF: 测试失败
THEN:
  1. 记录详细错误信息
  2. 记录堆栈跟踪
  3. 记录测试输入数据
  4. 记录预期输出
  5. 记录实际输出
  
  提供选项:
    A) 修复代码
    B) 修复测试
    C) 标记为已知问题 (SKIP)
```

---

## 🎯 测试策略

### 测试金字塔

```yaml
比例分配:
  单元测试: 70%
  集成测试: 20%
  E2E测试: 10%

原因:
  - 单元测试快速、稳定、易维护
  - 集成测试覆盖模块协作
  - E2E测试覆盖关键流程

投入产出:
  单元测试: 成本低、价值高
  集成测试: 成本中、价值中
  E2E测试: 成本高、价值高（关键流程）
```

### 什么时候写测试

```yaml
TDD (测试驱动开发) - 不推荐:
  流程: 先写测试 → 再写代码
  
传统模式 - 推荐:
  流程: 先写代码 → 再写测试
  
  原因:
    - 符合实际开发流程
    - 代码完成后更容易写测试
    - 可以根据实际代码调整测试

时机:
  STEP 11: 编写测试用例
  位置: 代码开发完成后，用户确认代码后
```

---

## ⚠️ 常见问题

### 避免的反模式

```yaml
❌ 测试实现细节:
  // 不好 - 测试内部实现
  expect(obj._privateMethod).toHaveBeenCalled();
  
  // 好 - 测试公开行为
  expect(obj.getResult()).toBe(expected);

❌ 过度Mock:
  // 不好 - mock一切
  jest.mock('./utils');
  jest.mock('./helpers');
  jest.mock('./validators');
  
  // 好 - 只mock必要的外部依赖
  jest.mock('axios');

❌ 脆弱的测试:
  // 不好 - 依赖具体数字
  expect(result.length).toBe(5);
  
  // 好 - 测试行为
  expect(result).toContain(expectedItem);

❌ 测试过大:
  it('should do everything', () => {
    // 100 lines of test code
  });
  
  // 好 - 拆分为多个小测试
  it('should do A', () => { /* ... */ });
  it('should do B', () => { /* ... */ });
```

---

**文件创建**: 2025-11-20  
**最后更新**: 2025-11-20  
**状态**: ✅ 完整

