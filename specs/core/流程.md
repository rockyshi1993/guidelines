# v3 核心执行流程

> **文件**: specs/core/流程.md  
> **版本**: v3.0  
> **日期**: 2025-11-20  
> **说明**: 完整的 STEP 0-22 执行流程

---

## 📑 目录导航

> 🔴 = 必读/必执行 | 🟡 = 重要 | 🟢 = 参考

- [完整流程（23个STEP）](#-完整流程23个step) 🔴 - 主执行流程
  - [🔴 STEP 0: Profile & 禁止项扫描](#-step-0-profile--禁止项扫描最高优先级) 🔴 - 最高优先级，任何操作前必须执行
  - [🟢 STEP 1: 分析用户意图](#-step-1-分析用户意图) 🔴 - 识别18种意图之一
  - [🟢 STEP 2: 确定涉及的规范文件](#-step-2-确定涉及的规范文件) 🔴 - 根据意图选择规范
  - [🟡 STEP 3: 检查项目规范](#-step-3-检查项目规范) 🟡 - Profile优先机制
  - [🟡 STEP 4: 解决规范冲突](#-step-4-解决规范冲突) 🟡 - 冲突解决规则
  - [🔵 STEP 5: 确定执行顺序](#-step-5-确定执行顺序) 🟡 - 全面分析和规划
  - [📝 STEP 6: 生成需求分析报告](#-step-6-生成需求分析报告) 🔴 - 输出临时方案
  - [⚠️ STEP 7: 用户确认执行计划](#️-step-7-用户确认执行计划) 🔴 - 第1个确认点，P0风险强制确认
  - [🔧 STEP 8: 固定执行流程](#-step-8-固定执行流程) 🔴 - 唯一流程：代码→测试→验证→文档
  - [💻 STEP 9: 代码开发](#-step-9-代码开发) 🔴 - 遵守代码规范和安全规范
  - [⚠️ STEP 10: 用户确认代码](#️-step-10-用户确认代码) 🔴 - 第2个确认点，展示改动清单
  - [🧪 STEP 11: 编写测试用例](#-step-11-编写测试用例) 🔴 - 覆盖率≥80%
  - [⚠️ STEP 12: 用户确认测试用例](#️-step-12-用户确认测试用例) 🔴 - 第3个确认点
  - [▶️ STEP 13: 运行测试验证](#️-step-13-运行测试验证) 🔴 - 必须100%通过
  - [⚠️ STEP 14: 用户确认测试结果](#️-step-14-用户确认测试结果) 🔴 - 第4个确认点，失败则循环修复
  - [📚 STEP 15: 更新文档](#-step-15-更新文档) 🔴 - 4种文档同步更新
  - [⚠️ STEP 16: 用户确认文档](#️-step-16-用户确认文档) 🔴 - 第5个确认点，包含Swagger
  - [✅ STEP 17: 质量验证](#-step-17-质量验证) 🔴 - 最终质量检查
  - [📄 STEP 18: 生成执行结果报告](#-step-18-生成执行结果报告) 🟡 - 完整审计日志
  - [⚠️ STEP 19: 最终用户确认](#️-step-19-最终用户确认) 🔴 - 最后机会返回修改
  - [💾 STEP 20: 写入文件](#-step-20-写入文件) 🔴 - 执行实际文件写入
  - [📦 STEP 21: 提交（可选）](#-step-21-提交可选) 🟢 - 用户选择提交方式
  - [🗃️ STEP 22: 存档和清理](#️-step-22-存档和清理) 🟡 - 清理临时文件
- [🔄 循环修复流程](#-循环修复流程) 🟡 - 允许循环的STEP和条件
- [📊 风险等级定义](#-风险等级定义) 🔴 - P0/P1/P2定义和处理

---

## 📚 相关规范文件

**必须配合使用的规范**:
- 📦 [意图分类.md](./意图分类.md) 🔴 - STEP 1使用，识别18种意图
- 📦 [目录结构.md](./目录结构.md) 🔴 - STEP 6/20使用，确定文件位置
- 📐 [代码规范.md](../rules/代码规范.md) 🔴 - STEP 9使用，代码质量标准
- 📐 [测试规范.md](../rules/测试规范.md) 🔴 - STEP 11使用，测试覆盖率要求
- 📐 [安全规范.md](../rules/安全规范.md) 🔴 - STEP 9使用，敏感信息检测
- 📐 [文档规范.md](../rules/文档规范.md) 🔴 - STEP 15使用，文档更新规则
- 📐 [API规范.md](../rules/API规范.md) 🟡 - STEP 15使用，Swagger生成
- 📄 [报告模板.md](../output/报告模板.md) 🔴 - STEP 6/18使用，报告格式

**Profile优先**:
- 🔴 如果 `guidelines/profiles/{project}.md` 存在，优先使用项目规范
- 🔴 STEP 0 必须首先读取 Profile

---

## 📋 完整流程（23个STEP）

### 🔴 STEP 0: Profile & 禁止项扫描（最高优先级）

**目的**: 在任何操作前，先读取项目规范和禁止项

**执行步骤**:
1. 检查 `guidelines/profiles/{project}.md` 是否存在
2. IF 存在：
   - 读取 Profile → 识别项目特定规范
   - 禁止项（Service层/DTO/特定模式）
   - 技术栈约束（语言/框架/库版本）
   - 目录结构定义
   - 命名规范定义
   - 脚本语言约束（shell/py/ts/js）
3. ELSE：使用默认规范
4. 扫描禁止删除项：
   - 禁止删除现有 import/require
   - 禁止删除现有路由/函数
   - 禁止删除现有配置
   - 除非用户书面明确确认
5. 构建规范上下文（贯穿整个流程）

**参考**: docs/紧急规范更新-严禁删除现有代码.md

---

### 🟢 STEP 1: 分析用户意图

**目的**: 理解用户想要做什么

**执行步骤**:
1. 识别意图类别（18种之一）
2. 确定操作类型（修复/开发/审查/文档等）
3. 初步判断涉及范围

---

### 🟢 STEP 2: 确定涉及的规范文件

**目的**: 根据意图类型确定需要应用哪些规范

**执行步骤**:
1. 根据意图类型和 STEP 0 的 Profile 结果
2. 代码类意图 → 代码规范 + 测试规范
3. 文档类意图 → 文档规范
4. 配置类意图 → 配置规范
5. 脚本类意图 → 脚本规范（遵从Profile指定的语言）
6. 所有意图 → 应用 STEP 0 的项目规范

---

### 🟠 STEP 3: 应用通用规范

**目的**: 应用相应的通用规范

**执行步骤**:
根据 STEP 2 确定的规范类型：
- 代码质量规范（命名/结构/注释）
- 测试规范（覆盖率/测试类型）
- 安全规范（敏感信息/权限）
- 文档规范（同步/格式）
- 脚本规范（格式/命名，优先使用Profile指定的语言）
- 配置规范（结构/环境）

---

### 🔴 STEP 4: 规范冲突解决 + 禁止删除验证

**目的**: 解决项目规范与通用规范的冲突，验证禁止删除

**执行步骤**:
1. IF 项目规范 与 通用规范 冲突
   - 优先级: 项目规范 > 通用规范
   - 应用: 项目规范
   - 记录: 冲突项和解决方案
2. 禁止删除验证:
   - ✅ 确认不删除现有 import/require
   - ✅ 确认不删除现有路由/函数
   - ✅ 确认不删除现有配置
   - ❌ 如需删除，必须获得用户书面明确确认

**"书面明确确认"的标准格式**:
```yaml
IF: 需要删除现有代码
THEN:
  1. 展示将要删除的内容清单:
     - 列出所有将被删除的import/require
     - 列出所有将被删除的函数/类/路由
     - 列出所有将被删除的配置项
  
  2. 要求用户明确确认，必须包含:
     格式: "我已理解删除影响，明确同意删除以下内容：{清单}"
     
     示例:
       "我已理解删除影响，明确同意删除以下内容：
        - import { OldService } from './old-service'
        - function oldFunction()
        - route /api/old-endpoint"
  
  3. 记录用户确认到审计日志
  
  4. IF: 用户未按格式确认 OR 用户拒绝
     THEN: 拒绝执行删除操作
```

**参考**: docs/紧急规范更新-严禁删除现有代码.md

---

### 📋 STEP 5: 全面分析意图中的项目

**目的**: 深度分析项目，识别影响范围

**执行步骤**:

#### 5.1 模块依赖分析
- 使用依赖图工具识别影响范围
- 检查 import/require 关系
- 识别循环依赖
- 绘制依赖关系图

#### 5.2 代码影响分析
- 函数调用链分析
- 数据流分析
- 副作用识别
- 评估改动复杂度

#### 5.3 测试覆盖分析
- 检查现有测试覆盖率
- 识别缺失的测试场景
- 确定需要新增的测试类型
- 评估测试工作量

#### 5.4 文档影响分析
- 识别需要更新的文档
- 检查 API 变更影响
- 评估示例代码更新需求
- 确定 Swagger 文档更新范围

#### 5.5 风险点识别
- 识别潜在的破坏性变更
- 评估性能影响
- 检查安全风险
- 评估兼容性问题

#### 5.6 工具辅助分析
- 静态代码分析工具
- 依赖可视化工具
- 测试覆盖率工具
- 代码复杂度分析工具

#### ⚠️ 分段处理机制

**触发条件**: 预估分析时间 > 5分钟

**分段策略**:
1. 按模块分段（每个模块单独分析）
2. 每段分析完成后立即保存
3. 暂存文件路径: `/reports/{模块名}/.temp/analysis-part-{N}.md`
4. 文件命名规则: `analysis-part-{序号}-{模块名}-{timestamp}.md`
5. 合并策略: 在 STEP 6 中合并所有 part-N 文件

**暂存文件格式**:
```markdown
---
分段序号: 1/N
分析模块: user-auth
分析时间: 2025-11-20 14:30:00
依赖关系: [list]
---
[分析内容]
```

**合并规则**:
- 保留所有分段的分析结果
- 合并依赖关系图
- 汇总风险点
- 生成统一的操作清单

---

### 📊 STEP 6: 生成分析报告（临时方案）

**目的**: 生成完整的执行计划报告

**执行步骤**:

#### 6.1 合并分段分析（如有）
IF 存在分段分析文件：
1. 读取所有 `analysis-part-N.md` 文件
2. 合并依赖关系图
3. 汇总所有风险点
4. 生成统一的操作清单
5. 保存到: `/reports/{模块名}/.temp/analysis-plan-{timestamp}.md`
6. 清理分段文件（保留到最终确认）

#### 6.2 报告内容
- 任务概述
- 涉及的文件和模块
- 将要执行的操作清单
  - 代码改动清单
  - 测试用例清单
  - 文档更新清单
  - 配置修改清单
- 输出路径规划
  - 报告: `/reports/{模块名}/.temp/`
  - 方案: `/plans/{模块名}/`
  - 文档: `/docs/{模块名}/`
  - 测试: `/test/`
  - 脚本: `/scripts/`
  - 配置: `/configs/`
  - 部署: `/deploy/`
- 执行流程（固定）
  1. 先执行代码开发
  2. 编写测试用例
  3. 运行测试验证
  4. 如果发现问题 → 修复代码 → 重新测试
  5. 测试通过后 → 更新文档
- 风险评估（P0/P1/P2）+ P0操作清单
- 预期影响范围
- 时间预估

#### 6.3 报告格式
- 分级展示: 执行摘要 + 技术详情 + 附录
- 可视化: 依赖关系图(Mermaid) + 风险矩阵
- 颜色标记: 🟢安全 🟡警告 🔴危险
- 图标: ✅成功 ⚠️警告 ℹ️信息

**保存位置**: `/reports/{模块名}/.temp/analysis-plan-{timestamp}.md`

---

### ⚠️ STEP 7: 用户确认执行计划（含P0风险强制确认）

**目的**: 获得用户对执行计划的确认

**执行步骤**:

#### 7.1 展示分析报告
- 展示临时方案
- 显示进度: `[=====>    ] 37% (STEP 7/23)`

#### 7.2 P0风险强制确认

**P0风险判断标准**:
```yaml
删除操作（任何删除都需要P0确认）:
  - 删除任何现有import/require
  - 删除任何现有函数/类/方法
  - 删除任何现有路由/端点
  - 删除任何现有配置项

大规模重构（符合以下任一条件）:
  - 修改代码行数 > 100行
  - 影响文件数 > 5个
  - 修改核心业务逻辑
  - 改变API接口定义
  - 修改数据模型

数据库迁移（任何数据库变更）:
  - 新增/删除/修改表结构
  - 新增/删除/修改索引
  - 数据迁移脚本
  - 修改数据库配置

生产部署（任何生产环境操作）:
  - 部署到生产环境
  - 修改生产配置
  - 回滚生产版本
```

IF 报告中包含 P0 高风险操作：
1. 展示 P0 操作清单:
   - 删除操作: [列出具体内容]
   - 大规模重构: [列出重构范围，包含具体数字]
   - 数据库迁移: [列出迁移计划]
   - 生产部署: [列出部署内容]
2. 必须获得用户正面确认: "我已理解以上 P0 风险操作，明确同意执行"
3. IF 用户不同意任何 P0 操作 → 返回 STEP 5 调整方案，或终止流程

#### 7.3 用户选择
- **用户要求调整**: 更新临时方案 → 返回 STEP 5 重新分析
- **用户同意**: 
  - 将临时方案升级为最终方案
  - 保存到: `/reports/{模块名}/final/implementation-plan-{timestamp}.md`
  - 清除所有 `.temp/` 临时方案和分段文件
  - 继续执行
- **用户取消**: 清除临时方案 → 生成取消记录 → 终止流程

---

### 🔧 STEP 8: 执行流程（固定顺序）

**目的**: 明确唯一的执行流程

**执行顺序**:
1. 先执行代码开发
2. 编写测试用例
3. 运行测试验证
4. 如果测试发现问题 → 修复代码 → 重新测试
5. 测试通过后 → 更新文档

**注意**: 这是唯一的执行流程，不再有TDD/传统/基准模式选择

---

### 🔧 STEP 9: 执行代码开发（含禁止删除复核）

**目的**: 完成代码开发

**执行步骤**:

#### 9.1 执行前复核
- ✅ 再次确认不删除现有 import/require
- ✅ 再次确认不删除现有路由/函数
- ✅ 再次确认不删除现有配置
- ✅ 再次确认 P0 风险操作已获得用户正面确认
- ❌ 如发现任何删除操作未确认，立即暂停并要求确认

#### 9.2 进度显示
```
[========>     ] 47% (STEP 9/23)
当前: 正在执行代码开发...
预计剩余时间: 约 10 分钟
```

#### 9.3 代码开发
- 修复Bug / 开发新功能 / 重构代码 / 性能优化
- 实时质量检查:
  - 实时 lint 检查（保存时自动）
  - 实时 format（保存时自动）
  - 实时复杂度提示
  - 敏感信息检测（实时警告）
- 生成代码到指定位置

#### 9.4 敏感信息检测
- 硬编码密码/API Key → 立即警告
- 敏感URL/IP地址 → 建议使用环境变量
- 个人身份信息(PII) → 提示脱敏处理

#### 9.5 影响范围三重检查（🔴 强制执行）

**目的**: 确保代码改动不破坏原有功能和兼容性

**检查频次**: 必须检查 **3遍**，每遍侧重不同方面

**第一遍 - 功能影响检查**:
```yaml
检查项:
  - 现有函数调用是否受影响（参数、返回值、行为）
  - 现有接口是否保持兼容（URL、请求/响应格式）
  - 现有配置是否仍然有效
  - 现有数据结构是否仍然兼容
  - 现有业务流程是否完整

检查方法:
  - 静态分析: 检查所有调用点
  - 类型检查: TypeScript类型是否仍然匹配
  - 接口对比: 新旧接口签名对比

记录格式:
  影响范围:
    - ✅ 无破坏性变更
    - ⚠️ 兼容性变更（需要迁移指南）
    - 🔴 破坏性变更（必须用户确认）
```

**第二遍 - 依赖关系检查**:
```yaml
检查项:
  - 上游依赖: 哪些模块调用了修改的代码
  - 下游依赖: 修改的代码依赖哪些模块
  - 循环依赖: 是否引入新的循环依赖
  - 副作用: 是否影响全局状态、缓存、数据库
  - 性能影响: 是否影响关键路径性能

检查方法:
  - 依赖图分析
  - 调用链追踪
  - 性能基准对比

记录格式:
  依赖影响:
    - 上游影响: [列出受影响的模块]
    - 下游影响: [列出依赖的模块]
    - 新增依赖: [列出新增的依赖]
    - 性能影响: [预估性能变化]
```

**第三遍 - 兼容性检查**:
```yaml
检查项:
  - 向后兼容: 是否保持向后兼容
  - API版本: 是否需要升级API版本
  - 数据迁移: 是否需要数据迁移脚本
  - 配置迁移: 是否需要配置迁移
  - 部署影响: 是否需要特殊部署步骤
  - 回滚方案: 是否可以安全回滚

检查方法:
  - 版本对比
  - 迁移路径规划
  - 回滚测试

记录格式:
  兼容性评估:
    - 向后兼容: ✅是 / ❌否
    - 需要迁移: ✅是 / ❌否
    - 可安全回滚: ✅是 / ❌否
    - 部署注意事项: [列出]
```

**检查结果整合**:
```yaml
影响范围总结:
  功能影响:
    - 修改的函数: [列表]
    - 影响的接口: [列表]
    - 破坏性变更: [列表]
  
  依赖影响:
    - 上游模块: [列表]
    - 下游模块: [列表]
    - 性能影响: [说明]
  
  兼容性:
    - 向后兼容: [是/否]
    - 迁移方案: [说明]
    - 回滚方案: [说明]
  
  风险等级: 🟢低风险 / 🟡中等风险 / 🔴高风险
```

**强制要求**:
- ❌ 如果跳过任何一遍检查 → 拒绝进入 STEP 10
- ❌ 如果发现破坏性变更未记录 → 返回重新检查
- ✅ 所有检查结果必须记录到报告中
- ✅ 高风险变更必须在 STEP 10 中向用户展示

#### 9.6 错误处理
IF 代码生成失败：
- 记录错误原因
- 展示错误详情
- 选项: A)重试 B)调整需求 C)跳过

**输出**: 
- 代码改动清单
- 影响范围三重检查报告（必须包含）

---

### ⚠️ STEP 10: 用户确认代码

**目的**: 让用户确认代码是否符合需求

**执行步骤**:

#### 10.1 展示内容
- 代码改动清单
- 修改的文件列表
- 新增的功能说明
- 代码质量检查结果（实时检查）
- **🔴 影响范围三重检查报告（必须展示）**:
  - 功能影响评估
  - 依赖关系分析
  - 兼容性评估
  - 风险等级标识

#### 10.2 用户选择
- **用户同意代码**: 继续 STEP 11
- **用户要求修改代码**: 返回 STEP 9 修改代码
- **用户取消**: 终止流程

---

### 📝 STEP 11: 编写测试用例

**目的**: 根据已完成的代码编写测试

**执行步骤**:

#### 11.1 目录检测与适配
```
IF: Profile 指定测试目录
  使用 Profile 指定的目录
ELSE IF: 项目已有 test/ 目录
  使用 test/ 结构
ELSE IF: 项目已有 tests/ 目录
  使用 tests/ 结构
ELSE:
  创建 test/ 结构（推荐单数形式）
```

#### 11.2 测试文件生成
```
格式: {模块名}-{类型}.test.js

生成位置:
- 单元测试: test/{模块名}-unit.test.js
- 集成测试: test/{模块名}-integration.test.js
- E2E测试: test/{模块名}-e2e.test.js
- API测试: test/{模块名}-api.test.js
- 基准测试: test/{模块名}-benchmark.test.js

注意: 
- 测试文件不分子目录，直接在test/根目录
- 文件名格式: {模块名}-{类型}.test.js
- 根据已完成的代码编写测试
```

#### 11.3 错误处理
IF 测试代码编译失败：
- 检查语法错误
- 提供修复建议
- 选项: A)自动修复 B)手动修复 C)跳过

---

### ⚠️ STEP 12: 用户确认测试用例

**目的**: 让用户确认测试用例是否完整

**执行步骤**:

#### 12.1 展示内容
- 测试文件清单
- 测试覆盖范围
- 预期测试场景

#### 12.2 用户选择
- **用户同意测试用例**: 继续 STEP 13
- **用户要求修改测试**: 返回 STEP 11 修改测试
- **用户取消**: 跳过测试（不推荐）

---

### ✅ STEP 13: 运行测试验证

**目的**: 运行测试，确保代码正确

**执行步骤**:

#### 13.1 运行测试
- 运行所有相关测试
- 检查测试覆盖率
- 确保所有测试通过

#### 13.2 错误处理
IF 测试执行失败：
- 分析失败原因（代码问题/测试问题）
- 展示失败的测试用例和堆栈跟踪
- 选项: 
  - A) 修复代码 → 返回 STEP 9
  - B) 修复测试 → 返回 STEP 11
  - C) 标记为已知问题

**循环修复**: 测试失败时可以返回修改代码或测试，直到通过

---

### ⚠️ STEP 14: 用户确认测试结果

**目的**: 让用户确认测试结果

**执行步骤**:

#### 14.1 展示内容
- 测试通过/失败统计
- 测试覆盖率
- 失败的测试用例（如有）
- 性能指标（如有基准测试）

#### 14.2 用户选择
- **所有测试通过且用户同意**: 继续 STEP 15
- **测试失败或用户要求修改**: 返回 STEP 9 或 STEP 11
- **用户接受已知问题**: 记录问题，继续 STEP 15

---

### 📚 STEP 15: 生成和更新文档

**目的**: 生成完整的文档

**执行步骤**:

#### 15.1 更新模块文档
- `/docs/{模块名}/README.md`
- `/docs/{模块名}/api/endpoints.md`
- `/docs/{模块名}/api/openapi.yaml`（根据接口自动生成Swagger）
- `/docs/{模块名}/examples/`

#### 15.2 检查并更新实现方案

**架构或流程变化判断标准**:
```yaml
架构变化包括:
  - 新增/删除/重命名 类/模块/文件
  - 修改模块间依赖关系
  - 改变数据模型结构
  - 修改数据库schema
  - 改变API接口定义（端点/参数/返回值）
  - 引入新的设计模式
  - 改变模块职责划分

流程变化包括:
  - 修改业务流程步骤
  - 改变函数调用顺序
  - 新增/删除关键业务逻辑
  - 修改错误处理流程
  - 改变数据处理流程
  - 修改认证/授权流程
  - 改变事务处理方式

判断逻辑:
  IF: 代码改动符合以上任一条件
  THEN: 
    必须更新 plans/{模块名}/IMPLEMENTATION.md
  ELSE: 
    仅更新 plans/{模块名}/CHANGELOG.md

示例:
  需要更新IMPLEMENTATION.md:
    - 将UserService拆分为UserService和AuthService
    - 新增缓存层
    - 修改订单状态流转逻辑
    - API从RESTful改为GraphQL
  
  不需要更新IMPLEMENTATION.md:
    - 优化函数内部算法
    - 修复bug
    - 调整代码格式
    - 更新注释
```

IF 代码改动涉及架构或流程变化：
1. 读取当前 `plans/{模块名}/IMPLEMENTATION.md`
2. 识别需要更新的部分
3. 更新实现方案文档
4. 记录版本变更
5. 说明修改原因和影响范围
6. ⚠️ 强制验证: 确保文档与代码一致

#### 15.3 更新模块状态
- 更新 `plans/{模块名}/STATUS.md`
- 更新进度百分比
- 更新健康状态
- 记录最新活动

#### 15.4 更新模块变更日志
- 详细记录到 `plans/{模块名}/CHANGELOG.md`
- 包含每次修改、优化、修复内容
- 比根目录 CHANGELOG 更详细

#### 15.5 更新根目录概览（如有必要）
IF 模块状态发生重大变化：
- 更新根目录 `STATUS.md`（项目概况）
- 更新根目录 `CHANGELOG.md`（仅概览，不详细）

---

### ⚠️ STEP 16: 用户确认文档

**目的**: 让用户确认文档

**执行步骤**:

#### 16.1 展示内容
- 文档清单
- API文档预览
- Swagger文档链接
- 使用示例
- 变更日志

#### 16.2 用户选择
- **用户同意文档**: 继续 STEP 17
- **用户要求修改文档**: 返回 STEP 15 修改文档
- **用户取消**: 跳过文档更新（不推荐）

---

### ✅ STEP 17: 代码质量最终验证

**目的**: 最终质量检查

**执行步骤**:

#### 17.1 质量检查
- 运行 lint 检查
- 运行 format 检查
- 检查代码复杂度
- 验证依赖完整性
- 安全扫描（如需要）
- 文档同步验证（IMPLEMENTATION.md与代码一致性）
- **🔴 复核影响范围三重检查结果（必须复核）**:
  - 验证所有功能影响已识别
  - 验证所有依赖关系已分析
  - 验证所有兼容性问题已评估
  - 确认所有高风险项已处理
- 生成质量报告

#### 17.2 错误处理
**Lint 检查失败**:
- 展示具体错误位置和原因
- 选项: A)自动修复 B)手动修复 C)忽略（不推荐）

**安全扫描发现问题**:
- 按严重程度分级展示
- 必须修复高危问题才能继续

**文档不同步**:
- 标记需要更新的文档
- 返回 STEP 15 更新文档

**影响范围检查不完整**:
- 返回 STEP 9 重新进行三重检查
- 补充缺失的检查项

---

### 📊 STEP 18: 生成执行结果报告

**目的**: 生成完整的执行结果报告

**执行步骤**:

#### 18.1 报告内容
- 已完成的代码改动（文件清单）
- 已编写的测试用例（数量/覆盖率）
- 测试执行结果（通过/失败统计）
- 已更新的文档（文件清单）
- 代码质量检查结果
- 生成的所有文件清单
- 用户确认记录（STEP 10/12/14/16）
- 错误统计（如有）
- 执行时间统计

#### 18.2 报告格式
- 分级展示: 执行摘要 + 技术详情 + 附录
- 可视化: 进度甘特图 + 质量仪表盘
- 报告脱敏: 密码→****** / API Key→abc***xyz

**保存位置**: `/reports/{模块名}/final/execution-result-{timestamp}.md`

---

### ✅ STEP 19: 用户最终确认

**目的**: 最终确认是否应用

**执行步骤**:

#### 19.1 展示执行结果报告

#### 19.2 用户选择
- **同意应用**: 继续 STEP 20
- **要求修改**: 指出修改点 → 返回相应 STEP → 修改后重新验证（允许循环修改，不限制次数）
- **取消应用**: 保留生成的文件在工作区，不应用到代码库 → 生成取消记录

---

### 🎯 STEP 20: 写入文件到工作区

**目的**: 将所有文件写入工作区

**执行步骤**:

#### 20.1 写入文件
- 写入所有生成的文件到工作区
- 更新 CHANGELOG 文件
- 生成文件清单

#### 20.2 权限验证
- 检查目标目录写入权限
- 确保敏感文件不会提交（检查 .gitignore）
- 验证密钥文件权限（600）

#### 20.3 错误处理
IF 文件写入失败：
- 检查权限问题
- 检查磁盘空间
- 选项: A)重试 B)更改路径 C)取消

#### 20.4 审计日志
记录所有文件操作：
- 写入的文件路径
- 写入时间
- 操作用户
- 是否包含敏感信息

---

### 📋 STEP 21: 用户选择提交方式（含审计链条记录）

**目的**: 决定如何处理变更

**执行步骤**:

#### 21.1 选项 A: 提交到代码库
- 执行 git add
- 执行 git commit -m "message"
- 记录 commit ID
- 打标签（如需要）
- 推送到远程（可选）

**审计记录**:
- 提交方式: A (提交到代码库)
- Commit ID: [记录实际commit ID]
- 提交时间: [timestamp]
- 提交者: [user]
- 提交信息: [commit message]

#### 21.2 选项 B: 仅保存文件，不提交
- 文件已写入工作区
- 用户自行决定何时提交

**审计记录**:
- 提交方式: B (仅保存文件)
- 工作副本状态: [记录当前 git status]
- 未提交文件清单: [列出所有修改的文件]
- 保存时间: [timestamp]

#### 21.3 选项 C: 继续修改
- 返回 STEP 19 重新确认
- 允许循环，不限制次数

**审计记录**:
- 提交方式: C (继续修改)
- 返回次数: [记录循环次数]
- 返回时间: [timestamp]

#### 21.4 审计链条保持
无论选择 A/B/C，必须在 STEP 22 存档里记录：
- 用户选择的提交方式
- Commit ID（选项A）或工作副本状态（选项B/C）
- 完整的文件变更历史
- 用户确认记录

---

### 📊 STEP 22: 回顾与存档（含审计链条）

**目的**: 存档所有信息，清理临时文件

**执行步骤**:

#### 22.1 生成最终执行摘要

#### 22.2 更新项目日志

#### 22.3 归档所有报告
保存到 `/reports/{模块名}/final/`：
- 分析报告（最终方案）
- 执行结果报告
- 错误统计报告（如有）
- 审计日志（完整链条）
  - Profile 扫描记录
  - 禁止删除验证记录
  - P0 风险确认记录
  - 用户选择记录（STEP 21）
  - Commit ID 或工作副本状态
  - 文件变更历史
- 经验教训记录

#### 22.4 清理临时文件
- 清理所有 `.temp/` 临时文件
- 清理分段分析文件

#### 22.5 记录执行统计
- 总执行时间
- 各STEP耗时
- 资源使用情况
- 遇到的问题和解决方案

#### 22.6 生成改进建议

---

## 🔄 循环修复流程

### 循环控制机制 🔴

**目的**: 防止无限循环，确保流程可控

**核心原则**:
```yaml
最大循环次数: 3次
超过后: 生成错误报告，提示用户手动介入
循环计数器: 每个循环点独立计数
重置时机: 新任务开始时，或成功完成某个循环点
```

---

### 循环点1: STEP 13→14 测试失败循环 🔴

**场景**: 测试失败需要修复代码

**循环控制**:
```yaml
最大循环次数: 3次

循环策略:
  第1次失败:
    - 分析测试失败原因
    - 自动修复代码中的明显错误
    - 重新运行测试
    - 记录: retryCount = 1
    
  第2次失败:
    - 深度分析失败原因
    - 调整测试策略(如降低覆盖率要求)
    - 或优化代码实现
    - 重新运行测试
    - 记录: retryCount = 2
    
  第3次失败:
    - 最后尝试修复
    - 如果仍失败，生成详细错误报告
    - 记录: retryCount = 3
    
  超过3次:
    - 终止循环
    - 生成完整的失败分析报告:
      * 所有失败的测试用例
      * 失败原因分析
      * 已尝试的修复方案
      * 建议的手动修复步骤
    - 提示用户: "已尝试3次修复均失败，建议手动介入"
    - 选项:
      A) 用户手动修复后重新运行
      B) 降低质量标准继续
      C) 终止任务

状态持久化:
  位置: /reports/{模块名}/.temp/state.json
  内容:
    {
      "loopPoint": "STEP13-14",
      "retryCount": 2,
      "lastError": "3个测试用例失败",
      "timestamp": "2025-11-21T10:30:00Z"
    }
```

**实现示例**:
```javascript
class TestLoopController {
  constructor() {
    this.maxRetries = 3;
    this.retryCount = 0;
  }
  
  async step13_to_14_loop() {
    while (this.retryCount < this.maxRetries) {
      // STEP 13: 运行测试
      const testResult = await this.runTests();
      
      if (testResult.passed) {
        // 测试通过，重置计数器
        this.retryCount = 0;
        return { success: true, result: testResult };
      }
      
      // 测试失败，增加计数
      this.retryCount++;
      
      // 记录失败
      this.auditLog.push({
        loop: 'STEP13-14',
        attempt: this.retryCount,
        failedTests: testResult.failures.length,
        timestamp: Date.now()
      });
      
      if (this.retryCount >= this.maxRetries) {
        // 超过最大次数
        return this.generateFailureReport(testResult);
      }
      
      // 尝试修复
      await this.fixCodeBasedOnTestFailure(testResult, this.retryCount);
    }
  }
  
  generateFailureReport(testResult) {
    const report = {
      success: false,
      message: `测试失败，已尝试${this.maxRetries}次修复`,
      failures: testResult.failures,
      suggestions: [
        '检查测试用例是否正确',
        '检查代码逻辑是否有误',
        '考虑调整测试策略',
        '手动调试失败的测试'
      ],
      options: {
        A: '手动修复后重新运行',
        B: '降低质量标准继续(不推荐)',
        C: '终止任务'
      }
    };
    
    // 生成详细报告文件
    this.saveReport(report);
    return report;
  }
}
```

---

### 循环点2: STEP 5→6→7 分析调整循环 🟡

**场景**: 用户对分析结果不满意，要求重新分析

**循环控制**:
```yaml
最大循环次数: 5次 (分析类任务允许更多次数)

循环策略:
  - 用户明确指出调整方向
  - AI根据反馈重新分析
  - 生成新的分析报告
  - 用户再次确认
  
超过5次:
  - 提示: "已调整5次，建议明确需求后重新开始"
  - 保存所有分析版本供参考
  - 终止当前任务或按当前版本继续
```

**实现**:
```javascript
class AnalysisLoopController {
  constructor() {
    this.maxRetries = 5;
    this.retryCount = 0;
    this.versions = [];
  }
  
  async step5_to_7_loop(userRequest) {
    while (this.retryCount < this.maxRetries) {
      // STEP 5-6: 分析和生成报告
      const analysis = await this.analyzeAndGenerateReport(userRequest);
      
      // 保存版本
      this.versions.push({
        version: this.retryCount + 1,
        analysis: analysis,
        timestamp: Date.now()
      });
      
      // STEP 7: 用户确认
      const confirmation = await this.getUserConfirmation(analysis);
      
      if (confirmation.approved) {
        // 用户同意，继续
        return { success: true, analysis: analysis };
      }
      
      if (confirmation.cancel) {
        // 用户取消
        return { success: false, reason: 'user_cancelled' };
      }
      
      // 用户要求调整
      this.retryCount++;
      userRequest = this.mergeUserFeedback(userRequest, confirmation.feedback);
      
      if (this.retryCount >= this.maxRetries) {
        // 超过最大次数
        return this.offerOptions();
      }
    }
  }
  
  offerOptions() {
    return {
      success: false,
      message: `已调整${this.maxRetries}次，建议明确需求`,
      versions: this.versions,
      options: {
        A: '使用最新版本继续',
        B: '选择历史版本继续',
        C: '重新明确需求后开始',
        D: '终止任务'
      }
    };
  }
}
```

---

### 循环点3: STEP 9→10 代码调整循环 🟡

**场景**: 用户对生成的代码不满意

**循环控制**:
```yaml
最大循环次数: 5次 (代码调整允许多次迭代)

循环策略:
  - 用户指出具体问题
  - AI修改代码
  - 重新进行Lint/Format检查
  - 用户再次确认
  
超过5次:
  - 保存所有代码版本
  - 提示用户选择版本或手动修改
  - 不强制终止，但建议明确需求
```

---

### 循环点4: STEP 11→12 测试调整循环 🟡

**场景**: 用户对测试用例不满意

**循环控制**:
```yaml
最大循环次数: 3次

循环策略:
  - 用户指出测试覆盖不足或策略问题
  - AI调整测试用例
  - 用户再次确认
  
超过3次:
  - 保存所有测试版本
  - 建议用户手动补充测试
```

---

### 循环点5: STEP 15→16 文档调整循环 🟡

**场景**: 用户对文档不满意

**循环控制**:
```yaml
最大循环次数: 3次 (文档调整相对简单)

循环策略:
  - 用户指出文档问题
  - AI修改文档
  - 用户再次确认
  
超过3次:
  - 提示用户手动修改文档
  - 保存当前文档版本
```

---

### 循环点6: STEP 19→各STEP 最终调整循环 🟢

**场景**: 最终确认时用户要求修改

**循环控制**:
```yaml
最大循环次数: 不限制 (用户有最终控制权)

但建议:
  - 如果返回超过5次，提示用户考虑重新明确需求
  - 记录所有返回和修改
  - 在审计日志中记录循环次数
```

---

### 全局循环统计

**状态跟踪**:
```javascript
class GlobalLoopTracker {
  constructor() {
    this.loops = {
      'STEP13-14': { count: 0, max: 3 },
      'STEP5-7': { count: 0, max: 5 },
      'STEP9-10': { count: 0, max: 5 },
      'STEP11-12': { count: 0, max: 3 },
      'STEP15-16': { count: 0, max: 3 },
      'STEP19-*': { count: 0, max: Infinity }
    };
  }
  
  increment(loopPoint) {
    this.loops[loopPoint].count++;
    
    // 检查是否超过限制
    if (this.loops[loopPoint].count >= this.loops[loopPoint].max) {
      return {
        exceeded: true,
        loopPoint: loopPoint,
        count: this.loops[loopPoint].count,
        max: this.loops[loopPoint].max
      };
    }
    
    return { exceeded: false };
  }
  
  reset(loopPoint) {
    this.loops[loopPoint].count = 0;
  }
  
  getStatistics() {
    return Object.keys(this.loops).map(key => ({
      loopPoint: key,
      count: this.loops[key].count,
      max: this.loops[key].max,
      percentage: (this.loops[key].count / this.loops[key].max) * 100
    }));
  }
}
```

---

### 循环状态持久化

**状态文件格式**:
```json
{
  "version": "3.0.0",
  "taskId": "uuid-xxx",
  "currentStep": 14,
  "loops": {
    "STEP13-14": {
      "count": 2,
      "lastError": "3个测试用例失败",
      "attempts": [
        {
          "attempt": 1,
          "timestamp": "2025-11-21T10:20:00Z",
          "error": "TypeError: Cannot read property",
          "fix": "添加了null检查"
        },
        {
          "attempt": 2,
          "timestamp": "2025-11-21T10:25:00Z",
          "error": "Assertion failed: expected 5 to be 10",
          "fix": "修正了计算逻辑"
        }
      ]
    }
  },
  "timestamp": "2025-11-21T10:30:00Z"
}
```

**保存和恢复**:
```javascript
class LoopStateManager {
  async saveState(state) {
    const statePath = `/reports/${state.moduleName}/.temp/loop-state.json`;
    await writeFile(statePath, JSON.stringify(state, null, 2));
  }
  
  async restoreState(moduleName) {
    const statePath = `/reports/${moduleName}/.temp/loop-state.json`;
    if (await fileExists(statePath)) {
      const content = await readFile(statePath);
      return JSON.parse(content);
    }
    return null;
  }
  
  async clearState(moduleName) {
    const statePath = `/reports/${moduleName}/.temp/loop-state.json`;
    await deleteFile(statePath);
  }
}
```

---

### 循环监控和警告

**警告级别**:
```yaml
🟢 正常 (0-50%):
  - 循环次数在合理范围内
  - 无需特别关注

🟡 注意 (50-80%):
  - 循环次数接近上限
  - 提示: "注意：已尝试X次，接近上限"

🔴 警告 (80-100%):
  - 循环次数接近最大值
  - 强提示: "警告：再尝试Y次将达到上限"

🔴 达到上限 (100%):
  - 终止循环
  - 生成完整报告
  - 提供后续选项
```

---

### 审计日志记录

**循环日志格式**:
```javascript
auditLog.push({
  type: 'loop',
  loopPoint: 'STEP13-14',
  attempt: 2,
  action: '修复测试失败',
  details: {
    failedTests: ['test1', 'test2'],
    fixApplied: '添加了错误处理',
    result: 'still_failed'
  },
  timestamp: Date.now(),
  remainingAttempts: 1
});
```

---

### 循环优化建议

**何时应该提前终止循环**:
```yaml
情况1: 用户明确表示放弃
  - 立即终止
  - 不计入循环次数

情况2: 同一错误重复3次
  - 说明修复策略无效
  - 建议改变思路或手动介入

情况3: 循环时间过长(>30分钟)
  - 提示用户考虑分阶段处理
  - 保存当前进度

情况4: 质量持续下降
  - 如果每次修复后质量更差
  - 建议回滚到最佳版本
```

---

### 允许循环的STEP (总结)

| 循环点 | 最大次数 | 超过后操作 | 原因 |
|--------|---------|-----------|------|
| **STEP 13→14** 🔴 | 3次 | 生成报告，提示手动介入 | 测试失败修复 |
| **STEP 5→7** 🟡 | 5次 | 提示明确需求 | 分析调整 |
| **STEP 9→10** 🟡 | 5次 | 保存版本，建议选择 | 代码调整 |
| **STEP 11→12** 🟡 | 3次 | 建议手动补充 | 测试调整 |
| **STEP 15→16** 🟡 | 3次 | 建议手动修改 | 文档调整 |
| **STEP 19→各STEP** 🟢 | 不限制 | 提示建议(>5次) | 用户最终控制 |

---

### 循环和错误处理
任何 STEP 发生未预期错误：
1. 记录完整错误堆栈
2. 保存当前状态（STEP 0 到当前 STEP 的结果）
3. 生成错误报告
4. 选项: A)重试 B)跳过当前步骤 C)中止流程

### 错误恢复机制
- STEP N 失败时，保存 STEP 0 到 N-1 的结果
- 允许从 STEP N 重新开始，无需重复前面步骤

---

## 📊 进度追踪

### 进度显示格式
```
[=====>          ] 37% (STEP 7/23)
当前: 等待用户确认执行计划...
预计剩余时间: 约 15 分钟
```

### 各阶段进度
- STEP 0-4: 0-20% (规范处理)
- STEP 5-7: 20-40% (分析和确认)
- STEP 8: 40-45% (确定流程)
- STEP 9-16: 45-80% (执行和确认)
- STEP 17-19: 80-90% (质量验证)
- STEP 20-22: 90-100% (提交和存档)

---

**文件创建**: 2025-11-20  
**最后更新**: 2025-11-21  
**状态**: ✅ 完整

---

## 💾 状态持久化策略 🔴

### 目的

**防止长流程执行中断导致工作丢失**，支持断点续传和错误恢复。

---

### 状态文件格式

**位置**: `/reports/{模块名}/.temp/state.json`

**完整格式**:
```json
{
  "version": "3.0.0",
  "taskId": "task-uuid-20251121-103000",
  "moduleName": "user-service",
  "intent": "Intent-02",
  "intentName": "开发新功能",
  "execution": {
    "currentStep": 14,
    "startTime": "2025-11-21T10:00:00Z",
    "lastUpdate": "2025-11-21T10:30:00Z",
    "status": "in_progress"
  },
  "profile": {
    "loaded": true,
    "name": "ndsk_core"
  },
  "steps": {
    "STEP0": { "completed": true, "timestamp": "2025-11-21T10:00:05Z" },
    "STEP9": { "completed": true, "timestamp": "2025-11-21T10:15:00Z" }
  },
  "loops": {
    "STEP13-14": { "count": 2, "maxRetries": 3 }
  },
  "filesGenerated": [],
  "auditLog": []
}
```

---

### 状态保存时机 🔴

**必须保存状态的时间点**:
1. 每个STEP完成后
2. 用户确认后
3. 文件生成后
4. 循环重试时
5. 错误发生时
6. 长时间操作中(>5分钟，每分钟保存)

---

### 状态恢复机制 🔴

**中断后如何恢复**:
1. 检测状态文件是否存在
2. 验证状态有效性
3. 询问用户是否恢复
4. 恢复上下文和循环计数器
5. 从中断的STEP继续执行

---

### 状态清理策略

```yaml
自动清理:
  任务成功完成后: STEP 22自动清理
  任务被取消后: 移动到archive/
  状态文件过期: 超过7天自动归档

手动清理:
  npm run clean:temp-states
  npm run clean:state -- --module=user-service
```

