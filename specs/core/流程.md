# v3 核心执行流程

> **文件**: specs/core/流程.md  
> **版本**: v3.0  
> **日期**: 2025-11-20  
> **说明**: 完整的 STEP 0-22 执行流程

---

## 📋 完整流程（23个STEP）

### 🔴 STEP 0: Profile & 禁止项扫描（最高优先级）

**目的**: 在任何操作前，先读取项目规范和禁止项

**执行步骤**:
1. 检查 `guidelines/profiles/{project}.md` 是否存在
2. IF 存在：
   - 读取 Profile → 识别项目特定规范
   - 禁止项（Service层/DTO/特定模式）
   - 技术栈约束（语言/框架/库版本）
   - 目录结构定义
   - 命名规范定义
   - 脚本语言约束（shell/py/ts/js）
3. ELSE：使用默认规范
4. 扫描禁止删除项：
   - 禁止删除现有 import/require
   - 禁止删除现有路由/函数
   - 禁止删除现有配置
   - 除非用户书面明确确认
5. 构建规范上下文（贯穿整个流程）

**参考**: docs/紧急规范更新-严禁删除现有代码.md

---

### 🟢 STEP 1: 分析用户意图

**目的**: 理解用户想要做什么

**执行步骤**:
1. 识别意图类别（18种之一）
2. 确定操作类型（修复/开发/审查/文档等）
3. 初步判断涉及范围

---

### 🟢 STEP 2: 确定涉及的规范文件

**目的**: 根据意图类型确定需要应用哪些规范

**执行步骤**:
1. 根据意图类型和 STEP 0 的 Profile 结果
2. 代码类意图 → 代码规范 + 测试规范
3. 文档类意图 → 文档规范
4. 配置类意图 → 配置规范
5. 脚本类意图 → 脚本规范（遵从Profile指定的语言）
6. 所有意图 → 应用 STEP 0 的项目规范

---

### 🟠 STEP 3: 应用通用规范

**目的**: 应用相应的通用规范

**执行步骤**:
根据 STEP 2 确定的规范类型：
- 代码质量规范（命名/结构/注释）
- 测试规范（覆盖率/测试类型）
- 安全规范（敏感信息/权限）
- 文档规范（同步/格式）
- 脚本规范（格式/命名，优先使用Profile指定的语言）
- 配置规范（结构/环境）

---

### 🔴 STEP 4: 规范冲突解决 + 禁止删除验证

**目的**: 解决项目规范与通用规范的冲突，验证禁止删除

**执行步骤**:
1. IF 项目规范 与 通用规范 冲突
   - 优先级: 项目规范 > 通用规范
   - 应用: 项目规范
   - 记录: 冲突项和解决方案
2. 禁止删除验证:
   - ✅ 确认不删除现有 import/require
   - ✅ 确认不删除现有路由/函数
   - ✅ 确认不删除现有配置
   - ❌ 如需删除，必须获得用户书面明确确认

**"书面明确确认"的标准格式**:
```yaml
IF: 需要删除现有代码
THEN:
  1. 展示将要删除的内容清单:
     - 列出所有将被删除的import/require
     - 列出所有将被删除的函数/类/路由
     - 列出所有将被删除的配置项
  
  2. 要求用户明确确认，必须包含:
     格式: "我已理解删除影响，明确同意删除以下内容：{清单}"
     
     示例:
       "我已理解删除影响，明确同意删除以下内容：
        - import { OldService } from './old-service'
        - function oldFunction()
        - route /api/old-endpoint"
  
  3. 记录用户确认到审计日志
  
  4. IF: 用户未按格式确认 OR 用户拒绝
     THEN: 拒绝执行删除操作
```

**参考**: docs/紧急规范更新-严禁删除现有代码.md

---

### 📋 STEP 5: 全面分析意图中的项目

**目的**: 深度分析项目，识别影响范围

**执行步骤**:

#### 5.1 模块依赖分析
- 使用依赖图工具识别影响范围
- 检查 import/require 关系
- 识别循环依赖
- 绘制依赖关系图

#### 5.2 代码影响分析
- 函数调用链分析
- 数据流分析
- 副作用识别
- 评估改动复杂度

#### 5.3 测试覆盖分析
- 检查现有测试覆盖率
- 识别缺失的测试场景
- 确定需要新增的测试类型
- 评估测试工作量

#### 5.4 文档影响分析
- 识别需要更新的文档
- 检查 API 变更影响
- 评估示例代码更新需求
- 确定 Swagger 文档更新范围

#### 5.5 风险点识别
- 识别潜在的破坏性变更
- 评估性能影响
- 检查安全风险
- 评估兼容性问题

#### 5.6 工具辅助分析
- 静态代码分析工具
- 依赖可视化工具
- 测试覆盖率工具
- 代码复杂度分析工具

#### ⚠️ 分段处理机制

**触发条件**: 预估分析时间 > 5分钟

**分段策略**:
1. 按模块分段（每个模块单独分析）
2. 每段分析完成后立即保存
3. 暂存文件路径: `/reports/{模块名}/.temp/analysis-part-{N}.md`
4. 文件命名规则: `analysis-part-{序号}-{模块名}-{timestamp}.md`
5. 合并策略: 在 STEP 6 中合并所有 part-N 文件

**暂存文件格式**:
```markdown
---
分段序号: 1/N
分析模块: user-auth
分析时间: 2025-11-20 14:30:00
依赖关系: [list]
---
[分析内容]
```

**合并规则**:
- 保留所有分段的分析结果
- 合并依赖关系图
- 汇总风险点
- 生成统一的操作清单

---

### 📊 STEP 6: 生成分析报告（临时方案）

**目的**: 生成完整的执行计划报告

**执行步骤**:

#### 6.1 合并分段分析（如有）
IF 存在分段分析文件：
1. 读取所有 `analysis-part-N.md` 文件
2. 合并依赖关系图
3. 汇总所有风险点
4. 生成统一的操作清单
5. 保存到: `/reports/{模块名}/.temp/analysis-plan-{timestamp}.md`
6. 清理分段文件（保留到最终确认）

#### 6.2 报告内容
- 任务概述
- 涉及的文件和模块
- 将要执行的操作清单
  - 代码改动清单
  - 测试用例清单
  - 文档更新清单
  - 配置修改清单
- 输出路径规划
  - 报告: `/reports/{模块名}/.temp/`
  - 方案: `/plans/{模块名}/`
  - 文档: `/docs/{模块名}/`
  - 测试: `/test/`
  - 脚本: `/scripts/`
  - 配置: `/configs/`
  - 部署: `/deploy/`
- 执行流程（固定）
  1. 先执行代码开发
  2. 编写测试用例
  3. 运行测试验证
  4. 如果发现问题 → 修复代码 → 重新测试
  5. 测试通过后 → 更新文档
- 风险评估（P0/P1/P2）+ P0操作清单
- 预期影响范围
- 时间预估

#### 6.3 报告格式
- 分级展示: 执行摘要 + 技术详情 + 附录
- 可视化: 依赖关系图(Mermaid) + 风险矩阵
- 颜色标记: 🟢安全 🟡警告 🔴危险
- 图标: ✅成功 ⚠️警告 ℹ️信息

**保存位置**: `/reports/{模块名}/.temp/analysis-plan-{timestamp}.md`

---

### ⚠️ STEP 7: 用户确认执行计划（含P0风险强制确认）

**目的**: 获得用户对执行计划的确认

**执行步骤**:

#### 7.1 展示分析报告
- 展示临时方案
- 显示进度: `[=====>    ] 37% (STEP 7/23)`

#### 7.2 P0风险强制确认

**P0风险判断标准**:
```yaml
删除操作（任何删除都需要P0确认）:
  - 删除任何现有import/require
  - 删除任何现有函数/类/方法
  - 删除任何现有路由/端点
  - 删除任何现有配置项

大规模重构（符合以下任一条件）:
  - 修改代码行数 > 100行
  - 影响文件数 > 5个
  - 修改核心业务逻辑
  - 改变API接口定义
  - 修改数据模型

数据库迁移（任何数据库变更）:
  - 新增/删除/修改表结构
  - 新增/删除/修改索引
  - 数据迁移脚本
  - 修改数据库配置

生产部署（任何生产环境操作）:
  - 部署到生产环境
  - 修改生产配置
  - 回滚生产版本
```

IF 报告中包含 P0 高风险操作：
1. 展示 P0 操作清单:
   - 删除操作: [列出具体内容]
   - 大规模重构: [列出重构范围，包含具体数字]
   - 数据库迁移: [列出迁移计划]
   - 生产部署: [列出部署内容]
2. 必须获得用户正面确认: "我已理解以上 P0 风险操作，明确同意执行"
3. IF 用户不同意任何 P0 操作 → 返回 STEP 5 调整方案，或终止流程

#### 7.3 用户选择
- **用户要求调整**: 更新临时方案 → 返回 STEP 5 重新分析
- **用户同意**: 
  - 将临时方案升级为最终方案
  - 保存到: `/reports/{模块名}/final/implementation-plan-{timestamp}.md`
  - 清除所有 `.temp/` 临时方案和分段文件
  - 继续执行
- **用户取消**: 清除临时方案 → 生成取消记录 → 终止流程

---

### 🔧 STEP 8: 执行流程（固定顺序）

**目的**: 明确唯一的执行流程

**执行顺序**:
1. 先执行代码开发
2. 编写测试用例
3. 运行测试验证
4. 如果测试发现问题 → 修复代码 → 重新测试
5. 测试通过后 → 更新文档

**注意**: 这是唯一的执行流程，不再有TDD/传统/基准模式选择

---

### 🔧 STEP 9: 执行代码开发（含禁止删除复核）

**目的**: 完成代码开发

**执行步骤**:

#### 9.1 执行前复核
- ✅ 再次确认不删除现有 import/require
- ✅ 再次确认不删除现有路由/函数
- ✅ 再次确认不删除现有配置
- ✅ 再次确认 P0 风险操作已获得用户正面确认
- ❌ 如发现任何删除操作未确认，立即暂停并要求确认

#### 9.2 进度显示
```
[========>     ] 47% (STEP 9/23)
当前: 正在执行代码开发...
预计剩余时间: 约 10 分钟
```

#### 9.3 代码开发
- 修复Bug / 开发新功能 / 重构代码 / 性能优化
- 实时质量检查:
  - 实时 lint 检查（保存时自动）
  - 实时 format（保存时自动）
  - 实时复杂度提示
  - 敏感信息检测（实时警告）
- 生成代码到指定位置

#### 9.4 敏感信息检测
- 硬编码密码/API Key → 立即警告
- 敏感URL/IP地址 → 建议使用环境变量
- 个人身份信息(PII) → 提示脱敏处理

#### 9.5 影响范围三重检查（🔴 强制执行）

**目的**: 确保代码改动不破坏原有功能和兼容性

**检查频次**: 必须检查 **3遍**，每遍侧重不同方面

**第一遍 - 功能影响检查**:
```yaml
检查项:
  - 现有函数调用是否受影响（参数、返回值、行为）
  - 现有接口是否保持兼容（URL、请求/响应格式）
  - 现有配置是否仍然有效
  - 现有数据结构是否仍然兼容
  - 现有业务流程是否完整

检查方法:
  - 静态分析: 检查所有调用点
  - 类型检查: TypeScript类型是否仍然匹配
  - 接口对比: 新旧接口签名对比

记录格式:
  影响范围:
    - ✅ 无破坏性变更
    - ⚠️ 兼容性变更（需要迁移指南）
    - 🔴 破坏性变更（必须用户确认）
```

**第二遍 - 依赖关系检查**:
```yaml
检查项:
  - 上游依赖: 哪些模块调用了修改的代码
  - 下游依赖: 修改的代码依赖哪些模块
  - 循环依赖: 是否引入新的循环依赖
  - 副作用: 是否影响全局状态、缓存、数据库
  - 性能影响: 是否影响关键路径性能

检查方法:
  - 依赖图分析
  - 调用链追踪
  - 性能基准对比

记录格式:
  依赖影响:
    - 上游影响: [列出受影响的模块]
    - 下游影响: [列出依赖的模块]
    - 新增依赖: [列出新增的依赖]
    - 性能影响: [预估性能变化]
```

**第三遍 - 兼容性检查**:
```yaml
检查项:
  - 向后兼容: 是否保持向后兼容
  - API版本: 是否需要升级API版本
  - 数据迁移: 是否需要数据迁移脚本
  - 配置迁移: 是否需要配置迁移
  - 部署影响: 是否需要特殊部署步骤
  - 回滚方案: 是否可以安全回滚

检查方法:
  - 版本对比
  - 迁移路径规划
  - 回滚测试

记录格式:
  兼容性评估:
    - 向后兼容: ✅是 / ❌否
    - 需要迁移: ✅是 / ❌否
    - 可安全回滚: ✅是 / ❌否
    - 部署注意事项: [列出]
```

**检查结果整合**:
```yaml
影响范围总结:
  功能影响:
    - 修改的函数: [列表]
    - 影响的接口: [列表]
    - 破坏性变更: [列表]
  
  依赖影响:
    - 上游模块: [列表]
    - 下游模块: [列表]
    - 性能影响: [说明]
  
  兼容性:
    - 向后兼容: [是/否]
    - 迁移方案: [说明]
    - 回滚方案: [说明]
  
  风险等级: 🟢低风险 / 🟡中等风险 / 🔴高风险
```

**强制要求**:
- ❌ 如果跳过任何一遍检查 → 拒绝进入 STEP 10
- ❌ 如果发现破坏性变更未记录 → 返回重新检查
- ✅ 所有检查结果必须记录到报告中
- ✅ 高风险变更必须在 STEP 10 中向用户展示

#### 9.6 错误处理
IF 代码生成失败：
- 记录错误原因
- 展示错误详情
- 选项: A)重试 B)调整需求 C)跳过

**输出**: 
- 代码改动清单
- 影响范围三重检查报告（必须包含）

---

### ⚠️ STEP 10: 用户确认代码

**目的**: 让用户确认代码是否符合需求

**执行步骤**:

#### 10.1 展示内容
- 代码改动清单
- 修改的文件列表
- 新增的功能说明
- 代码质量检查结果（实时检查）
- **🔴 影响范围三重检查报告（必须展示）**:
  - 功能影响评估
  - 依赖关系分析
  - 兼容性评估
  - 风险等级标识

#### 10.2 用户选择
- **用户同意代码**: 继续 STEP 11
- **用户要求修改代码**: 返回 STEP 9 修改代码
- **用户取消**: 终止流程

---

### 📝 STEP 11: 编写测试用例

**目的**: 根据已完成的代码编写测试

**执行步骤**:

#### 11.1 目录检测与适配
```
IF: Profile 指定测试目录
  使用 Profile 指定的目录
ELSE IF: 项目已有 test/ 目录
  使用 test/ 结构
ELSE IF: 项目已有 tests/ 目录
  使用 tests/ 结构
ELSE:
  创建 test/ 结构（推荐单数形式）
```

#### 11.2 测试文件生成
```
格式: {模块名}-{类型}.test.js

生成位置:
- 单元测试: test/{模块名}-unit.test.js
- 集成测试: test/{模块名}-integration.test.js
- E2E测试: test/{模块名}-e2e.test.js
- API测试: test/{模块名}-api.test.js
- 基准测试: test/{模块名}-benchmark.test.js

注意: 
- 测试文件不分子目录，直接在test/根目录
- 文件名格式: {模块名}-{类型}.test.js
- 根据已完成的代码编写测试
```

#### 11.3 错误处理
IF 测试代码编译失败：
- 检查语法错误
- 提供修复建议
- 选项: A)自动修复 B)手动修复 C)跳过

---

### ⚠️ STEP 12: 用户确认测试用例

**目的**: 让用户确认测试用例是否完整

**执行步骤**:

#### 12.1 展示内容
- 测试文件清单
- 测试覆盖范围
- 预期测试场景

#### 12.2 用户选择
- **用户同意测试用例**: 继续 STEP 13
- **用户要求修改测试**: 返回 STEP 11 修改测试
- **用户取消**: 跳过测试（不推荐）

---

### ✅ STEP 13: 运行测试验证

**目的**: 运行测试，确保代码正确

**执行步骤**:

#### 13.1 运行测试
- 运行所有相关测试
- 检查测试覆盖率
- 确保所有测试通过

#### 13.2 错误处理
IF 测试执行失败：
- 分析失败原因（代码问题/测试问题）
- 展示失败的测试用例和堆栈跟踪
- 选项: 
  - A) 修复代码 → 返回 STEP 9
  - B) 修复测试 → 返回 STEP 11
  - C) 标记为已知问题

**循环修复**: 测试失败时可以返回修改代码或测试，直到通过

---

### ⚠️ STEP 14: 用户确认测试结果

**目的**: 让用户确认测试结果

**执行步骤**:

#### 14.1 展示内容
- 测试通过/失败统计
- 测试覆盖率
- 失败的测试用例（如有）
- 性能指标（如有基准测试）

#### 14.2 用户选择
- **所有测试通过且用户同意**: 继续 STEP 15
- **测试失败或用户要求修改**: 返回 STEP 9 或 STEP 11
- **用户接受已知问题**: 记录问题，继续 STEP 15

---

### 📚 STEP 15: 生成和更新文档

**目的**: 生成完整的文档

**执行步骤**:

#### 15.1 更新模块文档
- `/docs/{模块名}/README.md`
- `/docs/{模块名}/api/endpoints.md`
- `/docs/{模块名}/api/openapi.yaml`（根据接口自动生成Swagger）
- `/docs/{模块名}/examples/`

#### 15.2 检查并更新实现方案

**架构或流程变化判断标准**:
```yaml
架构变化包括:
  - 新增/删除/重命名 类/模块/文件
  - 修改模块间依赖关系
  - 改变数据模型结构
  - 修改数据库schema
  - 改变API接口定义（端点/参数/返回值）
  - 引入新的设计模式
  - 改变模块职责划分

流程变化包括:
  - 修改业务流程步骤
  - 改变函数调用顺序
  - 新增/删除关键业务逻辑
  - 修改错误处理流程
  - 改变数据处理流程
  - 修改认证/授权流程
  - 改变事务处理方式

判断逻辑:
  IF: 代码改动符合以上任一条件
  THEN: 
    必须更新 plans/{模块名}/IMPLEMENTATION.md
  ELSE: 
    仅更新 plans/{模块名}/CHANGELOG.md

示例:
  需要更新IMPLEMENTATION.md:
    - 将UserService拆分为UserService和AuthService
    - 新增缓存层
    - 修改订单状态流转逻辑
    - API从RESTful改为GraphQL
  
  不需要更新IMPLEMENTATION.md:
    - 优化函数内部算法
    - 修复bug
    - 调整代码格式
    - 更新注释
```

IF 代码改动涉及架构或流程变化：
1. 读取当前 `plans/{模块名}/IMPLEMENTATION.md`
2. 识别需要更新的部分
3. 更新实现方案文档
4. 记录版本变更
5. 说明修改原因和影响范围
6. ⚠️ 强制验证: 确保文档与代码一致

#### 15.3 更新模块状态
- 更新 `plans/{模块名}/STATUS.md`
- 更新进度百分比
- 更新健康状态
- 记录最新活动

#### 15.4 更新模块变更日志
- 详细记录到 `plans/{模块名}/CHANGELOG.md`
- 包含每次修改、优化、修复内容
- 比根目录 CHANGELOG 更详细

#### 15.5 更新根目录概览（如有必要）
IF 模块状态发生重大变化：
- 更新根目录 `STATUS.md`（项目概况）
- 更新根目录 `CHANGELOG.md`（仅概览，不详细）

---

### ⚠️ STEP 16: 用户确认文档

**目的**: 让用户确认文档

**执行步骤**:

#### 16.1 展示内容
- 文档清单
- API文档预览
- Swagger文档链接
- 使用示例
- 变更日志

#### 16.2 用户选择
- **用户同意文档**: 继续 STEP 17
- **用户要求修改文档**: 返回 STEP 15 修改文档
- **用户取消**: 跳过文档更新（不推荐）

---

### ✅ STEP 17: 代码质量最终验证

**目的**: 最终质量检查

**执行步骤**:

#### 17.1 质量检查
- 运行 lint 检查
- 运行 format 检查
- 检查代码复杂度
- 验证依赖完整性
- 安全扫描（如需要）
- 文档同步验证（IMPLEMENTATION.md与代码一致性）
- **🔴 复核影响范围三重检查结果（必须复核）**:
  - 验证所有功能影响已识别
  - 验证所有依赖关系已分析
  - 验证所有兼容性问题已评估
  - 确认所有高风险项已处理
- 生成质量报告

#### 17.2 错误处理
**Lint 检查失败**:
- 展示具体错误位置和原因
- 选项: A)自动修复 B)手动修复 C)忽略（不推荐）

**安全扫描发现问题**:
- 按严重程度分级展示
- 必须修复高危问题才能继续

**文档不同步**:
- 标记需要更新的文档
- 返回 STEP 15 更新文档

**影响范围检查不完整**:
- 返回 STEP 9 重新进行三重检查
- 补充缺失的检查项

---

### 📊 STEP 18: 生成执行结果报告

**目的**: 生成完整的执行结果报告

**执行步骤**:

#### 18.1 报告内容
- 已完成的代码改动（文件清单）
- 已编写的测试用例（数量/覆盖率）
- 测试执行结果（通过/失败统计）
- 已更新的文档（文件清单）
- 代码质量检查结果
- 生成的所有文件清单
- 用户确认记录（STEP 10/12/14/16）
- 错误统计（如有）
- 执行时间统计

#### 18.2 报告格式
- 分级展示: 执行摘要 + 技术详情 + 附录
- 可视化: 进度甘特图 + 质量仪表盘
- 报告脱敏: 密码→****** / API Key→abc***xyz

**保存位置**: `/reports/{模块名}/final/execution-result-{timestamp}.md`

---

### ✅ STEP 19: 用户最终确认

**目的**: 最终确认是否应用

**执行步骤**:

#### 19.1 展示执行结果报告

#### 19.2 用户选择
- **同意应用**: 继续 STEP 20
- **要求修改**: 指出修改点 → 返回相应 STEP → 修改后重新验证（允许循环修改，不限制次数）
- **取消应用**: 保留生成的文件在工作区，不应用到代码库 → 生成取消记录

---

### 🎯 STEP 20: 写入文件到工作区

**目的**: 将所有文件写入工作区

**执行步骤**:

#### 20.1 写入文件
- 写入所有生成的文件到工作区
- 更新 CHANGELOG 文件
- 生成文件清单

#### 20.2 权限验证
- 检查目标目录写入权限
- 确保敏感文件不会提交（检查 .gitignore）
- 验证密钥文件权限（600）

#### 20.3 错误处理
IF 文件写入失败：
- 检查权限问题
- 检查磁盘空间
- 选项: A)重试 B)更改路径 C)取消

#### 20.4 审计日志
记录所有文件操作：
- 写入的文件路径
- 写入时间
- 操作用户
- 是否包含敏感信息

---

### 📋 STEP 21: 用户选择提交方式（含审计链条记录）

**目的**: 决定如何处理变更

**执行步骤**:

#### 21.1 选项 A: 提交到代码库
- 执行 git add
- 执行 git commit -m "message"
- 记录 commit ID
- 打标签（如需要）
- 推送到远程（可选）

**审计记录**:
- 提交方式: A (提交到代码库)
- Commit ID: [记录实际commit ID]
- 提交时间: [timestamp]
- 提交者: [user]
- 提交信息: [commit message]

#### 21.2 选项 B: 仅保存文件，不提交
- 文件已写入工作区
- 用户自行决定何时提交

**审计记录**:
- 提交方式: B (仅保存文件)
- 工作副本状态: [记录当前 git status]
- 未提交文件清单: [列出所有修改的文件]
- 保存时间: [timestamp]

#### 21.3 选项 C: 继续修改
- 返回 STEP 19 重新确认
- 允许循环，不限制次数

**审计记录**:
- 提交方式: C (继续修改)
- 返回次数: [记录循环次数]
- 返回时间: [timestamp]

#### 21.4 审计链条保持
无论选择 A/B/C，必须在 STEP 22 存档里记录：
- 用户选择的提交方式
- Commit ID（选项A）或工作副本状态（选项B/C）
- 完整的文件变更历史
- 用户确认记录

---

### 📊 STEP 22: 回顾与存档（含审计链条）

**目的**: 存档所有信息，清理临时文件

**执行步骤**:

#### 22.1 生成最终执行摘要

#### 22.2 更新项目日志

#### 22.3 归档所有报告
保存到 `/reports/{模块名}/final/`：
- 分析报告（最终方案）
- 执行结果报告
- 错误统计报告（如有）
- 审计日志（完整链条）
  - Profile 扫描记录
  - 禁止删除验证记录
  - P0 风险确认记录
  - 用户选择记录（STEP 21）
  - Commit ID 或工作副本状态
  - 文件变更历史
- 经验教训记录

#### 22.4 清理临时文件
- 清理所有 `.temp/` 临时文件
- 清理分段分析文件

#### 22.5 记录执行统计
- 总执行时间
- 各STEP耗时
- 资源使用情况
- 遇到的问题和解决方案

#### 22.6 生成改进建议

---

## 🔄 循环和错误处理

### 允许循环的STEP
- **STEP 5→6→7**: 用户要求调整 → 重新分析
- **STEP 9→10**: 用户不满意代码 → 修改代码
- **STEP 11→12**: 用户不满意测试 → 修改测试
- **STEP 13→14**: 测试失败 → 修改代码或测试
- **STEP 15→16**: 用户不满意文档 → 修改文档
- **STEP 19→各STEP**: 用户要求修改 → 返回相应STEP
- **STEP 21(C)→19**: 继续修改 → 重新确认

### 全局错误处理
任何 STEP 发生未预期错误：
1. 记录完整错误堆栈
2. 保存当前状态（STEP 0 到当前 STEP 的结果）
3. 生成错误报告
4. 选项: A)重试 B)跳过当前步骤 C)中止流程

### 错误恢复机制
- STEP N 失败时，保存 STEP 0 到 N-1 的结果
- 允许从 STEP N 重新开始，无需重复前面步骤

---

## 📊 进度追踪

### 进度显示格式
```
[=====>          ] 37% (STEP 7/23)
当前: 等待用户确认执行计划...
预计剩余时间: 约 15 分钟
```

### 各阶段进度
- STEP 0-4: 0-20% (规范处理)
- STEP 5-7: 20-40% (分析和确认)
- STEP 8: 40-45% (确定流程)
- STEP 9-16: 45-80% (执行和确认)
- STEP 17-19: 80-90% (质量验证)
- STEP 20-22: 90-100% (提交和存档)

---

**文件创建**: 2025-11-20  
**最后更新**: 2025-11-20  
**状态**: ✅ 完整
