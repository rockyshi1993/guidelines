# 重要补充：数据库开发必须先查询结构

> **日期**: 2025-11-21  
> **类型**: 关键改进  
> **优先级**: 🔴 高 (强烈建议遵守)

---

## 📌 核心建议

**当开发涉及数据库的功能时，AI必须先查询数据库结构，再编写代码。**

---

## 🎯 适用场景

### 必须查询数据库结构的场景

| Intent | 场景 | 为什么要查询 |
|--------|------|------------|
| **Intent-02** | 开发新功能 (涉及数据库) | 确保字段名、类型、索引准确 |
| **Intent-01** | 修复Bug (涉及数据库) | 了解实际数据情况，快速定位问题 |
| **Intent-10** | 性能优化 (数据库查询) | 分析索引、执行计划、数据量 |
| **Intent-14** | 数据迁移 | 了解目标集合结构 |
| **Intent-06** | 生成测试 (数据库相关) | 生成符合Schema的测试数据 |

---

## ✅ 查询流程

### 标准5步查询流程

```yaml
STEP 1: 提示用户
  💡 检测到此功能需要操作MongoDB。
  为确保代码质量，建议先查询数据库结构。
  
  是否查询？ [Y/N]

STEP 2: 选择连接
  检测到以下MongoDB连接:
  1. mongodb-local (本地) 🟢 推荐
  2. mongodb-staging (测试) 🟡
  
  请选择:

STEP 3: 查询结构
  3.1 list-databases → 查看数据库
  3.2 list-collections → 查看集合
  3.3 collection-schema → 查看字段(采样50条)
  3.4 collection-indexes → 查看索引
  3.5 find (limit:3) → 查看示例数据(可选)

STEP 4: 展示结果
  users集合结构:
  
  字段:
  ✅ username (String, 必填, 唯一索引)
  ✅ email (String, 98%填充, 唯一索引)
  ⚠️ phoneNumber (String, 可选, 45%填充)
  
  索引:
  ✅ _id_
  ✅ email_1 (唯一)
  ✅ username_1 (唯一)

STEP 5: 基于结构编写代码
  [生成准确的代码]
```

---

## 📊 对比效果

### 不查询 vs 查询后

| 维度 | ❌ 不查询数据库 | ✅ 查询数据库后 |
|------|---------------|---------------|
| **字段名** | 猜测，可能错误 | 100%准确 |
| **数据类型** | 假设，可能不匹配 | 完全匹配 |
| **可选字段** | 不清楚，可能漏判断 | 明确标注，安全访问 |
| **索引情况** | 不了解，可能性能差 | 清楚知道，优化查询 |
| **数据样例** | 没有参考 | 看到真实数据 |
| **Bug风险** | 高 (字段错误) | 低 (结构准确) |

---

## 💡 实际示例

### 示例1: 开发用户查询接口

**场景**: 用户要求"开发根据email查询用户的接口"

#### ❌ 不查询的做法

```javascript
// 直接猜测字段名
async function getUserByEmail(email) {
  const user = await db.collection('users').findOne({
    userEmail: email  // ❌ 错误！猜测字段名为userEmail
  });
  return user;
}

// 问题:
// 1. 字段名可能是 email 而不是 userEmail
// 2. 不知道是否有索引，查询可能很慢
// 3. 不知道哪些字段是可选的
```

#### ✅ 查询后的做法

```javascript
// 步骤:
// 1. 提示用户选择MongoDB连接 → 选择了 mongodb-local
// 2. 查询Schema → 确认字段名是 "email"
// 3. 查询索引 → 确认有 email_1 唯一索引
// 4. 查看示例 → 了解phoneNumber是可选字段

async function getUserByEmail(email) {
  const user = await db.collection('users').findOne({
    email: email  // ✅ 正确！字段名确认为email
  });
  
  // 知道phoneNumber是可选字段，安全访问
  if (user && user.phoneNumber) {
    console.log(`Phone: ${user.phoneNumber}`);
  }
  
  return user;
}

// 优势:
// ✅ 字段名100%准确
// ✅ 知道有email索引，查询性能有保证
// ✅ 知道哪些字段是可选的，避免undefined错误
```

---

### 示例2: 修复数据统计Bug

**场景**: 用户反馈"统计注册用户数不准确"

#### ❌ 不查询的做法

```javascript
// 直接修改代码
async function countUsers() {
  return await db.collection('users').countDocuments();
}

// 问题:
// 1. 不知道是否有逻辑删除字段(如deleted)
// 2. 不知道是否有status字段(active/inactive)
// 3. 可能统计了已删除用户
```

#### ✅ 查询后的做法

```javascript
// 步骤:
// 1. 选择连接 → mongodb-staging (测试环境)
// 2. 查询Schema → 发现有 deleted: Boolean 字段
// 3. 查询Schema → 发现有 status: String 字段
// 4. 查看示例数据 → 发现deleted=true的数据应该排除

async function countUsers() {
  // 基于真实Schema，排除已删除和非激活用户
  return await db.collection('users').countDocuments({
    deleted: { $ne: true },  // ✅ 发现了deleted字段
    status: 'active'         // ✅ 发现了status字段
  });
}

// 优势:
// ✅ 快速定位问题：统计时没有排除deleted用户
// ✅ 修复准确：基于真实数据结构
// ✅ 避免再次出错
```

---

### 示例3: 性能优化

**场景**: 用户反馈"用户列表接口很慢"

#### ❌ 不查询的做法

```javascript
// 盲目添加索引
async function optimizeUserList() {
  // 猜测可能需要这些索引
  await db.collection('users').createIndex({ createdAt: 1 });
  await db.collection('users').createIndex({ username: 1 });
}

// 问题:
// 1. 不知道这些索引是否已存在(重复创建)
// 2. 不知道实际查询使用了哪些字段
// 3. 可能优化方向错误
```

#### ✅ 查询后的做法

```javascript
// 步骤:
// 1. 选择连接 → mongodb-local
// 2. 查询索引 → 发现已有 username_1 和 email_1
// 3. 查询执行计划 → 发现按createdAt排序没用到索引
// 4. 查询数据量 → collection-storage-size 显示50万条

async function optimizeUserList() {
  // 分析结果:
  // - username和email已有索引
  // - 查询按createdAt排序，但没有索引
  // - 数据量50万条，全表扫描很慢
  
  // 针对性优化: 只添加缺少的createdAt索引
  await db.collection('users').createIndex({ 
    createdAt: -1  // ✅ 只添加缺少的索引
  });
  
  // 不添加已存在的username索引
}

// 优势:
// ✅ 精准定位性能瓶颈
// ✅ 避免重复创建索引
// ✅ 针对性优化，效果明显
```

---

## 🚀 实施建议

### AI执行流程

```javascript
// STEP 9: 代码开发
async function step9_codeGeneration(userRequest) {
  // 1. 分析是否涉及数据库
  const involvesMongoDB = this.detectMongoDBInvolvement(userRequest);
  
  if (involvesMongoDB) {
    // 2. 提示用户
    const userWantsQuery = await this.askUser(`
💡 检测到此功能需要操作MongoDB。

为确保代码质量，建议先查询数据库结构:
  ✅ 获取准确的字段名和类型
  ✅ 了解现有索引情况
  ✅ 避免字段名错误导致Bug

是否查询数据库结构？
[Y] 是，查询后再编写代码 (推荐)
[N] 否，直接编写代码 (可能有风险)
    `);
    
    if (userWantsQuery === 'Y') {
      // 3. 选择连接
      const connection = await this.selectMongoDBConnection();
      
      // 4. 查询结构
      const structure = await this.queryDatabaseStructure(connection);
      
      // 5. 展示结果
      this.displayStructure(structure);
      
      // 6. 基于结构生成代码
      const code = this.generateCodeWithStructure(structure);
      return code;
    }
  }
  
  // 正常生成代码
  return this.generateCode(userRequest);
}
```

---

## 📋 规范更新位置

### 已更新的文件

1. **工具调用规范.md** ✅
   - 路径: `guidelines/specs/rules/工具调用规范.md`
   - 更新内容: 
     - "何时调用MongoDB MCP" 章节
     - 增加 Intent-02/01/10 场景
     - 增加"查询数据库结构的标准流程"
     - 增加完整示例

2. **v3.md 主规范** ✅
   - 路径: `guidelines/guidelines/v3.md`
   - 更新内容:
     - 在"你必须查阅的规范文件"章节
     - 增加"涉及数据库开发时"特别说明

---

## ✅ 总结

### 核心价值

| 价值 | 说明 |
|------|------|
| **代码质量** | 字段名100%准确，类型完全匹配 |
| **减少Bug** | 避免字段错误、类型不匹配、可选字段漏判断 |
| **性能优化** | 了解索引情况，优化查询 |
| **快速修复** | 基于真实数据定位问题 |
| **降低返工** | 一次做对，避免反复修改 |

### 关键原则

✅ **涉及数据库 → 先查询结构 → 再编写代码**

这是**简单但极其有效**的实践，显著提升代码质量。

---

**最后更新**: 2025-11-21  
**状态**: ✅ 已集成到规范  
**重要性**: 🔴 高 (强烈建议AI助手遵守)

