### 工作区通用规范 v2.1

> **快速导航**: [← 返回 README](../README.md) | [AI 执行入口](../../.github/copilot-instructions.md) | [MCP 调度规则](../mcp/v2.md)

本规范用于在同一仓库内统一管理多个项目（库/服务/CLI；Node/Python/Go/Java/Rust…），以一致流程交付高质量变更。各项目通过根级集中式 \guidelines\profiles/<project>.md 声明运行命令、约束与"例外/覆盖"。

---

## 📖 目录 (Table of Contents)

### 🤖 AI 速查
- [AI 执行速查](#ai-执行速查-优先阅读) - 优先级、立即执行规则、关键决策点
- [场景触发器](#ai-决策指南场景触发器) - 6个场景的IF-THEN规则
  - [场景 0: 项目规范强制检查](#场景-0-项目规范强制检查-所有场景前必执行) - 🔴 最高优先级
  - [场景 A: 功能新增/修改](#场景-a-功能新增修改-强制四要素)
  - [场景 B: Bug 修复](#场景-b-bug-修复-强制记录分析)
  - [场景 C: 大规模编辑](#场景-c-大规模编辑-强制脚本模式)
  - [场景 D: 代码审查](#场景-d-代码审查-强制安全检查)
  - [场景 E: 文档更新判断](#场景-e-文档更新判断-决策矩阵)
- [Bug 修复分析模板](#bug-修复分析模板)

### 📚 详细章节 (1-20)
1. [基线风格与语言](#1-基线风格与语言) - 缩进、行尾、编码
2. [Profile 选择策略](#2-profile-选择策略集中式) - 集中式配置
3. [提交与 PR 规范](#3-提交与-pr-规范) - Conventional Commits
4. [分支与发布](#4-分支与发布) - SemVer 版本管理
5. [文档与版本策略](#5-文档与版本策略含自动创建与示例条款) - README/CHANGELOG/STATUS
6. [代码修改与文档联动](#6-代码修改与文档联动) - 何时更新文档
7. [测试与质量](#7-测试与质量) - 覆盖率标准、测试框架
8. [多语言/技术栈默认命令](#8-多语言技术栈默认命令可被-profile-覆盖) - Node/Python/Go/Java/Rust
9. [错误处理与输入校验](#9-错误处理与输入校验) - Joi/Zod/pydantic
10. [日志分级与敏感信息清洗](#10-日志分级与敏感信息清洗含可观测性增强) - 日志安全
11. [兼容性与 CI 矩阵](#11-兼容性与-ci-矩阵) - 运行时矩阵
12. [目录/导出与 TypeScript 声明](#12-目录导出与-typescript-声明) - index.d.ts
13. [API 稳定性与弃用](#13-api-稳定性与弃用deprecation) - 弃用流程
14. [安全与配置](#14-安全与配置) - 凭据管理
15. [文档联动与自检](#15-文档联动与自检) - CI 自检
16. [PR 合并门禁清单](#16-pr-合并门禁清单) - 提交前检查
17. [项目 Profile 最小模板](#17-项目-profile-最小模板位于-guidelinesprofilesprojectmd) - Profile 模板
18. [功能示例目录](#18-功能示例目录examples) - examples/ 要求
19. [临时文档清理规范](#19-临时文档清理规范) - 文档精简
    - 19.1 [分析报告目录规范](#191-分析报告目录规范) - analysis-reports/bug-analysis 目录
20. [大规模文件编辑策略](#20-大规模文件编辑策略ai-辅助开发) - PowerShell 脚本
21. [验证与测试策略](#21-验证与测试策略完整流程) - 完整验证流程、优先级矩阵
22. [验证脚本与工具目录规范](#22-验证脚本与工具目录规范) - scripts/ 目录结构

---

## 🤖 AI 执行速查 (优先阅读)

> **你的角色**: 智能执行代理 - 严格遵循优先级规则，自动读取相关章节

### ⚡ 立即执行规则

**🔴 第0优先级：项目规范绝对优先**
```yaml
任何代码实现任务开始前:
  1. 强制读取 → guidelines/profiles/<project>.md (完整通读)
  2. 识别禁止项 → Service层/DTO/测试框架/测试目录/验证库等
  3. 识别测试规范 → 测试目录结构/测试框架/断言库/文件命名
  4. 冲突解决 → 项目规范 > 通用最佳实践（100%优先）
  5. 自我检查 → 5个核心问题（详见 copilot-instructions.md 场景0）

理由: 每个项目有自己的历史架构和团队约定，强行使用通用实践会破坏一致性

特别注意（测试相关）:
  ❌ 禁止：在 Profile 未授权的目录创建测试文件
  ❌ 禁止：使用 Profile 未明确允许的测试框架
  ❌ 禁止：使用 Profile 未明确允许的断言库
  ✅ 必须：100% 遵守 Profile 的测试目录结构规范
```

**常规执行规则**
```yaml
当用户请求涉及:
  项目规范检查 → 强制执行 [场景0] 读取Profile并识别禁止项
  功能新增/修改 → 强制执行 [第3.1章] 四要素流程
  Bug修复 → 强制使用 [Bug模板] 记录到 bug-analysis/
  主动改进/优化 → 推荐记录分析到 analysis-reports/ [第19.1章]
  大规模编辑(>100行) → 强制使用 [第20章] PowerShell脚本
  代码审查 → 强制检查 [第9章][第10章] 校验与日志
  文档更新判断 → 使用 [第6章] 决策矩阵
```

### 📊 优先级标识
- 🔴 **强制** - 不执行则失败
- 🟠 **必须** - 应执行，除非例外
- 🟡 **推荐** - 最佳实践
- 🟢 **可选** - 根据情况判断

### 🔍 关键决策点
0. **开始任何开发任务** → 强制执行场景 0（读取 Profile，识别禁止项）[场景0]
   包括: 代码/测试/示例/文档/类型/配置/脚本
   特别提醒: 文档更新（含代码示例）也是开发任务！
1. **是否修改代码** → 检查测试+示例+文档 [第21章]
2. **是否改API** → 强制更新CHANGELOG+README
3. **编辑行数>100** → 使用脚本而非工具
4. **包含日志** → 检查敏感信息清洗
5. **主动改进** → 推荐记录到 analysis-reports/ [第19.1章]
6. **Bug修复** → 强制记录到 bug-analysis/ [第19.1章]
7. **代码修改完成** → 执行完整验证流程 [第21章]

### 📚 详细规范入口
- 📖 [完整规范](#1-基线风格与语言) - 20个章节
- 📝 [Bug 修复分析模板](../templates/bug-fix-analysis-template.md)
- 📁 [项目配置](../profiles/)

---



## 🤖 AI 决策指南（场景触发器）

> **使用说明**: 识别场景 → 读取对应章节 → 执行强制规则 → 验证结果

### 场景 0: 项目规范强制检查 (🔴 所有场景前必执行)

**触发条件** (满足任一即触发):
- 开始任何开发任务（包括但不限于）:
  - 📝 编写/修改源代码（lib/src/）
  - 🧪 编写/修改测试文件（test/）
  - 💡 编写/修改示例文件（examples/）
  - 📚 编写/修改文档（docs/, README.md）
  - 🔧 编写/修改类型声明（index.d.ts）
  - ⚙️ 编写/修改配置文件（package.json, tsconfig.json）
  - 🛠️ 编写/修改脚本文件（scripts/）
- 用户请求添加功能/修改功能/创建任何项目文件

⚠️ **特别注意: 文档任务也是开发任务**
  - 文档包含代码示例 = 需要遵守代码规范
  - 文档更新 API 说明 = 需要验证与代码一致性
  - 因此必须执行场景 0，读取项目 Profile

**强制执行顺序**:
```yaml
STEP 1: 识别项目名称
  - 从用户请求中识别（chat/user/push/resource/search/payment等）
  - 从当前工作目录推断（如 D:\Worker\v1\chat\）
  - 如无法识别，询问用户

STEP 2: 读取项目 Profile
  - 🔴 必须读取: guidelines/profiles/<project>.md
  - 🔴 必须完整通读，不能跳过任何章节
  - 🔴 重点关注"禁止"、"强制"、"必须"等关键词

STEP 3: 提取强制规范
  从 Profile 中提取并记录:
  [ ] 架构禁止项: Service层/Repository层/DTO类？
  [ ] 验证方式: Joi/class-validator/其他？
  [ ] 测试框架: Mocha/Jest/其他？（🔴 强制）
  [ ] 测试断言库: Chai expect/Node.js assert/Jest expect？（🔴 强制）
  [ ] 测试目录结构: test/unit/features/ 还是其他？（🔴 强制）
  [ ] 测试文件命名: snake_case/kebab-case/camelCase？（🔴 强制）
  [ ] 数据库操作: utilsCrud/直接Mongoose/TypeORM？
  [ ] 注释语言: 中文/英文？
  [ ] 其他特定要求: 文件命名/目录结构/响应格式

  🔴 特别注意测试规范:
    - 测试文件必须在 Profile 明确允许的目录下
    - 禁止在 Profile 未提及的目录创建测试文件
    - 禁止使用 Profile 未明确允许的测试框架或断言库

STEP 4: 冲突检查
  IF: Profile规范 与 通用最佳实践 冲突
  THEN: 🔴 无条件遵守 Profile 规范
  
  示例冲突:
    - Profile: "禁止Service层" vs 通用实践: "推荐Service层"
      → 遵守Profile，禁止Service层 ✅
    - Profile: "强制Joi" vs 通用实践: "推荐class-validator"
      → 遵守Profile，使用Joi ✅
    - Profile: "测试在 test/unit/features/" vs 通用实践: "test/app/controller/"
      → 遵守Profile，只在 test/unit/features/ 创建 ✅
    - Profile: "强制 Chai expect" vs 通用实践: "Node.js assert"
      → 遵守Profile，使用 Chai expect ✅

STEP 5: 自我检查（5个核心问题）
  在开始写代码前必须确认:
  1. "我是否已读取项目Profile？" → 必须 YES
  2. "我是否知道项目禁止什么？" → 必须 YES
  3. "我是否会使用项目禁止的技术？" → 必须 NO
  4. "我是否优先项目规范而非通用实践？" → 必须 YES
  5. "我是否需要重新读取Profile？" → 如前4个有问题，必须 YES
  
  如任何一项不符合要求，立即停止，重新执行 STEP 1-4
```

**禁止行为** ❌:
- 未读取Profile就开始写代码
- 读取Profile但忽略"禁止"条款
- 认为"通用最佳实践"比"项目规范"更重要
- 自作主张"优化"项目架构
- 使用项目明确禁止的技术栈

**详细规范**: 
- [copilot-instructions.md 场景0](../../.github/copilot-instructions.md#场景-0-项目规范强制检查-所有场景前必执行)
- [项目Profile目录](../profiles/)

---

### 场景 0.1: 文档任务特别说明 (🔴 强制理解)

**为什么文档任务也要执行场景 0？**

很多 AI 助手会误认为"文档更新是低风险任务，不需要读 Profile"，这是**错误的**。

**原因**:
1. **文档包含代码示例** - 必须遵守项目代码规范（引号/分号/模块系统）
2. **文档描述 API 行为** - 必须与代码实现一致
3. **示例文件是可运行代码** - `examples/*.js` 就是代码文件，不是纯文档
4. **类型声明是代码** - `index.d.ts` 是 TypeScript 代码，不是纯文档

**判断标准**:
```yaml
IF: 任务涉及以下任一内容
  - 编写/修改 examples/*.js（示例代码）
  - 编写/修改 docs/*.md 中的代码块
  - 编写/修改 README.md 中的代码示例
  - 编写/修改 index.d.ts（类型声明）
  - 编写/修改 test/*.js（测试代码）
THEN:
  🔴 必须执行场景 0
  🔴 必须读取 profiles/<project>.md
  🔴 必须遵守项目代码规范
```

**错误案例**:
```yaml
❌ 错误思维: "我只是更新文档，不需要读 Profile"
❌ 结果: docs/write-operations.md 用了双引号，项目要求单引号
❌ 后果: 用户需要手动修改所有代码示例，或修改 Profile 允许双引号

✅ 正确思维: "文档包含代码示例，我必须先读 Profile"
✅ 执行: 读取 profiles/monSQLize.md，发现要求单引号
✅ 结果: docs/write-operations.md 的所有代码示例都用单引号
✅ 后果: 一次到位，无需返工
```

**自我检查**:
- [ ] 我是否认为"这只是文档任务，不是代码任务"？ → 如果是，重新阅读本章节
- [ ] 我的任务是否包含任何代码（即使在文档中）？ → 如果是，必须执行场景 0
- [ ] 我是否已经读取了项目 Profile？ → 如果没有，立即执行场景 0

---

### 场景 A: 功能新增/修改 (🔴 强制四要素)
**触发条件**: 
- 修改 src/lib/ 中的代码
- 新增/修改 API、函数、模块

**强制执行顺序**:
```yaml
0. 🔴 【第一步】执行场景 0 → 读取 profiles/<project>.md 并提取规范
   （如果还未执行，必须立即执行；如果已执行，跳过）

1. 🔴 编写测试 → test/<功能>.test.js (正常+异常+边界)
2. 🔴 提供示例 → examples/<功能>.examples.js (可运行+注释)
3. 🔴 更新CHANGELOG → [Unreleased] 章节
4. 🟠 更新README → 如果API变更
5. 🟡 更新类型声明 → index.d.ts (TypeScript项目)
6. 🔴 运行验证 → npm test && node examples/<功能>.examples.js
```
**详细规范**: [第3.1章](#31-功能添加完整流程四要素代码-测试-示例-文档)

---

### 场景 B: Bug 修复 (🔴 强制记录分析)
**触发条件**:
- 用户报告错误
- 发现异常行为
- 修复缺陷

**强制执行顺序**:
```yaml
1. 🔴 使用Bug模板 → templates/bug-fix-analysis-template.md
2. 🔴 记录分析 → <项目>/bug-analysis/YYYY-MM-DD-描述.md
   必填: 根本原因/影响对比/修复方案/验证方法
3. 🟠 添加回归测试 → 防止再次发生
4. 🔴 更新CHANGELOG → 类型: Fixed
```
**详细规范**: [Bug分析模板](../templates/bug-fix-analysis-template.md)

---

### 场景 C: 大规模编辑 (🔴 强制脚本模式)
**触发条件**:
- 删除/修改 >100行
- 删除整个章节/附录
- 批量重构

**强制执行顺序**:
```yaml
1. 🔴 备份文件 → Copy-Item file.md file.md.backup
2. 🔴 使用脚本 → PowerShell/Bash 而非 replace_string_in_file
3. 🔴 UTF-8编码 → [System.Text.UTF8Encoding]::new($false)
4. 🟠 分步验证 → 每次编辑后 read_file 检查
5. 🟡 清理备份 → 确认无误后删除 .backup
```
**禁止操作**:
- ❌ 使用 multi_edit 删除 >100行
- ❌ 使用 Out-File 或 > 重定向 (编码问题)

**详细规范**: [第20章](#20-大规模文件编辑策略ai-辅助开发)

---

### 场景 D: 代码审查 (🔴 强制安全检查)
**触发条件**:
- 审查代码变更
- 检查日志输出
- 验证错误处理

**强制检查项**:
```yaml
日志安全:
  🔴 无密码/token/连接串
  🔴 使用查询形状而非具体值
  🟠 结构化日志 (JSON/键值对)
  
输入校验:
  🔴 类型校验 (Joi/Zod/pydantic/validator)
  🔴 必填字段检查
  🔴 范围/格式验证
  
错误处理:
  🟠 可行动的错误信息
  🟠 保留原始错误 (cause)
  🟡 去敏的堆栈信息
```
**敏感信息正则**:
```javascript
/(sk|pk|api|token)[-_]?[a-zA-Z0-9]{20,}/  // API Keys
/password|passwd|pwd|secret|credential/i  // 密码
/mongodb:\/\/|postgres:\/\/|mysql:\/\//   // 连接串
```
**详细规范**: [第9章](#9-错误处理与输入校验) + [第10章](#10-日志分级与敏感信息清洗含可观测性增强)

---

### 场景 E: 文档更新判断 (决策矩阵)
**触发条件**:
- 代码修改完成
- 需判断是否更新文档

**决策规则**:
```yaml
IF 满足任一条件:
  - 修改公开API (函数签名/参数/返回值)
  - 修改默认值
  - 修改配置项
  - 修改行为逻辑
  - 修改示例代码
THEN 强制更新:
  🔴 CHANGELOG.md [Unreleased]
  🟠 README.md (如果影响用户)
  🟡 STATUS.md (如果状态变化)
  🟡 类型声明文件

IF 仅内部重构/性能优化:
  🟡 可省略README
  🟠 仍需测试覆盖
```
**详细规范**: [第6章](#6-代码修改与文档联动)

---
## Bug 修复分析模板

> 👉 **重要**：修复 Bug 前，必须使用 [Bug 修复分析模板](../templates/bug-fix-analysis-template.md) 记录分析过程

### 为什么需要？

在修复前深入理解：
1. **为什么会有问题**（根本原因）
2. **修复与不修复的区别**（影响对比）
3. **为什么那样修复**（方案选择）

### 使用流程

```
发现 Bug → 复制模板 → 填写分析 → 实施修复 → 验证测试 → 归档到项目
```

### 归档位置

分析文档保存到：`<项目根目录>/bug-analysis/YYYY-MM-DD-问题描述.md`

> 💡 **提示**：如果 `bug-analysis/` 目录不存在，会自动创建

---

### 1) 基线风格与语言
- 缩进：4 个空格
- 行结尾：`LF`
- 编码：`UTF-8`
- 注释与文档：中文为主，英文术语用括号注明（如：命名空间（namespace））
- 行宽：≤100
- **引号**：双引号（项目可覆盖为单引号）
- **分号**：可选（项目可覆盖为必须）
- **模块系统**：ESM（项目可覆盖为 CommonJS）
- 建议在仓库根提交 `.editorconfig` 与 `.gitattributes` 统一风格（模板见 [templates/file-templates.md](../templates/file-templates.md)）

---

### 2) Profile 选择策略（集中式）
- 根级集中式：由 `guidelines/profiles/<project>.md` 与 `guidelines/guidelines.md` 共同构成，保证项目特有配置覆盖全局规范。, 其中`<project>` 表示根目录项目目录名称
- 兜底：若未找到 `<project>.md`，使用 \guidelines\guidelines.md（本文）并提示补齐。
- 显式指定：允许通过环境变量 `GITHUB_PROFILE` 指定自定义路径（临时/实验用途）。
- 迁移提示：不再读取项目内 `<项目根>\guidelines\profile.md`；如有历史文件，请迁移至根级 `profiles/<project>.md` 并删除旧文件，避免歧义。

#### 🔴 MCP 服务器配置（强制）
**规则**: AI 助手在调用任何 MCP 服务器（如 MongoDB、PostgreSQL 等数据库工具）前，**必须**先检查项目 Profile 中的 MCP 配置。

**强制要求**:
```yaml
调用 MCP 前置检查:
  1. 🔴 读取 guidelines/profiles/<project>.md
  2. 🔴 检查是否有 "MCP 配置" 章节
  3. 🔴 确认指定了允许使用的 MCP 服务器名称
  4. ❌ 未指定则禁止调用任何 MCP 服务器

禁止行为:
  - ❌ 未读取 Profile 就调用 MCP
  - ❌ Profile 中未声明就擅自调用
  - ❌ 使用未在 Profile 中列出的 MCP 服务器
```

**原因**: 防止错误连接到不同项目的数据库，避免数据污染和安全风险。

**示例**（Profile 中的 MCP 配置）:
```markdown
## MCP 配置
- 允许的 MCP 服务器: `mongodb-monsqlize`
- 数据库: monsqlize
- 用途: 测试数据查询和分析
```

---

### 3) 提交与 PR 规范
- 提交信息：Conventional Commits（`feat|fix|docs|test|refactor|chore|build|perf|ci`），建议带 scope（如：`feat(api): ...`）。
- PR 必填：
    - 动机与背景
    - 方案概述
    - 影响面（API/行为/性能/兼容性/缓存键形状）
    - 迁移建议（如有）
    - 测试说明（正反/边界覆盖、时间与并发相关用例）
    - 文档更新（`README/CHANGELOG/STATUS`）
- PR 描述模板：
```
- 动机与背景：
- 方案概述：
- 影响面（API/行为/缓存键/性能/兼容性）：
- 迁移建议（如有）：
- 测试说明（用例要点/边界覆盖）：
- 文档更新（README/CHANGELOG/STATUS）：
- 风险与回滚预案：
```

---

### 3.1) 功能添加完整流程（四要素：代码-测试-示例-文档）
本章节适用于所有新增功能或修改现有功能的场景，确保交付完整、可验证、可维护的变更。

#### 必需步骤（按顺序执行）
1. **实现功能代码**
   - 遵循基线风格（第1章）
   - 进行输入校验（第9章）
   - 适当的错误处理和日志（第10章）

2. **编写测试用例**（强制）
   - 位置：`test/` 目录，文件名与功能模块对应（如 `findPage.test.js`）
   - 覆盖要求：
     - ✅ 正常路径（主要使用场景）
     - ✅ 异常路径（非法输入、边界条件）
     - ✅ 边界用例（空值、最小/最大值、并发、超时）
   - 命名规范：测试描述用中文，聚焦行为而非实现
   - 验证方式：`npm test` 或项目定义的测试命令

3. **提供示例代码**（强制）
   - 位置：`examples/` 目录，文件名与功能对应（如 `findPage.examples.js`）
   - 要求：
     - ✅ 独立可运行（可直接执行验证）
     - ✅ 详细注释（功能描述、参数说明、返回值、预期行为）
     - ✅ 覆盖主要使用场景（至少1-2个典型场景）
     - ✅ 使用占位配置（如 `.env.example`），不含真实凭据
   - 验证方式：手动运行示例文件，确保输出符合预期

4. **更新文档**（强制）
   - `CHANGELOG.md`：在 `[Unreleased]` 下添加条目（Added/Changed/Fixed 等）
   - `README.md`：
     - 添加/更新功能说明、API 参数、返回值
     - 引用 `examples/` 中的示例（保持一致性）
     - 标注默认值、限制、注意事项
   - `STATUS.md`：更新功能状态（计划中 → 进行中 → 已实现）
   - 类型声明文件（如 `index.d.ts`）：同步更新类型定义和 JSDoc

5. **自检与验证**（提交前）
   - [ ] 测试全部通过（本地 + CI 矩阵）
   - [ ] 示例可独立运行且输出正确
   - [ ] 文档与代码一致（API 签名、参数、返回值）
   - [ ] 无敏感信息泄露（日志、注释、示例）
   - [ ] 类型声明文件已更新（如适用）

#### 流程图（快速参考）
```
功能需求
   ↓
[1] 实现代码 → [2] 编写测试 → [3] 提供示例 → [4] 更新文档 → [5] 自检验证
   ↓              ↓                ↓                ↓                ↓
代码实现      test/*.test.js   examples/*.js    CHANGELOG +      全部通过
            （正反边界）      （可运行+注释）   README +         ↓
                                              STATUS +        提交 PR
                                              类型声明
```

#### 示例场景：新增 `findPage` 功能
```
1. 实现 lib/mongodb/find-page.js
2. 编写 test/findPage.test.js（正常分页、边界limit、空结果、并发请求）
3. 提供 examples/findPage.examples.js（基础分页、排序、过滤组合）
4. 更新文档：
   - CHANGELOG.md: "## [Unreleased]\n- Added: `findPage` 分页查询支持"
   - README.md: 添加 API 说明和示例引用
   - docs/findPage.md: 详细文档（可选）
   - index.d.ts: 添加类型定义
5. 运行 npm test 和 node examples/findPage.examples.js 验证
```

#### 例外情况
- **内部重构/性能优化**：若不改变公开 API，可省略示例和 README 更新，但仍需测试覆盖
- **紧急修复（hotfix）**：可简化流程，但必须保留测试和 CHANGELOG
- **实验性功能**：可在项目 Profile 中标注，放宽部分要求

#### CI 自动检查
- 测试用例存在且通过
- `examples/` 目录包含对应示例文件
- `CHANGELOG.md` 的 `[Unreleased]` 有更新（通过 git diff 检测）
- 文档文件存在（README/CHANGELOG/STATUS）

---

### 4) 分支与发布
- 分支策略：
    - `main`：始终保持可发布状态
    - `feature/*`、`fix/*`：从 `main` 派生，以 PR 合并
- 发布步骤（SemVer）：
    1) 在 `<项目>\CHANGELOG.md` 的 `[Unreleased]` 补全条目；
    2) 下沉为 `[x.y.z]` 并填写日期；
    3) 同步版本文件（`package.json`/`pom.xml`/`go.mod`/`Cargo.toml` 等）；
    4) 打 Tag（`vX.Y.Z`）；
    5) 合并至 `main` 并发布；问题回滚采用 `hotfix/*` + patch。
- 版本语义：
    - `fix` → patch（`x.y.z → x.y.(z+1)`）
    - 向后兼容功能 → minor（`x.y.z → x.(y+1).0`）
    - 破坏性改动 → major（`(x+1).0.0`）

---

### 5) 文档与版本策略（含自动创建与示例条款）

#### README.md 更新规范
- **触发条件**：新增/修改/废弃功能、默认值变更、示例变化。
- **内容要求**：
    - 功能模块分节，每节对应一个功能模块
    - 每节包含：
        - 功能简介
        - 核心 API/方法（参数/返回值/异常/边界说明）
        - 示例调用（引用 examples/ 目录）
        - 注意事项或限制说明
    - 废弃功能标注 Deprecated 与迁移建议
- **示例引用与一致性**：
    - 示例必须与 examples/ 目录保持一致
    - 更新文档后，手动或通过脚本验证示例可运行
- **风格**：
    - 中文为主，英文术语用括号
    - 代码块标识语言，缩进 4 空格，LF 行尾，UTF-8

#### CHANGELOG.md
- 所有对外变更记录，遵循 Keep a Changelog + SemVer
- 分类：Added/Changed/Fixed/Deprecated/Removed/Performance/Security
- 内部重构可按 Internal 简述或省略
- `[Unreleased]` 用于当前开发，发布时下沉到具体版本

#### CHANGELOG.md 管理策略（按项目规模）

**小型项目**（<500行，大多数项目）:
```markdown
# CHANGELOG.md

## [Unreleased]
### Added
- 新功能...

## [1.1.0] - 2025-11-03
### Added
- ...

## [1.0.0] - 2025-01-15
### Added
- ...
```
- ✅ 使用单文件管理
- ✅ 遵循 Keep a Changelog 格式
- ✅ 按 SemVer 版本号倒序排列

**中型项目**（500-2000行，历史版本较多）:
```markdown
# CHANGELOG.md

## 📚 归档版本

完整历史请参考：
- [2024年版本](changelogs/2024.md) - v0.1.0 至 v0.9.0
- [2023年版本](changelogs/2023.md) - v0.1.0-alpha 至 v0.1.0-rc

---

## [Unreleased]
### Added
- 新功能...

## [1.1.0] - 2025-11-03
### Added
- ...（仅保留最近1年的版本）
```
- ✅ 主文件保留最近 1 年版本
- ✅ 旧版本归档到 `changelogs/<YYYY>.md`
- ✅ 主文件顶部添加归档索引

**大型项目**（>2000行，复杂变更历史）:
```markdown
# CHANGELOG.md

## 📚 归档版本

完整历史请参考：
- [2025年详细变更](changelogs/2025/)
- [2024年详细变更](changelogs/2024/)

---

## [Unreleased]
### Added
- 新功能...

## [1.1.0] - 2025-11-03
### Added
- ...（仅摘要，详细链接到 changelogs/2025/v1.1.0.md）

详细变更请参考：[v1.1.0 详细变更](changelogs/2025/v1.1.0.md)
```
- ✅ 主文件保留最新 3 个版本（仅摘要）
- ✅ 详细变更存储在 `changelogs/<YYYY>/v<x.y.z>.md`
- ✅ 主文件链接到详细变更文件

**归档触发条件**:
- CHANGELOG.md 超过 500 行
- 或历史版本超过 10 个
- 或时间跨度超过 1 年

**归档策略**:
```yaml
步骤:
  1. 创建目录: mkdir -p changelogs
  2. 移动旧版本:
     - 中型项目: 按年份归档（changelogs/2024.md）
     - 大型项目: 按年份+版本（changelogs/2024/v1.0.0.md）
  3. 更新主文件:
     - 添加归档索引（顶部）
     - 保留最近版本（1年或3个版本）
  4. 更新项目 Profile:
     - 声明使用归档策略
     - 更新文档路径

保留规则:
  - 主文件: 最新的活跃版本（便于快速查看）
  - 归档文件: 完整历史（永久保留）
  - 格式一致: 归档文件保持与主文件相同格式
```

**changelogs/ 目录结构示例**:

中型项目（按年归档）:
```
<项目>/
  CHANGELOG.md                    # 最近1年版本
  changelogs/
    ├─ 2024.md                    # 2024年所有版本
    ├─ 2023.md                    # 2023年所有版本
    └─ archive/
       ├─ 2022.md
       └─ 2021.md
```

大型项目（按年+版本）:
```
<项目>/
  CHANGELOG.md                    # 最新3个版本（摘要）
  changelogs/
    ├─ 2025/
    │  ├─ v1.1.0.md              # 详细变更
    │  └─ v1.0.0.md
    └─ 2024/
       ├─ v0.9.0.md
       └─ ...
```

#### STATUS.md / ROADMAP.md
- **定位**：记录项目功能状态、计划与路线图
- **状态流转**：计划中 🗺️ → 进行中 🚧 → 已实现 ✅
- **强制同步**：功能从"计划中"到"已实现"必须同步更新到 `CHANGELOG.md [Unreleased]`

**更新触发条件**（何时必须更新 STATUS.md）：

| 场景 | 触发条件 | 更新内容 | 优先级 | 示例 |
|------|---------|---------|--------|------|
| **新增功能** | 实现新 API/方法/模块 | 🗺️ → ✅，添加功能说明 | 🔴 强制 | comment 参数支持 |
| **修改功能** | 改变功能行为/参数/返回值 | 更新功能描述，保持 ✅ | 🟠 必须 | 修改 findPage 分页逻辑 |
| **功能完成** | P1/P2 计划完成 | 🗺️ → ✅，更新统计数据 | 🔴 强制 | P1 高级查询选项全部实现 |
| **功能废弃** | API 标记为 Deprecated | ✅ → ⚠️ Deprecated | 🔴 强制 | 旧版分页 API |
| **功能移除** | API 完全移除 | ✅ → ❌，移至"已移除"章节 | 🔴 强制 | 移除旧缓存实现 |
| **内部重构** | 不改变对外 API | 不更新 | 🟢 可选 | 重构内部缓存逻辑 |
| **Bug 修复** | 修复缺陷，不改功能 | 不更新（仅更新 CHANGELOG） | 🟢 可选 | 修复缓存键生成 Bug |
| **性能优化** | 不改变功能行为 | 可选添加性能说明 | 🟡 推荐 | 缓存命中率优化 |
| **文档更新** | 仅文档修改 | 不更新 | 🟢 可选 | 完善 API 文档 |

**更新原则**：
1. **功能级变更**：新增/修改/删除功能 → 强制更新
2. **实现级变更**：重构/优化/Bug 修复 → 可选更新
3. **保持同步**：STATUS.md ✅ 状态必须与 CHANGELOG.md [Unreleased] 对应

**典型更新示例**：

```markdown
# 示例 1：新增 comment 参数支持

## 更新前（STATUS.md）
### 高级查询/游标选项（已评估，分阶段实施）
- ✅ 已支持: hint, collation, batchSize
- 🗺️ P1 推荐实施: comment (find/findOne/count)
- 🗺️ P2 可选实施: readPreference, max/min

## 更新后（STATUS.md）
### 高级查询/游标选项（已评估，分阶段实施）
- ✅ 已支持: hint, collation, batchSize, comment (find/findOne/count)
- 🗺️ P2 可选实施: readPreference, max/min

同步更新 CHANGELOG.md:
## [Unreleased]
### Added
- **comment 参数**：find/findOne/count 方法支持 comment 参数，用于生产环境监控和慢查询追踪
```

```markdown
# 示例 2：完成 P1 计划

## 更新前（STATUS.md）
### 能力缺口与优先级
- 🗺️ P1（规划中）- 扩展能力面
  1. 🗺️ 分支覆盖率提升
  2. 🗺️ 示例验证
  3. 🗺️ 性能基准

## 更新后（STATUS.md）
### 能力缺口与优先级
- ✅ P1（已完成）- 扩展能力面
  1. ✅ 分支覆盖率提升：从 61.51% → 65.9%（2025-11-05）
  2. ✅ 示例验证：CI 自动化（2025-11-06）
  3. ✅ 性能基准：13 个场景（2025-11-06）

同步更新 CHANGELOG.md:
## [Unreleased]
### Changed
- **质量提升**：P1 全部完成（分支覆盖率、示例验证、性能基准）
```

**不应更新的情况**：
- ❌ **Bug 修复**（不改功能）→ 仅更新 CHANGELOG.md
- ❌ **内部重构**（不改 API）→ 仅更新 CHANGELOG.md（可选）
- ❌ **文档完善**（不改代码）→ 无需更新
- ❌ **测试补充**（不改功能）→ 无需更新

#### 版本文件
- 与实际发布版本同步（package.json/go.mod/Cargo.toml 等）
- 发布时更新 CHANGELOG 与文档中版本引用

#### 自动创建与自检
- **对象**：每个项目根的 README/CHANGELOG/STATUS，仓库根的 .editorconfig/.gitattributes
- **模式**：
    - check（CI）：检查文件是否缺失，缺失失败或告警
    - fix（本地/受控分支）：自动创建最小模板，提交 PR，不覆盖已有文件
- **例外**：可在 profiles/<project>.md 登记例外，CI 放宽
- **统一风格**：LF 行尾、4 空格缩进、UTF-8

#### 示例关联
- **新增/修改功能**
    - 必须在 `examples/` 目录提供对应示例。
    - README 可通过注释引用示例路径或用简短说明保持文档完整性。
- **示例验证**
    - 文档更新后，需验证示例可运行，确保文档描述与代码行为一致。
    - CI 可选开启示例运行检查，提醒开发者同步更新。

#### 推荐实践
- 每次修改 API/功能时，先更新 CHANGELOG → 更新 README（含示例引用）→ 更新 STATUS → 更新 examples 示例。
- 通过脚本统一检查 `examples/` 目录、文档与版本号一致性，保证长期可执行性。

---

### 6) 代码修改与文档联动
- 适用范围：所有修改公开 API、默认值、示例、配置项、行为逻辑、重要内部能力的变更
- 要求：
    - 每次修改代码，必须确认以下文档是否需要同步更新：
    - README.md（示例、默认值、使用方法）
    - CHANGELOG.md（新增/修改/废弃功能）
        - STATUS.md（计划/已实现状态）
        - 类型声明文件（如 index.d.ts）或接口文档
        - 修改公共 API/行为时，PR 中必须列明受影响文档
- CI 自检：
    - 未同步更新文档时 PR 失败或警告（可按项目 Profile 放宽 STATUS.md）
    - 新增/修改示例代码必须手动验证可运行，保持与 README/文档一致

### 7) 测试与质量

### 🔴 测试目录结构（强制遵守项目 Profile）

**最高优先级规则**：
```yaml
🔴 强制规则：
  1. 测试文件位置必须严格遵守项目 Profile 中定义的目录结构
  2. 禁止在 Profile 未明确允许的目录下创建测试文件
  3. 禁止使用 Profile 未明确允许的测试框架或断言库
  4. 禁止使用 Profile 未明确允许的文件命名规范

IF: 项目 Profile 明确规定测试目录结构
THEN: 100% 遵守项目规范，忽略本章的默认规范

示例：
  Profile 规定: test/unit/features/<功能名>.test.js
  → 只能在 test/unit/features/ 下创建测试文件
  → 禁止在 test/app/controller/ 创建测试文件（即使其他项目常用）
  → 禁止在任何其他位置创建测试文件
```

**通用目录结构（仅当 Profile 未明确规定时使用）**：
```
test/                   # 测试根目录
├── unit/               # 单元测试
│   ├── features/       # 功能测试（业务功能）
│   ├── infrastructure/ # 基础设施测试（数据库、缓存等）
│   └── utils/          # 工具函数测试（纯函数）
├── integration/        # 集成测试（跨模块）
└── e2e/                # 端到端测试（完整流程）

注意：
- 此结构仅为默认建议
- 项目 Profile 可完全覆盖此结构
- 必须以项目 Profile 为准
```

### 默认测试框架（可被 Profile 覆盖）

**🔴 强制规则：必须使用项目 Profile 指定的测试框架和断言库**

**默认配置（仅当 Profile 未明确规定时）**：
- **Node.js**: Vitest / Jest（项目可覆盖为 Mocha 等）
- **断言库**: 
  - Vitest/Jest: 默认使用 `expect`
  - Mocha: 必须在 Profile 中明确指定（chai/expect/assert）
  - 🔴 禁止混用：同一项目只能使用一种断言库
- **Python**: pytest
- **Go**: 内置 testing 包
- **Java**: JUnit
- **Rust**: 内置 cargo test

**Profile 覆盖示例**：
```markdown
# guidelines/profiles/chat.md

### 测试框架强制规范
- ✅ 测试框架：Mocha（强制）
- ✅ 断言库：Chai 的 expect（强制）
- ❌ 禁止：Jest、Node.js assert、其他断言库
- ✅ 测试目录：test/unit/features/<功能名>.test.js（唯一位置）
- ❌ 禁止：test/app/controller/、test/integration/、其他位置
```

### 测试覆盖率默认标准（可被 Profile 覆盖）
- **行覆盖率**: ≥ 60%
- **分支覆盖率**: ≥ 60%
- **核心 API**: ≥ 70%
- 项目可在 Profile 中设定更高或更低的标准

### 测试要求

**🔴 文件位置强制规则**：
1. **必须先读取项目 Profile**，确认测试目录结构
2. **严格遵守 Profile 规定**，不得在未授权的目录创建测试文件
3. **禁止自作主张**，即使其他项目常用某种结构

**测试覆盖要求**：
- 覆盖要求：新增/修改路径提供正反与边界用例；核心路径维持基础覆盖线（门槛可在项目 Profile 设定）
- 边界示例：
    - 输入为空/非法、分页参数边界、超时/重试边界
    - 缓存/并发与时间相关行为（建议 fake timers 与并发去重测试）

**测试文件自动分类规则**（减少主观判断）：

```yaml
IF: Profile 明确规定测试目录结构
THEN: 100% 遵守 Profile，忽略以下通用规则

IF: Profile 未明确规定（使用通用结构）
THEN: 按以下规则自动分类:

功能性测试 (test/unit/features/):
  触发条件（满足任一）:
    - 测试对外暴露的 public API/方法
    - 测试业务功能（查询、创建、更新、删除等CRUD操作）
    - 测试用户直接使用的功能
    - 文件名包含 find/count/aggregate/create/update/delete 等业务动词
  
  示例:
    ✅ test/unit/features/find.test.js        # 查询功能
    ✅ test/unit/features/count.test.js       # 计数功能
    ✅ test/unit/features/findPage.test.js    # 分页功能
    ✅ test/unit/features/aggregate.test.js   # 聚合功能

基础设施测试 (test/unit/infrastructure/):
  触发条件（满足任一）:
    - 测试底层支撑系统（不直接对外暴露）
    - 测试跨功能的基础设施（多个功能共用）
    - 测试内部工具类（非业务逻辑）
    - 文件名包含 logger/errors/connection/cache/config/validator 等基础设施关键词
  
  示例:
    ✅ test/unit/infrastructure/logger.test.js      # 日志系统
    ✅ test/unit/infrastructure/errors.test.js      # 错误码系统
    ✅ test/unit/infrastructure/connection.test.js  # 连接管理
    ✅ test/unit/infrastructure/cache.test.js       # 缓存机制

工具函数测试 (test/unit/utils/):
  触发条件（满足任一）:
    - 测试纯函数（无副作用，输入→输出）
    - 测试格式化、转换、解析函数
    - 测试可复用的辅助工具（无状态）
    - 文件名包含 helpers/formatters/parsers/validators 等工具关键词
  
  示例:
    ✅ test/unit/utils/helpers.test.js      # 辅助函数
    ✅ test/unit/utils/formatters.test.js   # 格式化函数
    ✅ test/unit/utils/parsers.test.js      # 解析函数

边界情况处理:
  IF: 测试文件同时符合多个类别
  THEN: 按优先级选择:
    1. Profile 明确规定 > 一切
    2. 功能性测试 > 基础设施测试 > 工具函数测试
    3. 以测试对象的主要职责为准
  
  示例:
    - cache.test.js 测试缓存机制（跨功能使用）→ infrastructure/
    - cacheHelper.test.js 测试缓存辅助函数（纯函数）→ utils/
    - getCachedData.test.js 测试带缓存的查询功能（业务API）→ features/

分类不明确时:
  IF: 无法判断测试文件应放在哪个目录
  THEN:
    1. 检查测试对象的导出位置（public API → features/）
    2. 检查测试对象的依赖（依赖业务逻辑 → features/）
    3. 检查测试对象的副作用（有副作用 → features/infrastructure/，无副作用 → utils/）
    4. 仍不明确则默认放在 features/（最安全）
```

**自动分类示例**:

```yaml
示例1: 测试 find() 方法
  - 检查: find() 是对外 API ✅
  - 检查: 业务功能（查询）✅
  - 结论: test/unit/features/find.test.js

示例2: 测试 logger 模块
  - 检查: 不是对外 API，是内部工具
  - 检查: 跨功能使用（多个模块都用）✅
  - 结论: test/unit/infrastructure/logger.test.js

示例3: 测试 formatDate() 函数
  - 检查: 纯函数（输入日期→输出格式化字符串）✅
  - 检查: 无副作用 ✅
  - 结论: test/unit/utils/formatters.test.js

示例4: 测试 ErrorCodeSystem 类
  - 检查: 不是业务 API，是基础设施
  - 检查: 错误处理系统（跨功能）✅
  - 结论: test/unit/infrastructure/errors.test.js
```

**文件结构与命名（可被 Profile 覆盖）**：
- 测试文件按功能域拆分
- 文件名默认 kebab-case（如 `user-service.test.js`）
  - 项目可覆盖为 snake_case（如 `user_service.test.js`）
- 用例描述中文、聚焦行为

**CI 要求**：
- Windows + Ubuntu × 受支持运行时矩阵
- 库项目建议补一次包体检查（如 `npm pack`）

### 🚨 违规示例（必读）

**错误做法**：
```javascript
// ❌ 错误：未读取 Profile，在 test/app/controller/ 创建测试
// test/app/controller/user.test.js
const { strict: assert } = require('node:assert'); // ❌ 项目可能禁止 assert

describe('User Controller', () => {
  it('should work', () => {
    assert.equal(true, true); // ❌ 可能违反项目规范
  });
});
```

**正确做法**：
```javascript
// ✅ 正确：读取 Profile，确认规范
// 1. 读取 guidelines/profiles/chat.md
// 2. 发现要求：test/unit/features/ + Mocha + Chai
// 3. 在正确位置创建：test/unit/features/user.test.js

const { describe, it } = require('mocha');      // ✅ Profile 要求
const { expect } = require('chai');              // ✅ Profile 要求

describe('User Feature', () => {
  it('应该返回用户信息', () => {
    expect(result.success).to.be.true;          // ✅ 使用 Chai
  });
});
```

---

### 8) 多语言/技术栈默认命令（可被 Profile 覆盖）
- Node.js：
    - 安装：`npm ci`
    - 测试：`npm test`（或 `node test\run-tests.js`）
    - 构建：`npm run build`
    - 发布/校验：版本由 `package.json` + `CHANGELOG` 管理；可选 `npm pack`
- Python：`pytest`；安装使用 `pip`/`poetry`；可选 `build + twine`；记录 `CHANGELOG`
- Go：`go test ./...`；`go build`；版本与 Tag 管理；记录 `CHANGELOG`
- Java：`mvn test`/`gradle test`；`mvn package`/`gradle build`；同步版本；记录 `CHANGELOG`
- Rust：`cargo test`/`cargo build`；`Cargo.toml` 版本同步；记录 `CHANGELOG`

---

### 9) 错误处理与输入校验
- 公开 API 必做基本校验（类型/必填/范围），报错信息可行动且去敏；避免泄露连接 URI/凭据；保留原始错误于 `cause`。
- 建议错误结构：
```
{
    code: "VALIDATION_ERROR",
    message: "参数校验失败",
    details: [ { path: ["field"], type: "number.min", message: "..." } ],
    cause?: any
}
```
- 校验方案选择（项目根据需求自行选择）：
    - Node.js: Joi / Zod / Yup / 自定义校验
    - Python: pydantic / voluptuous
    - Go: go-playground/validator
    - Java: Jakarta Bean Validation
    - Rust: validator

- 参考示例（Node.js with Joi）：
```
const Joi = require("joi");

const schema = Joi.object({
    id: Joi.string().uuid().required(),
    limit: Joi.number().integer().min(1).max(100).default(20),
    timeout: Joi.number().integer().greater(0).default(3000)
});

function validateInput(input) {
    const { value, error } = schema.validate(input, { abortEarly: false, convert: true });
    if (error) {
        const details = error.details.map(d => ({ path: d.path, type: d.type, message: d.message }));
        const err = new Error("参数校验失败");
        err.code = "VALIDATION_ERROR";
        err.details = details;
        throw err;
    }
    return value;
}
```
- 其他语言在各自 `profiles/<project>.md` 指定等效校验方案。

---

### 9.1) API 接口规范与 Swagger/OpenAPI 验证

#### 适用场景
**触发条件**（满足任一即推荐）：
- ✅ 项目提供 RESTful API 或 GraphQL 接口
- ✅ 前后端分离架构（需要接口契约）
- ✅ 微服务项目（服务间通信需要规范）
- ✅ 开放 API 给第三方调用
- ✅ 团队规模 ≥ 3 人（需要协作规范）

**豁免场景**（可不使用）：
- ❌ 纯命令行工具（CLI）
- ❌ 纯库项目（Library）无 HTTP 接口
- ❌ 简单脚本或内部工具

#### Swagger/OpenAPI 规范要求

**核心原则**：
- 🔴 **API-First 设计**（Design First）- 先定义 API 规范，再实现代码，避免代码注释污染
- 🔴 **统一规范文件**（Single Source of Truth）- 使用 OpenAPI YAML 文件集中管理 API 定义
- 🔴 **框架无关**（Framework Agnostic）- 规范文件独立于框架，任何语言/框架都可使用
- 🟠 **版本管理**（API Versioning）- 明确 API 版本，Git diff 可追踪变更
- 🟡 **工具生态**（Tooling）- 利用 OpenAPI 生态工具（校验/测试/文档/SDK生成）

#### 强制要求（API 项目）

```yaml
必须提供:
  1. 🔴 OpenAPI 规范文件（推荐 YAML 格式）
     位置: <项目根>/docs/api/openapi.yaml (或 swagger.yaml)
     格式: OpenAPI 3.0.0 或更高版本
     维护: 手写或使用可视化编辑器（Swagger Editor / Stoplight）
     
  2. 🔴 接口文档访问方式
     - 开发环境: http://localhost:<port>/api-docs （Swagger UI）
     - 生产环境: 可选禁用或仅限内网访问
     - 实现: 使用工具从 YAML 文件加载（如 swagger-ui-express）
     
  3. 🟠 核心接口字段说明（在 YAML 文件中）
     - 请求参数: 类型、必填、默认值、校验规则、示例
     - 响应数据: 类型、字段说明、可能的错误码
     - 认证方式: Bearer Token / API Key / OAuth2 等
     
  4. 🟡 错误码规范
     - 统一的错误码定义（参见第 10 章日志规范）
     - 错误响应结构一致性（在 YAML 文件的 components/schemas 中定义）
```

#### 推荐方案：API-First 工作流

**步骤 1: 定义 OpenAPI YAML 文件**

```yaml
# docs/api/openapi.yaml
openapi: 3.0.0
info:
  title: User Management API
  version: 1.0.0
  description: RESTful API for user management

servers:
  - url: http://localhost:3000/api
    description: Development server
  - url: https://api.example.com
    description: Production server

paths:
  /users/{id}:
    get:
      summary: Get user by ID
      tags:
        - Users
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
            format: uuid
          description: User unique identifier
      responses:
        '200':
          description: Successful response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
              example:
                id: "123e4567-e89b-12d3-a456-426614174000"
                name: "张三"
                email: "zhang@example.com"
                createdAt: "2025-01-01T00:00:00Z"
        '404':
          description: User not found
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Error'
              example:
                code: "USER_NOT_FOUND"
                message: "用户不存在"

  /users:
    post:
      summary: Create new user
      tags:
        - Users
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - name
                - email
              properties:
                name:
                  type: string
                  minLength: 2
                  maxLength: 50
                email:
                  type: string
                  format: email
                password:
                  type: string
                  format: password
                  minLength: 8
            example:
              name: "李四"
              email: "li@example.com"
              password: "SecurePass123!"
      responses:
        '201':
          description: User created successfully
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'

components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: string
          format: uuid
        name:
          type: string
        email:
          type: string
          format: email
        createdAt:
          type: string
          format: date-time
      required:
        - id
        - name
        - email

    Error:
      type: object
      properties:
        code:
          type: string
        message:
          type: string
        details:
          type: array
          items:
            type: object
      required:
        - code
        - message

  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

security:
  - bearerAuth: []
```

**步骤 2: 框架无关的 Swagger UI 集成**

##### Node.js / Express
```javascript
const express = require('express');
const swaggerUi = require('swagger-ui-express');
const YAML = require('yamljs');

const app = express();

// 加载 OpenAPI YAML 文件
const swaggerDocument = YAML.load('./docs/api/openapi.yaml');

// 挂载 Swagger UI
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocument));

// 业务代码保持简洁，无需注释污染
app.get('/api/users/:id', async (req, res) => {
  // 实现逻辑...
});

app.post('/api/users', async (req, res) => {
  // 实现逻辑...
});
```

##### Node.js / Fastify
```javascript
const fastify = require('fastify')({ logger: true });
const YAML = require('yamljs');

// 加载 OpenAPI YAML 文件
const swaggerDocument = YAML.load('./docs/api/openapi.yaml');

await fastify.register(require('@fastify/swagger-ui'), {
  routePrefix: '/api-docs',
  swagger: swaggerDocument
});

// 业务代码保持简洁
fastify.get('/api/users/:id', async (request, reply) => {
  // 实现逻辑...
});
```

##### Node.js / Egg.js
```javascript
// config/plugin.js
exports.swaggerUi = {
  enable: true,
  package: 'egg-swagger-ui'
};

// config/config.default.js
const YAML = require('yamljs');
const swaggerDocument = YAML.load('./docs/api/openapi.yaml');

config.swaggerUi = {
  swaggerDocument,
  routePrefix: '/api-docs'
};

// Controller 代码保持简洁
class UserController extends Controller {
  async show() {
    // 实现逻辑...
  }
}
```

##### Node.js / NestJS
```typescript
// main.ts
import { NestFactory } from '@nestjs/core';
import { SwaggerModule } from '@nestjs/swagger';
import * as fs from 'fs';
import * as yaml from 'js-yaml';

const app = await NestFactory.create(AppModule);

// 加载 OpenAPI YAML 文件
const swaggerDocument = yaml.load(
  fs.readFileSync('./docs/api/openapi.yaml', 'utf8')
);

SwaggerModule.setup('api-docs', app, swaggerDocument);

// Controller 代码保持简洁
@Controller('users')
export class UserController {
  @Get(':id')
  async findOne(@Param('id') id: string) {
    // 实现逻辑...
  }
}
```

##### Python / FastAPI
```python
from fastapi import FastAPI
from fastapi.openapi.utils import get_openapi
import yaml

app = FastAPI()

# 加载 OpenAPI YAML 文件
with open('./docs/api/openapi.yaml', 'r') as f:
    openapi_schema = yaml.safe_load(f)

# 覆盖默认的 OpenAPI schema
def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    app.openapi_schema = openapi_schema
    return app.openapi_schema

app.openapi = custom_openapi

# 业务代码保持简洁
@app.get("/api/users/{user_id}")
async def get_user(user_id: str):
    # 实现逻辑...
    pass
```

**步骤 3: 验证与工具链集成**

```yaml
开发阶段:
  - 使用 Swagger Editor 在线编辑: https://editor.swagger.io
  - 或使用 Stoplight Studio: https://stoplight.io
  - 实时校验 YAML 格式和规范合规性

CI/CD 集成:
  - 使用 Spectral 校验规范文件:
    npx @stoplight/spectral-cli lint docs/api/openapi.yaml
  
  - 使用 openapi-generator 生成客户端 SDK:
    npx @openapitools/openapi-generator-cli generate \
      -i docs/api/openapi.yaml \
      -g typescript-axios \
      -o sdk/typescript
  
  - 使用 Postman 导入 YAML 进行 API 测试:
    newman run docs/api/openapi.yaml --environment prod.json

版本控制:
  - Git diff 可清晰追踪 API 变更
  - API 变更独立于代码变更
  - 便于 Code Review 聚焦于 API 契约
```

**步骤 4: 代码与规范同步验证**

```javascript
// scripts/verify-api-sync.js
// 验证实现的路由与 OpenAPI YAML 文件定义一致

const YAML = require('yamljs');
const express = require('express');

const swaggerDoc = YAML.load('./docs/api/openapi.yaml');
const app = require('./app'); // 你的应用实例

// 提取 YAML 中定义的路径
const definedPaths = Object.keys(swaggerDoc.paths);

// 提取应用中实现的路径
const implementedPaths = [];
app._router.stack.forEach(middleware => {
  if (middleware.route) {
    implementedPaths.push(middleware.route.path);
  }
});

// 对比差异
const missing = definedPaths.filter(p => !implementedPaths.includes(p));
const extra = implementedPaths.filter(p => !definedPaths.includes(p));

if (missing.length > 0) {
  console.error('❌ 缺少实现的接口:', missing);
  process.exit(1);
}

if (extra.length > 0) {
  console.warn('⚠️ 未在 OpenAPI 中定义的接口:', extra);
}

console.log('✅ API 定义与实现一致');
```

#### 项目 Profile 配置示例

在 `profiles/<project>.md` 中添加（可选配置）：

```markdown
## API 接口规范（可选 - 仅 API 项目需要）

### Swagger/OpenAPI 配置
- 规范版本: OpenAPI 3.0.0
- 文档路径: `/api-docs`（开发环境）
- 规范文件: `docs/api/openapi.yaml`
- 维护方式: 手写 YAML 或使用 Swagger Editor
- 访问限制: 生产环境禁用或仅限内网

### 集成方式
- 加载方式: 从 YAML 文件加载（框架无关）
- 工具: swagger-ui-express / @fastify/swagger-ui / egg-swagger-ui
- 更新策略: 修改 openapi.yaml 后重启服务

### 强制字段
- 每个接口必须包含: summary, tags, parameters, responses
- 错误码必须与 lib/errors.js 定义一致
- 认证方式必须明确说明（Bearer Token / API Key）

### 验证方式
- 开发环境: 访问 http://localhost:3000/api-docs 验证
- CI 检查: 确保 openapi.yaml 文件存在且格式正确（Spectral）
- 同步验证: 验证 API 定义与代码实现一致（scripts/verify-api-sync.js）
```

#### CI 集成示例

```yaml
# .github/workflows/api-docs-check.yml
name: API Documentation Check

on: [push, pull_request]

jobs:
  swagger-validation:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Validate OpenAPI Spec
        run: |
          npm install -g @stoplight/spectral-cli
          spectral lint docs/api/openapi.yaml
      
      - name: Verify API Sync
        run: |
          node scripts/verify-api-sync.js
```

#### 最佳实践

**DO ✅**:
- ✅ **手写 YAML 文件**（使用 Swagger Editor 或 Stoplight 可视化编辑）
- ✅ **保持代码简洁**（业务代码不被文档注释污染）
- ✅ **API-First 设计**（先定义契约，再实现代码）
- ✅ **错误码与代码定义保持同步**（如 lib/errors.js）
- ✅ **提供请求/响应示例**（examples 字段）
- ✅ **为复杂接口提供详细说明和注意事项**
- ✅ **使用 tags 分组管理接口**（如 Users/Orders/Payments）
- ✅ **在 README.md 中说明如何访问 API 文档**
- ✅ **在 examples/ 目录提供 Swagger UI 截图或 Postman 配置**
- ✅ **使用 Git diff 追踪 API 变更**（YAML 文件变更历史清晰可见）

**DON'T ❌**:
- ❌ **用代码注解/装饰器生成文档**（避免注释污染业务代码）
- ❌ **手写 swagger.json 并脱离版本控制**（应使用 YAML 并纳入 Git）
- ❌ **生产环境默认开启 Swagger UI**（安全风险）
- ❌ **使用过时的 Swagger 2.0 规范**（应使用 OpenAPI 3.0+）
- ❌ **忽略错误响应的文档**（只写成功情况）
- ❌ **不提供示例数据**（examples）
- ❌ **API 变更后忘记更新 YAML 文件**

#### 推荐工具

- **Swagger Editor**: 在线编辑和预览 OpenAPI 规范（https://editor.swagger.io）
- **Stoplight Studio**: 可视化 OpenAPI 编辑器（桌面版）
- **Swagger UI**: 可视化 API 文档和测试工具
- **Postman**: 导入 OpenAPI 规范生成测试集合
- **OpenAPI Generator**: 根据规范生成客户端 SDK
- **Spectral**: OpenAPI 规范 Lint 工具（CI 集成）

---

### 10) 日志分级与敏感信息清洗（含可观测性增强）
- 分级：`debug/info/warn/error`；慢操作使用 `warn`。
- 慢查询日志：记录集合/命名空间、查询形状（字段集合）、耗时与阈值，不含具体数据值。
- 敏感信息：严禁记录账号、密码、完整连接串、令牌、个人数据；对象输出使用“安全序列化”。
- 结构化日志：建议使用 JSON 或键值对形式；支持通过环境变量配置日志级别。
- Tracing：建议接入 OpenTelemetry，在核心调用链埋点 `traceId/spanId`。
- Metrics：按需暴露基础指标（请求量/错误率/延迟分布，缓存命中率/淘汰）。

---

### 11) 兼容性与 CI 矩阵
- 在项目 Profile 或 `README` 声明受支持的运行时/依赖主版本；大版本升级在 `CHANGELOG` 标注影响与迁移建议。
- CI 覆盖与声明矩阵一致（语言版本 × OS）。
- 参考矩阵：
    - OS：`Windows-latest`、`Ubuntu-latest`
    - Node：`18.x`、`20.x`
    - Python：`3.10`、`3.12`
    - Go：`1.22`
    - Shell：开发默认 PowerShell；CI（Ubuntu）使用 bash

---

### 12) 目录/导出与 TypeScript 声明
- 公共 API 门面清晰；Node 库仅通过入口导出，内部模块保持私有。
- 文件命名 kebab-case；导出采用驼峰（可按项目风格覆盖）。
- 若提供类型声明（如 `index.d.ts`），应为单一入口；实现变更需同步参数与返回类型与中文 JSDoc；可选引入 `tsd/dtslint` 做轻量校验。

---

### 13) API 稳定性与弃用（Deprecation）
- 稳定性：公开 API 在 patch/minor 中保持向后兼容；破坏性改动仅随 major 发布。
- 弃用流程：
    - 在 `CHANGELOG` 标注 `Deprecated` 与替代方案；
    - `README` 标注迁移建议（若影响使用者）；
    - 运行期打印一次性 `warn`（由 `MONOREPO_DEPRECATION_WARN` 控制：`1`=默认开，`0`=关），且不得包含敏感信息；
    - 至少保留一个 minor 周期后再移除，并提前在 `CHANGELOG` 说明目标移除版本。

---

### 14) 安全与配置
- 凭据通过环境变量或本地 `.env` 注入（不纳入版本控制）；示例/测试使用占位符。
- 默认提供合理的超时/限流/缓存 TTL 等安全参数；高敏场景避免过长 TTL。
- 供应链安全：建议启用 Dependabot/Renovate；在 CI 引入 SAST/Secret Scan（如 CodeQL/Trivy/Gitleaks 按需选择）。

---

### 15) 文档联动与自检
- 每次对外可见变更均需更新 `CHANGELOG [Unreleased]`；必要时更新 `README/STATUS`。
- 提交前比对 `README/示例` 与类型/接口声明（如 `index.d.ts`/接口文档）一致性。
- 在 CI 启用“文档自检”：缺失 `README/CHANGELOG` 直接失败；`STATUS` 可按项目 Profile 例外放宽。

---

### 16) PR 合并门禁清单
- [ ] 是否改变公开 API/行为/性能/兼容性/缓存键形状？
- [ ] 对应项目测试在声明矩阵下全部通过？
- [ ] **测试用例已添加/更新**（`test/` 目录，覆盖正常+异常+边界场景）？
- [ ] **示例代码已添加/更新**（`examples/` 目录，可独立运行且有详细注释）？
- [ ] **示例已手动验证**（运行成功且输出符合预期）？
- [ ] `CHANGELOG [Unreleased]` 已更新？是否需要更新 `README/STATUS`？
- [ ] **文档与代码一致**（API 签名、参数、返回值、类型声明文件）？
- [ ] 日志与注释已去敏，无凭据/个人数据？
- [ ] 版本语义（patch/minor/major）已判定并同步至版本文件？
- [ ] CI `docs-check` 通过（`README/CHANGELOG` 存在；`STATUS` 依项目规则）？
- [ ] **功能添加完整流程**（参见第3.1章）已遵循？

---

### 17) 项目 Profile 最小模板（位于 \guidelines\profiles/<project>.md）
```
# <项目名> 的 Github Profile（集中式）

## 关键目录与运行时
- 主目录与入口：`src/`（示例）
- 运行时与 OS：Node 18/20；Windows/Ubuntu（示例）

## 本地与 CI 命令（PowerShell 优先）
- 安装：`npm ci`
- 测试：`npm test`
- 构建：`npm run build`
- 包体检查（库）：`npm pack`

## 文档与版本
- `CHANGELOG.md` 路径与维护方式（Keep a Changelog + SemVer）
- `README` 的更新触发条件

## MCP 配置（🔴 强制 - 使用 MCP 服务器的项目必填）
- 允许的 MCP 服务器: `<mcp-server-name>`（如：`mongodb-monsqlize`）
- 数据库/资源: `<database-name>`（如：`monsqlize`）
- 用途: `<purpose>`（如：测试数据查询和分析）
- 限制: `<restrictions>`（可选，如：只读权限、禁止删除操作）

**说明**: AI 助手必须先读取此配置才能调用 MCP 服务器。未配置则禁止调用任何 MCP。

## API 接口规范（可选 - 仅 API 项目需要）

### Swagger/OpenAPI 配置
- 规范版本: OpenAPI 3.0.0
- 文档路径: `/api-docs`（开发环境）
- 规范文件: `docs/api/openapi.yaml`
- 维护方式: 手写 YAML 或使用 Swagger Editor
- 访问限制: 生产环境禁用或仅限内网

### 集成方式
- 加载方式: 从 YAML 文件加载（框架无关）
- 工具: swagger-ui-express / @fastify/swagger-ui / egg-swagger-ui
- 更新策略: 修改 openapi.yaml 后重启服务

### 强制字段
- 每个接口必须包含: summary, tags, parameters, responses
- 错误码必须与 lib/errors.js 定义一致
- 认证方式必须明确说明（Bearer Token / API Key）

### 验证方式
- 开发环境: 访问 http://localhost:3000/api-docs 验证
- CI 检查: 确保 openapi.yaml 文件存在且格式正确（Spectral）
- 同步验证: 验证 API 定义与代码实现一致（scripts/verify-api-sync.js）

## 例外与覆盖
- 例外 X：<规则项> —— 理由/影响面/迁移建议

## 质量门槛（可选）
- 覆盖率门槛：行/分支/语句（如：70%/70%/70%）

## 风险与回滚
- hotfix + patch 流程
```

### 18) 功能示例目录（examples）
- **适用范围**：每次新增功能或修改现有功能的行为/参数，都必须在仓库 `examples/` 目录下提供对应示例。
- **示例目录结构**（多语言项目可按语言分层）：
  ```
  examples/
    ├── basic/                    # 基础功能示例
    ├── advanced/                 # 高级功能示例
    ├── api/                      # API 接口示例（可选 - API 项目）
    │   ├── swagger-ui.png       # Swagger UI 截图
    │   ├── postman-collection.json  # Postman 配置导出
    │   └── api-examples.md       # API 调用示例
    └── README.md                 # 示例索引
  ```
- **独立可运行**：示例代码应可直接执行，验证功能行为；仅允许使用 `.env.examples` 等占位配置。
- **详细注释**：每个示例需包含：
    - 功能描述
    - 参数说明（类型、默认值、限制）
    - 返回值示例
    - 预期行为
    - 可选：边界或异常情况说明
- **文档一致**：示例中的 API、参数、返回值必须与 `README.md` / 类型声明文件保持一致。
- **覆盖核心场景**：至少覆盖主要使用场景，边界与异常可选。

#### API 项目额外要求（🟠 必须）

如果项目提供 HTTP API 接口，`examples/` 目录必须包含：

```yaml
强制提供:
  1. 🔴 Swagger UI 截图或访问说明
     - 文件: examples/api/swagger-ui.png 或 README.md 说明
     - 内容: 展示接口列表、参数说明、响应示例
     
  2. 🟠 Postman Collection 导出（推荐）
     - 文件: examples/api/postman-collection.json
     - 用途: 导入即可测试所有接口
     
  3. 🟠 API 调用示例文档
     - 文件: examples/api/api-examples.md
     - 内容: 常见接口的 curl/fetch/axios 调用示例
     - 格式:
       ```markdown
       ## 获取用户信息
       
       ### 请求
       ```bash
       curl -X GET http://localhost:3000/api/users/123 \
         -H "Authorization: Bearer <token>"
       ```
       
       ### 响应
       ```json
       {
         "id": "123",
         "name": "张三",
         "email": "zhang@example.com"
       }
       ```
       ```
     
  4. 🟡 接口测试脚本（可选）
     - 文件: examples/api/test-api.js 或 test-api.sh
     - 用途: 快速验证接口可用性
```

#### API 示例完整模板

```markdown
# API 接口调用示例

本文档提供 API 接口的调用示例，帮助快速集成。

## 1. 认证方式

所有接口需要 Bearer Token 认证：

```bash
Authorization: Bearer <your_api_token>
```

## 2. 基础接口

### 2.1 获取用户信息

**接口**: `GET /api/users/:id`

**cURL 示例**:
```bash
curl -X GET http://localhost:3000/api/users/123 \
  -H "Authorization: Bearer your_token_here"
```

**JavaScript (fetch) 示例**:
```javascript
const response = await fetch('http://localhost:3000/api/users/123', {
  headers: {
    'Authorization': 'Bearer your_token_here'
  }
});
const user = await response.json();
console.log(user);
```

**响应示例**:
```json
{
  "id": "123",
  "name": "张三",
  "email": "zhang@example.com",
  "createdAt": "2025-01-01T00:00:00Z"
}
```

**错误响应**:
```json
{
  "error": "USER_NOT_FOUND",
  "message": "用户不存在",
  "statusCode": 404
}
```

### 2.2 创建用户

**接口**: `POST /api/users`

**cURL 示例**:
```bash
curl -X POST http://localhost:3000/api/users \
  -H "Authorization: Bearer your_token_here" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "李四",
    "email": "li@example.com",
    "password": "SecurePass123!"
  }'
```

**响应示例**:
```json
{
  "id": "124",
  "name": "李四",
  "email": "li@example.com",
  "createdAt": "2025-01-15T08:30:00Z"
}
```

## 3. 高级功能

### 3.1 分页查询

**接口**: `GET /api/users?page=1&limit=20`

**参数说明**:
- `page`: 页码（默认 1）
- `limit`: 每页数量（默认 20，最大 100）
- `sortBy`: 排序字段（可选）
- `order`: 排序方向（asc/desc，默认 asc）

**cURL 示例**:
```bash
curl -X GET "http://localhost:3000/api/users?page=2&limit=10&sortBy=createdAt&order=desc" \
  -H "Authorization: Bearer your_token_here"
```

**响应示例**:
```json
{
  "data": [
    { "id": "123", "name": "张三", "email": "zhang@example.com" },
    { "id": "124", "name": "李四", "email": "li@example.com" }
  ],
  "pagination": {
    "page": 2,
    "limit": 10,
    "total": 150,
    "pages": 15
  }
}
```

## 4. Swagger UI 访问

开发环境访问 API 文档：

```
http://localhost:3000/api-docs
```

可在 Swagger UI 中：
- 📖 查看所有接口定义
- 🧪 直接在浏览器中测试接口
- 📥 导出 OpenAPI 规范文件

## 5. Postman 集成

导入 Postman Collection：

1. 下载 `examples/api/postman-collection.json`
2. 打开 Postman → Import → 选择文件
3. 设置环境变量 `base_url` 和 `api_token`
4. 即可测试所有接口
```

- **更新规则**：
  - **新增功能** → 必须添加示例
  - **修改功能** → 必须更新相关示例，保持示例与最新功能一致
  - **新增接口** → 必须更新 examples/api/api-examples.md 和 Swagger 文档
  - **内部优化/性能调整** → 可选更新示例，但建议在注释中说明差异
  
- **推荐实践**：
  - 通过脚本统一运行 `examples/*` 下所有示例，确保长期可执行性。
  - CI 可选开启示例可运行检查，提醒开发者同步更新。
  - API 项目建议在 CI 中验证 Swagger 文档与代码一致性。
---



---

### 19) 临时文档清理规范

#### 临时文档定义
临时文档是指在项目改进、重构或开发过程中创建的**一次性记录文档**，完成后应当删除，避免项目文档冗余。

#### 应删除的临时文档类型

**改进报告类**（项目完成后删除）：
- ❌ `IMPROVEMENTS.md` - 改进详情报告
- ❌ `VERIFICATION.md` - 验证报告
- ❌ `MIGRATION.md` - 迁移指南（完成后）
- ❌ `REFACTORING.md` - 重构记录

**重复内容类**（保留一个，删除其他）：
- ❌ `GETTING_STARTED.md` - 当已有 `QUICKSTART.md` 时
- ❌ `SETUP.md` - 当 `README.md` 已包含安装说明时
- ❌ 多个类似的快速开始指南

**开发过程记录类**（归档或删除）：
- ❌ `TODO.md` - 待办事项（完成后删除或归档到 `STATUS.md`）
- ❌ `NOTES.md` / `DEV_NOTES.md` - 开发笔记
- ❌ `PLAN.md` - 开发计划（完成后归档到 `CHANGELOG.md`）

#### 应保留的核心文档

**标准必需文档**：
- ✅ `README.md` - 项目总览和入口（必需）
- ✅ `CHANGELOG.md` - 版本变更记录（必需）
- ✅ `CONTRIBUTING.md` - 贡献指南（推荐）
- ✅ `LICENSE` - 许可证（必需）

**用户帮助文档**：
- ✅ `QUICKSTART.md` - 快速开始指南
- ✅ `TROUBLESHOOTING.md` - 故障排除指南
- ✅ `FAQ.md` - 常见问题

**开发者文档**：
- ✅ `STRUCTURE.md` / `ARCHITECTURE.md` - 项目结构/架构
- ✅ `STATUS.md` / `ROADMAP.md` - 项目状态/路线图
- ✅ `SECURITY.md` - 安全政策

#### 临时文档处理流程

1. **创建时标注**
   - 在临时文档顶部添加标记：
   ```markdown
   > **📝 临时文档** - 本文档为项目改进/重构过程记录，完成后将删除
   ```

2. **内容归档**
   - 重要信息迁移到 `CHANGELOG.md`（改进历史）
   - 技术决策归档到 `ARCHITECTURE.md` 或 `docs/decisions/`
   - 主动改进分析记录到 `analysis-reports/`（参见第19.1章，永久保留）
   - 问题修复分析记录到 `bug-analysis/`（参见第19.1章，永久保留）

3. **删除时机**
   - 项目改进完成并验证通过
   - PR 已合并到主分支
   - 相关信息已归档到标准文档

4. **删除方式**
   ```powershell
   # 一次性删除多个临时文档
   Remove-Item IMPROVEMENTS.md, VERIFICATION.md, GETTING_STARTED.md
   
   # 验证删除
   Get-ChildItem -Filter "*.md" | Select-Object Name
   ```

#### 最佳实践

**归档而非删除**：
- 重要的改进决策 → `CHANGELOG.md` 的 `[x.y.z]` 版本条目
- 架构重构说明 → `docs/architecture/` 或 `ARCHITECTURE.md`
- 主动改进分析 → `<项目>/analysis-reports/YYYY-MM-DD-主题.md`（永久保留，参见第19.1章）
- Bug 分析报告 → `<项目>/bug-analysis/YYYY-MM-DD-问题.md`（永久保留，参见第19.1章）

**文档精简原则**：
- 每个主题只保留一个文档（避免 `QUICKSTART.md` + `GETTING_STARTED.md` + `SETUP.md` 并存）
- 临时记录尽量使用 Git commit message 或 PR 描述
- 长期有价值的内容才独立成文档

**CI 检查（可选）**：
```yaml
# 检查是否存在临时文档（警告但不失败）
- name: Check for temporary docs
  run: |
    if (Test-Path "IMPROVEMENTS.md") { Write-Warning "Found temporary doc: IMPROVEMENTS.md" }
    if (Test-Path "VERIFICATION.md") { Write-Warning "Found temporary doc: VERIFICATION.md" }
```

#### 示例：项目改进完成后的清理

**场景**：Multi-MCP 项目完成规范化改进

**删除的临时文档**：
```powershell
Remove-Item IMPROVEMENTS.md, VERIFICATION.md, GETTING_STARTED.md
```

**保留的核心文档**：
- `README.md` - 项目总览
- `QUICKSTART.md` - 快速开始
- `CHANGELOG.md` - 版本历史（包含改进记录）
- `CONTRIBUTING.md` - 贡献指南
- `TROUBLESHOOTING.md` - 故障排除
- `STATUS.md` - 项目状态
- `STRUCTURE.md` - 目录结构

**归档的信息**：
- 改进详情 → `CHANGELOG.md` 的 `[1.0.0]` 版本条目
- 重要决策 → `CONTRIBUTING.md` 的相关章节
- 验证结果 → Git commit message

---

### 19.1) 分析报告目录规范

#### 目录定义

本规范定义两类永久保留的分析目录：

- **`<项目>/analysis-reports/`** - 主动性改进分析报告
- **`<项目>/bug-analysis/`** - 被动性问题修复分析

#### 适用场景

**analysis-reports/** 用于记录主动性改进（计划性优化）：
- ✅ 项目改进评估报告（如：P0/P1/P2 优先级改进）
- ✅ 性能优化分析报告
- ✅ 架构重构方案评估
- ✅ 技术债务分析报告
- ✅ 代码质量提升报告
- ✅ 依赖升级影响分析

**bug-analysis/** 用于记录被动性修复（问题响应）：
- ✅ Bug 根因分析
- ✅ 问题修复记录
- ✅ 回归测试方案
- ✅ 生产事故分析

#### 命名规范

```
analysis-reports/YYYY-MM-DD-<类型>-<简短描述>.md

示例:
2025-11-04-P0-improvements-report.md
2025-11-04-performance-optimization-analysis.md
2025-11-04-refactoring-evaluation.md
2025-11-04-dependency-upgrade-impact.md

bug-analysis/YYYY-MM-DD-<问题描述>.md

示例:
2025-11-04-connection-pool-leak.md
2025-11-04-cache-key-collision.md
```

#### 报告内容要求

**analysis-reports/** 报告应包含：
```markdown
# <改进/优化主题>

**分析日期**: YYYY-MM-DD
**改进范围**: 简要说明
**状态**: 计划中 / 进行中 / 已完成

## 背景与动机
- 为什么要做这个改进？
- 当前存在什么问题？

## 方案分析
- 评估了哪些方案？
- 为什么选择当前方案？

## 实施步骤
- 具体实施步骤
- 风险点与缓解措施

## 验证方法
- 如何验证改进效果？
- 测试覆盖范围

## 结果总结
- 改进效果（性能/质量/可维护性）
- 经验教训
```

**bug-analysis/** 报告要求参见 [Bug修复分析模板](../templates/bug-fix-analysis-template.md)

#### 保留策略

- 📁 **analysis-reports/** - 永久保留（长期价值）
- 📁 **bug-analysis/** - 永久保留（问题追溯）
- 🔄 完成后重要结论归档到 `CHANGELOG.md`
- 🔄 重要决策可引用到 `README.md` 或 `ARCHITECTURE.md`

#### 与临时文档的区别

| 文档类型 | 保留策略 | 用途 | 示例 |
|---------|---------|------|------|
| **分析报告** | ✅ 永久保留 | 主动改进分析 | `analysis-reports/P0-improvements.md` |
| **Bug分析** | ✅ 永久保留 | 问题修复分析 | `bug-analysis/2025-11-04-leak.md` |
| **临时文档** | ❌ 完成后删除 | 过程记录 | `IMPROVEMENTS.md`, `VERIFICATION.md` |

**关键区别**：
- 分析报告（analysis-reports/bug-analysis/）→ 具有长期参考价值，记录**为什么**
- 临时文档（IMPROVEMENTS.md等）→ 仅用于开发过程，记录**做什么**

#### 使用流程

**主动改进流程**：
```
1. 识别改进点 → 创建 analysis-reports/YYYY-MM-DD-主题.md
2. 填写分析报告 → 方案评估、风险分析
3. 实施改进 → 按报告中的步骤执行
4. 验证效果 → 更新报告中的结果部分
5. 归档总结 → 重要结论更新到 CHANGELOG.md
6. 保留报告 → 永久保留在 analysis-reports/
```

**Bug修复流程**：
```
1. 发现问题 → 使用 Bug分析模板
2. 根因分析 → 创建 bug-analysis/YYYY-MM-DD-问题.md
3. 实施修复 → 添加回归测试
4. 更新报告 → 验证方法和结果
5. 更新文档 → CHANGELOG.md [Fixed]
6. 保留报告 → 永久保留在 bug-analysis/
```

#### 项目实践

**已采用此规范的项目**：
- ✅ monSQLize - 已有 `analysis-reports/` 和 `bug-analysis/`

**新项目建议**：
- 🔴 活跃开发项目 - 必须创建两个目录
- 🟡 维护模式项目 - 按需创建

**目录初始化**：
```powershell
# 创建分析报告目录
New-Item -ItemType Directory -Path "analysis-reports", "bug-analysis" -Force

# 创建 README 说明
@"
# 分析报告

本目录存放项目的主动性改进分析报告。

## 报告类型
- P0/P1/P2 优先级改进
- 性能优化分析
- 架构重构评估
- 技术债务分析

## 命名规范
YYYY-MM-DD-类型-简短描述.md

## 规范参考
[第19.1章 分析报告目录规范](../../guidelines/guidelines/v2.md#191-分析报告目录规范)
"@ | Out-File -FilePath "analysis-reports/README.md" -Encoding UTF8
```

#### 最佳实践

**定期回顾**：
- 🔄 每季度回顾 analysis-reports，评估改进效果
- 🔄 每半年回顾 bug-analysis，识别系统性问题

**知识传承**：
- 📚 新成员入职时，阅读关键分析报告
- 📚 架构演进时，参考历史改进分析

**持续改进**：
- 🎯 从 bug-analysis 识别预防措施
- 🎯 从 analysis-reports 提炼最佳实践

---

#### Git 管理策略

**不要提交到 Git** (❌):

```yaml
目录:
  - analysis-reports/     # 分析报告（不提交）
  - bug-analysis/         # Bug 分析（不提交）

理由:
  ❌ 文件数量多，每天可能产生几十个
  ❌ 会导致 Git 仓库持续膨胀
  ❌ 大多数团队很少查阅历史分析
  ❌ 克隆仓库时间变长
  
建议:
  ✅ 保留在本地（开发者自行决定）
  ✅ 或使用外部文档系统（Wiki/飞书/Notion）
  ✅ 真正重要的内容放入 docs/ 目录
```

**不应该提交到 Git** (❌):

运行时生成的临时文件不应提交：

```yaml
目录/文件:
  - logs/                  # 运行日志
  - coverage/              # 覆盖率报告
  - .nyc_output/           # 测试临时文件
  - tmp/                   # 临时目录
  - *.log                  # 日志文件
  - verify-results.json    # 验证结果
  - test-results/          # 测试结果

理由:
  - 自动生成，可重新生成
  - 频繁变动，无版本意义
  - 文件可能很大
  - 包含运行时数据
```

**.gitignore 配置**:

```gitignore
# ====================
# 运行时生成文件（不提交）
# ====================

# 日志
logs/
*.log
npm-debug.log*

# 测试覆盖率
coverage/
.nyc_output/

# 临时文件
tmp/
temp/
.cache/

# ====================
# 分析报告（不提交）⭐
# ====================

# 这些目录文件数量多，会导致仓库膨胀
analysis-reports/
bug-analysis/

# ====================
# 应该提交的目录（不要忽略）
# ====================

# docs/         ← 不要忽略
# scripts/      ← 不要忽略
# test/         ← 不要忽略
# examples/     ← 不要忽略
```

**注意**: 如果需要保留重要分析，建议：
- 放入 `docs/` 目录（精选的重要文档）
- 使用外部文档系统（GitHub Wiki / 飞书文档 / Notion）

**说明**:

- analysis-reports/ 和 bug-analysis/ 目录用于**本地开发过程记录**
- 不提交到 Git，避免仓库膨胀
- 开发者可自行决定是否保留
- 重要内容建议迁移到外部文档系统或放入 docs/ 目录

---

**业界参考**:

类似的不提交到 Git 的目录：
- logs/ - 运行日志
- coverage/ - 测试覆盖率
- node_modules/ - 依赖包

---

### 19.2) 项目标准目录结构规范

#### 目录定义

本规范定义项目的标准目录结构，确保不同项目间的一致性和可维护性。

#### 标准目录结构

```
<项目根目录>/
├── .github/                  # GitHub 配置（可选）
│   ├── workflows/           # CI/CD 工作流
│   └── copilot-instructions.md  # AI 助手指令（如适用）
│
├── docs/                     # 📚 API 文档和使用指南
│   ├── <功能>.md            # 功能详细文档
│   └── architecture/        # 架构设计文档（可选）
│
├── examples/                 # 💡 示例代码（可运行）
│   └── <功能>.examples.js  # 功能示例文件
│
├── test/                     # 🧪 测试用例
│   ├── README.md            # 测试说明文档
│   ├── run-tests.js         # 测试运行器
│   └── <功能>.test.js       # 功能测试文件
│
├── lib/ 或 src/             # 📦 源代码
│   ├── index.js             # 主入口
│   ├── common/              # 通用工具
│   └── <模块>/              # 功能模块
│
├── analysis-reports/         # 📊 项目分析报告（永久保留）
│   ├── README.md            # 报告目录说明
│   └── YYYY-MM-DD-<主题>.md # 分析报告文件
│
├── bug-analysis/            # 🐛 Bug 分析报告（永久保留）
│   ├── README.md            # Bug 分析说明
│   └── YYYY-MM-DD-<问题>.md # Bug 分析文件
│
├── utils/ 或 scripts/       # 🛠️ 工具脚本（可选）
│
├── README.md                 # 项目总览
├── CHANGELOG.md              # 版本变更历史
├── STATUS.md                 # 项目状态（功能矩阵）
├── CONTRIBUTING.md           # 贡献指南
├── LICENSE                   # 许可证
├── package.json              # Node.js 项目配置
└── index.d.ts                # TypeScript 类型声明（可选）
```

#### 目录用途说明

##### 核心目录（必需）

| 目录 | 用途 | 强制性 | 备注 |
|------|------|--------|------|
| **lib/** 或 **src/** | 源代码 | 🔴 强制 | 主要业务逻辑 |
| **test/** | 测试用例 | 🔴 强制 | 单元测试、集成测试 |
| **examples/** | 示例代码 | 🔴 强制 | 可运行的功能示例 |
| **docs/** | API 文档 | 🟠 必须 | 详细的功能文档 |

##### 分析目录（推荐）

| 目录 | 用途 | 强制性 | 备注 |
|------|------|--------|------|
| **analysis-reports/** | 项目分析报告 | 🟡 推荐 | 主动性改进分析 |
| **bug-analysis/** | Bug 分析报告 | 🟡 推荐 | 问题修复分析 |

##### 配置文件（必需）

| 文件 | 用途 | 强制性 | 备注 |
|------|------|--------|------|
| **README.md** | 项目总览 | 🔴 强制 | 项目介绍和快速开始 |
| **CHANGELOG.md** | 版本历史 | 🔴 强制 | 遵循 Keep a Changelog |
| **STATUS.md** | 项目状态 | 🟠 必须 | 功能矩阵和路线图 |
| **LICENSE** | 许可证 | 🟠 必须 | 开源许可协议 |
| **package.json** | 项目配置 | 🔴 强制 | Node.js 项目必需 |

#### test/ 目录规范

test/ 目录的详细结构和规范请参见 **[第21章 验证与测试策略完整流程](#21-验证与测试策略完整流程)**。

**标准结构**（简要）：
```
test/
├── unit/                 # 单元测试（强制）
├── integration/          # 集成测试（推荐）
├── e2e/                  # 端到端测试（可选）
└── README.md             # 测试说明文档（推荐）
```

**要点**：
- 🔴 强制：单元测试覆盖所有核心功能
- 🟠 必须：test/README.md 说明测试结构和运行方法
- 🟡 推荐：集成测试验证跨模块交互
- 详细规范参见第21章

#### docs/ 目录规范

**用途**: 存放详细的 API 文档和使用指南

**标准结构**：
```
docs/
├── <功能>.md               # 功能详细文档（每个 API 方法一个文件）
├── <主题>.md               # 主题文档（如 cache.md, connection.md, events.md）
├── architecture/            # 架构设计（可选）
└── guides/                 # 使用指南（可选）
```

**文档分类**：

1. **API 方法文档**（每个公开 API 一个文件）
   - 命名规范：`<方法名>.md`（如 `find.md`, `findOne.md`, `aggregate.md`）
   - 必须内容：方法签名、参数说明、返回值、使用示例
   
2. **主题文档**（跨方法的功能说明）
   - 命名规范：`<主题>.md`（如 `cache.md`, `connection.md`, `events.md`）
   - 适用场景：缓存策略、连接管理、事件系统、配置说明等

3. **架构文档**（可选）
   - 位置：`docs/architecture/`
   - 内容：系统设计、技术选型、性能优化等

---

**文档内容标准**（所有 docs 文档必须包含以下章节）：

```markdown
# <功能/主题名称>

## 概述
简短说明功能定位和核心能力（1-2 段）

## 核心特性
- ✅ 特性 1
- ✅ 特性 2
- ✅ 特性 3

---

## API 参数说明（API 方法文档必需）
### 方法签名
\`\`\`javascript
methodName(options)
\`\`\`

### 参数详解
| 参数 | 类型 | 必需 | 默认值 | 说明 |
|------|------|------|--------|------|
| param1 | Type | ✅ | - | 参数说明 |

### 返回值
\`\`\`javascript
{
  field1: Type,
  field2: Type
}
\`\`\`

---

## 使用示例
### 基本用法
\`\`\`javascript
// 示例代码（必须可运行）
\`\`\`

### 高级场景
\`\`\`javascript
// 复杂场景示例
\`\`\`

---

## 最佳实践
1. **实践 1**
   \`\`\`javascript
   // 推荐做法
   \`\`\`

2. **实践 2**
   \`\`\`javascript
   // 推荐做法
   \`\`\`

---

## 常见问题
### Q: 问题描述？
**A**: 解答...

### Q: 问题描述？
**A**: 解答...

---

## 参考资料
- [相关文档链接](...)
- [外部参考](...)
```

---

**强制要求**：
- 🔴 **每个公开 API 都必须有对应文档**
- � **文档必须包含可运行的示例代码**
- 🔴 **示例代码必须有详细注释**
- 🟠 **文档必须包含参数说明、返回值、使用示例**
- � **文档必须包含最佳实践和常见问题章节**
- �🟡 **推荐添加注意事项、性能建议、错误处理**

---

**文档命名规范**：
```yaml
API 方法文档:
  - find.md              # find 方法
  - findOne.md           # findOne 方法
  - findPage.md          # findPage 方法
  - aggregate.md         # aggregate 方法
  - distinct.md          # distinct 方法
  - count.md             # count 方法
  - explain.md           # explain 方法

主题文档:
  - cache.md             # 缓存策略
  - connection.md        # 连接管理
  - events.md            # 事件系统
  - bookmarks.md         # Bookmark 维护 API
  
技术文档:
  - MONGODB-MEMORY-SERVER.md  # 测试环境配置
  - MIGRATION.md              # 迁移指南（如适用）
```

---

**代码示例标准**：

```javascript
// ✅ 好的示例（推荐）
const MonSQLize = require('monsqlize');

// 创建实例
const msq = new MonSQLize({
  type: 'mongodb',
  databaseName: 'example',
  config: { uri: 'mongodb://localhost:27017' }
});

// 连接
const { collection } = await msq.connect();

// 使用功能（包含参数说明）
const products = await collection('products').find({
  query: { category: 'electronics' },    // 查询条件
  limit: 20,                             // 限制 20 条
  cache: 5000,                           // 缓存 5 秒
  maxTimeMS: 3000                        // 超时 3 秒
});

console.log('查询结果:', products.length);

// ❌ 不好的示例（避免）
// 缺少注释、不可运行、参数不完整
collection('products').find({ query: {} });
```

---

**文档与代码同步**：
- 📝 修改 API 参数 → 🔴 强制更新对应 docs 文件
- 📝 新增 API 方法 → 🔴 强制创建对应 docs 文件
- 📝 修改返回值格式 → 🔴 强制更新 docs 文档
- 📝 修改默认值 → 🟠 必须更新 docs 说明
- 📝 性能优化 → 🟡 推荐更新最佳实践

---

**文档质量检查清单**：
- [ ] 是否有概述章节（说明功能定位）
- [ ] 是否有核心特性列表
- [ ] 是否有完整的参数说明（类型、必需、默认值）
- [ ] 是否有返回值说明
- [ ] 是否有可运行的示例代码
- [ ] 示例代码是否有详细注释
- [ ] 是否有最佳实践章节
- [ ] 是否有常见问题章节
- [ ] 是否有参考资料链接
- [ ] 示例代码是否与 examples/ 目录对应

---

**README.md 与 docs/ 的关系**：

| 文档类型 | README.md | docs/*.md |
|---------|-----------|-----------|
| **定位** | 项目入口、导航中心 | 详细文档 |
| **长度** | 200-400 行 | 不限 |
| **内容** | 简短介绍 + 示例（10-20 行） | 完整文档（包含所有细节） |
| **示例** | 快速开始示例 | 完整场景示例（正常/异常/边界） |
| **更新频率** | 较低（仅核心变更） | 较高（详细变更） |

**原则**：
- ✅ README.md 只做导航，不包含详细内容
- ✅ 每个 API 在 README.md 中有简短示例 + docs 链接
- ✅ 所有详细说明、完整示例、最佳实践都在 docs/ 中
- ✅ README.md 保持简洁（200-400 行），便于快速了解项目

---

**参考示例**：
- 📚 [monSQLize/docs/](../../monSQLize/docs/) - 完整的文档示例
- 📄 [monSQLize/README.md](../../monSQLize/README.md) - 导航型 README 示例

---

**详细文档结构参见**：
- [第6章 代码修改与文档联动](#6-代码修改与文档联动)
- [第18章 功能示例目录](#18-功能示例目录examples)

#### examples/ 目录规范

**用途**: 存放可运行的功能示例代码

**要点**：
- 🔴 强制：每个功能都应有对应示例
- 🔴 强制：示例必须可独立运行
- 🟠 必须：添加详细注释说明参数和预期结果
- 🟢 可选：examples/README.md 汇总所有示例
- 详细示例规范参见 [第18章 功能示例目录](#18-功能示例目录examples)

#### 目录创建脚本

##### PowerShell 脚本

```powershell
# 创建标准项目目录结构
$directories = @(
    "lib/common",
    "test",
    "examples",
    "docs",
    "analysis-reports",
    "bug-analysis"
)

foreach ($dir in $directories) {
    New-Item -ItemType Directory -Path $dir -Force | Out-Null
    Write-Host "✓ Created $dir"
}

# 创建说明文件
New-Item -ItemType File -Path "test/README.md" -Force | Out-Null
New-Item -ItemType File -Path "analysis-reports/README.md" -Force | Out-Null
New-Item -ItemType File -Path "bug-analysis/README.md" -Force | Out-Null

Write-Host "`n✅ 标准目录结构创建完成"
```

#### 最佳实践

##### 目录维护

- 🔄 **定期清理**: 删除不再使用的文件
- 🔄 **分类明确**: 避免文件散乱
- 🔄 **命名一致**: 遵循命名规范

##### 文档同步

- 📝 **代码变更**: 同步更新相关文档
- 📝 **API 变更**: 更新 docs/ 和 examples/
- 📝 **测试覆盖**: 确保 test/ 与功能对应

##### 归档管理

- 📁 **分析报告**: 永久保留在 analysis-reports/
- 📁 **Bug 分析**: 永久保留在 bug-analysis/
- 🗑️ **临时文件**: 完成后及时删除

#### 项目实践

**已采用此规范的项目**：
- ✅ monSQLize - 完整标准目录结构
- ✅ sseKify - 标准目录结构
- ✅ multi-mcp - 标准目录结构

**新项目初始化**：
```powershell
# 1. 创建目录结构
# 运行上述 PowerShell 脚本

# 2. 创建核心文件
New-Item README.md, CHANGELOG.md, STATUS.md, LICENSE

# 3. 初始化 package.json (Node.js)
npm init -y

# 4. 配置 Git
git init
# 添加 .gitignore
```

#### 验证检查清单

创建项目后，确认以下目录和文件：

**必需目录**：
- [ ] `lib/` 或 `src/` - 源代码目录
- [ ] `test/` - 测试目录（含 README.md）
- [ ] `examples/` - 示例目录
- [ ] `docs/` - 文档目录

**推荐目录**：
- [ ] `analysis-reports/` - 分析报告目录（含 README.md）
- [ ] `bug-analysis/` - Bug 分析目录（含 README.md）

**必需文件**：
- [ ] `README.md` - 项目总览
- [ ] `CHANGELOG.md` - 版本历史
- [ ] `STATUS.md` - 项目状态
- [ ] `LICENSE` - 许可证
- [ ] `package.json` - 项目配置（Node.js）

---

### 20) 大规模文件编辑策略（AI 辅助开发）

#### 适用场景
- 删除大段内容（如附录、示例代码）
- 重构大文件（>500行）结构
- 批量迁移内容到新文件
- 优化文档以减少 token 消耗

#### 策略选择

**方案 A：PowerShell/Bash 脚本编辑**（推荐）
- **适用**：删除大段连续内容、简单替换
- **优势**：
  - ✅ 可靠稳定，不受 AI 上下文限制
  - ✅ 可精确定位删除范围（如从"### 附录 A"到文件末尾）
  - ✅ UTF-8 编码控制准确
- **实施步骤**：
  1. 备份原文件：`Copy-Item file.md file.md.backup`
  2. 使用脚本精确删除/替换：
     ``powershell
     $content = [System.IO.File]::ReadAllText("file.md", [System.Text.UTF8Encoding]::new($false))
     $pos = $content.IndexOf("### 附录 A")
     if ($pos -gt 0) {
         $newContent = $content.Substring(0, $pos) + "新内容"
         [System.IO.File]::WriteAllText("file.md", $newContent, [System.Text.UTF8Encoding]::new($false))
     }
     ``
  3. 验证并删除备份

**方案 B：AI 工具 multi_edit**（受限场景）
- **适用**：小范围精确修改（<50行）、多处分散修改
- **限制**：
  - ⚠️ 大段删除可能触发模型错误
  - ⚠️ 需要精确匹配 old_string（包括空格/换行）
  - ⚠️ 编码问题可能导致乱码
- **实施步骤**：
  1. 先 `read_file` 查看最新内容
  2. 分小段编辑（每次<100行）
  3. 每次编辑后验证结果

**方案 C：混合策略**（最佳实践）
- **流程**：
  1. AI 分析优化方案（保留什么、删除什么、移动到哪里）
  2. AI 创建新文件（templates/、examples/）
  3. **PowerShell 执行大规模删除/重构**
  4. AI 修改小细节（链接更新、引用修正）
  5. AI 验证最终效果

#### 最佳实践

1. **始终备份**
   ``powershell
   Copy-Item "guidelines/guidelines/v2.md" "guidelines/guidelines/v2.md.backup"
   ``

2. **UTF-8 编码控制**
   - 使用 `[System.Text.UTF8Encoding]::new($false)` 避免 BOM
   - 避免 PowerShell 的 `Set-Content`（默认 UTF-16）

3. **分步验证**
   - 大规模编辑后立即 `read_file` 查看结果
   - 检查文件大小变化：`Get-Item file.md | Select-Object Length`
   - 对比字符数和 token 估算

4. **失败恢复**
   ``powershell
   # 如果编辑失败，快速恢复
   Copy-Item "file.md.backup" "file.md" -Force
   ``

5. **避免的陷阱**
   - ❌ 不要用 multi_edit 删除 >100行内容
   - ❌ 不要在未备份时执行大规模修改
   - ❌ 不要使用 `Out-File` 或 `>` 重定向（编码问题）

#### 案例参考

**案例：README.md 优化（删除 3 个大附录）**

``powershell
# 1. 备份
Copy-Item "guidelines/guidelines/v2.md" "guidelines/guidelines/v2.md.backup"

# 2. 精确删除从"附录 A"到文件末尾的所有内容
$content = [System.IO.File]::ReadAllText("guidelines/guidelines/v2.md", [System.Text.UTF8Encoding]::new($false))
$pos = $content.IndexOf("### 附录 A：根级风格文件模板")
if ($pos -gt 0) {
    $beforeAppendix = $content.Substring(0, $pos).TrimEnd()
    $newContent = $beforeAppendix + "`
`
---`
`
## 附录：模板与脚本`
`
" +
                  "详细模板和自动化脚本已移至独立文件，按需查阅：`
`
" +
                  "- 📄 [文件模板](../templates/file-templates.md)`
" +
                  "- 🤖 [自动化脚本](../templates/automation-scripts.md)`
"
    [System.IO.File]::WriteAllText("guidelines/guidelines/v2.md", $newContent, [System.Text.UTF8Encoding]::new($false))
}

# 3. 验证
$before = (Get-Item "guidelines/guidelines/v2.md.backup").Length
$after = (Get-Item "guidelines/guidelines/v2.md").Length
Write-Host "原始: $before 字节, 优化后: $after 字节, 节省: $($before - $after) 字节"

# 4. 确认无误后删除备份
Remove-Item "guidelines/guidelines/v2.md.backup"
``

**效果**：
- 原始 16,037 字符 → 优化后 12,061 字符
- 节省 25% token，保持规范完整

---

### 21) 验证与测试策略（完整流程）

> **章节目标**: 统一说明所有验证要求、优先级矩阵、执行时机和失败处理流程

#### 验证分类与优先级

本章节整合了规范中分散的验证要求（涉及场景A、第3.1章、第5章、第6章、第7章、第16章等），提供统一的验证决策矩阵。

**开发阶段验证**（本地执行，代码修改后）

🔴 **强制执行**：
```yaml
单元测试:
  命令: npm test (或项目定义的测试命令)
  位置: test/ 或 tests/
  要求: 正常路径 + 异常路径 + 边界用例
  覆盖率: ≥60% (核心API ≥70%)
  参考: 第7章

示例运行:
  命令: node examples/<功能>.examples.js
  位置: examples/
  要求: 独立可运行 + 详细注释
  验证: 输出符合预期
  参考: 第18章

文档一致性:
  检查: README/CHANGELOG/STATUS 与代码同步
  检查: API签名、参数、返回值一致
  检查: 类型声明文件（index.d.ts）同步
  参考: 第6章、第15章
```

🟠 **必须执行**（除非特殊情况）：
```yaml
覆盖率检查:
  命令: npm run coverage (或项目定义)
  要求: 行覆盖率≥60%, 分支覆盖率≥60%
  参考: 第7章

代码风格:
  命令: npm run lint (或 eslint/prettier)
  要求: 无 lint 错误
  参考: 第1章

敏感信息检查:
  检查: 日志中无密码/token/连接串
  检查: 注释/示例无真实凭据
  参考: 第10章、第14章
```

🟡 **推荐执行**：
```yaml
集成测试:
  命令: npm run test:integration (如果项目有)
  位置: test/integration/
  要求: 跨模块交互验证

性能基准:
  命令: npm run benchmark (如果项目有)
  位置: benchmarks/
  要求: 性能无明显退化

类型检查:
  命令: tsc --noEmit (TypeScript项目)
  命令: tsd (类型声明验证)
  要求: 无类型错误
```

---

**提交阶段验证**（Pre-commit/Pre-push）

🔴 **强制执行**：
```yaml
所有测试通过:
  - 单元测试
  - 示例可运行

文档完整性:
  - CHANGELOG [Unreleased] 已更新
  - README 与代码一致（如果API变更）
  - STATUS 状态同步（如适用）

敏感信息:
  - 无密码/token/API keys
  - 无真实数据库连接串
```

🟠 **必须执行**：
```yaml
代码质量:
  - Lint 检查通过
  - 覆盖率达标

提交信息:
  - 符合 Conventional Commits
  - 包含必要的 scope
  - 参考: 第3章
```

---

**CI/CD 验证**（自动执行）

🔴 **强制执行**：
```yaml
矩阵测试:
  - 多运行时版本（Node 18/20, Python 3.10/3.12等）
  - 多操作系统（Windows/Ubuntu）
  - 参考: 第11章

文档完整性:
  - README.md 存在
  - CHANGELOG.md 存在
  - 必要的类型声明文件存在

包体检查:
  - npm pack (库项目)
  - 包体大小合理
  - 无意外包含的文件
```

🟠 **必须执行**：
```yaml
示例验证:
  - examples/ 目录中的示例可运行
  - 示例输出正确

依赖安全:
  - npm audit (或 Dependabot)
  - 无高危漏洞
  - 参考: 第14章

代码扫描:
  - SAST 扫描（如 CodeQL）
  - Secret 扫描（如 Gitleaks）
  - 参考: 第14章
```

🟡 **推荐执行**：
```yaml
类型声明验证:
  - tsd 或 dtslint (TypeScript项目)
  - 类型定义正确性

性能回归测试:
  - 关键API性能无明显下降
  - 参考基准数据
```

---

#### 验证代码目录结构

**标准目录结构**：
```
<项目>/
├─ test/                         # 测试代码（强制）
│  ├─ unit/                      # 单元测试（强制）
│  │  ├─ features/               # 功能性测试（业务功能）
│  │  │  ├─ <功能>.test.js      # 测试文件
│  │  │  └─ ...
│  │  ├─ infrastructure/         # 基础设施测试（底层支撑）
│  │  │  ├─ logger.test.js       # 日志系统测试
│  │  │  ├─ errors.test.js       # 错误码系统测试
│  │  │  ├─ connection.test.js   # 连接管理测试
│  │  │  ├─ cache.test.js        # 缓存机制测试
│  │  │  └─ config.test.js       # 配置管理测试
│  │  └─ utils/                  # 工具函数测试（纯函数）
│  │     ├─ helpers.test.js
│  │     └─ formatters.test.js
│  ├─ integration/               # 集成测试（推荐）
│  │  ├─ <场景>.integration.test.js
│  │  └─ ...
│  └─ e2e/                       # 端到端测试（可选）
│     ├─ <流程>.e2e.test.js
│     └─ ...
├─ examples/                     # 示例验证（强制）
│  ├─ <功能>.examples.js         # 示例文件
│  └─ README.md                  # 示例说明
├─ benchmarks/                   # 性能测试（可选）
│  ├─ <功能>.benchmark.js
│  └─ ...
├─ .github/
│  └─ workflows/
│     └─ ci.yml                  # CI 验证配置
└─ coverage/                     # 覆盖率报告（自动生成）
```

**测试分类标准**：

| 测试类型 | 目录 | 测试对象 | 示例 |
|---------|------|---------|------|
| **功能性测试** | test/unit/features/ | 业务功能、对外API | find.test.js, count.test.js, aggregate.test.js |
| **基础设施测试** | test/unit/infrastructure/ | 底层支撑、内部工具 | logger.test.js, errors.test.js, connection.test.js |
| **工具函数测试** | test/unit/utils/ | 纯函数、辅助工具 | helpers.test.js, formatters.test.js |
| **集成测试** | test/integration/ | 跨模块交互 | pagination-flow.integration.test.js |
| **端到端测试** | test/e2e/ | 完整用户流程 | user-query-flow.e2e.test.js |

**分类判断标准**：

```yaml
功能性测试 (features/):
  判断条件:
    - 测试对外暴露的 API/方法
    - 测试业务功能（如查询、计数、聚合）
    - 用户直接使用的功能
  示例:
    - find.test.js         # 测试查询功能
    - count.test.js        # 测试计数功能
    - aggregate.test.js    # 测试聚合功能
    - findPage.test.js     # 测试分页功能

基础设施测试 (infrastructure/):
  判断条件:
    - 测试底层支撑系统
    - 测试跨功能的基础设施
    - 内部使用的工具类
  示例:
    - logger.test.js       # 测试日志系统
    - errors.test.js       # 测试错误码系统
    - connection.test.js   # 测试连接管理
    - cache.test.js        # 测试缓存机制
    - config.test.js       # 测试配置管理
    - validator.test.js    # 测试输入校验器

工具函数测试 (utils/):
  判断条件:
    - 测试纯函数（无副作用）
    - 测试格式化、转换函数
    - 测试可复用的辅助工具
  示例:
    - helpers.test.js      # 测试辅助函数
    - formatters.test.js   # 测试格式化函数
    - parsers.test.js      # 测试解析函数
```

**为什么要分类？**

```yaml
优势:
  ✅ 清晰分类，易于查找
  ✅ 职责明确，易于维护
  ✅ 便于单独运行某类测试
  ✅ 符合软件分层思想

问题场景（不分类）:
  ❌ logger.test.js 与 find.test.js 混在一起
  ❌ 难以区分测试类型
  ❌ 不利于测试组织和维护
```

**测试文件命名规范**：
```yaml
单元测试:
  - 文件名: <功能>.test.js
  - 描述: 中文，聚焦行为
  - 示例: findPage.test.js

集成测试:
  - 文件名: <场景>.integration.test.js
  - 描述: 完整业务流程
  - 示例: pagination-flow.integration.test.js

E2E测试:
  - 文件名: <用户流程>.e2e.test.js
  - 描述: 用户视角的完整流程
  - 示例: user-query-flow.e2e.test.js
```

**测试目录迁移指南**（从扁平结构到分层结构）:

```bash
# 适用场景：现有项目的 test/unit/ 目录下所有测试文件平铺

# 1. 创建子目录
mkdir -p test/unit/features
mkdir -p test/unit/infrastructure
mkdir -p test/unit/utils

# 2. 移动功能性测试（业务功能）
mv test/unit/find.test.js test/unit/features/
mv test/unit/count.test.js test/unit/features/
mv test/unit/aggregate.test.js test/unit/features/
mv test/unit/findPage.test.js test/unit/features/

# 3. 移动基础设施测试（底层支撑）
mv test/unit/logger.test.js test/unit/infrastructure/
mv test/unit/errors.test.js test/unit/infrastructure/
mv test/unit/connection.test.js test/unit/infrastructure/
mv test/unit/cache.test.js test/unit/infrastructure/

# 4. 移动工具函数测试（纯函数）
mv test/unit/helpers.test.js test/unit/utils/
mv test/unit/formatters.test.js test/unit/utils/

# 5. 验证测试运行
npm test

# 注意：大多数测试框架（Vitest/Jest/Mocha）自动递归扫描子目录，无需配置
```

**迁移前后对比**:

迁移前（扁平结构）:
```
test/unit/
  ├─ find.test.js           # 功能
  ├─ count.test.js          # 功能
  ├─ logger.test.js         # 基础设施 ❌ 混在一起
  ├─ errors.test.js         # 基础设施 ❌
  └─ helpers.test.js        # 工具 ❌
```

迁移后（分层结构）:
```
test/unit/
  ├─ features/              # 功能性测试 ✅ 清晰分类
  │  ├─ find.test.js
  │  └─ count.test.js
  ├─ infrastructure/        # 基础设施测试 ✅
  │  ├─ logger.test.js
  │  └─ errors.test.js
  └─ utils/                 # 工具函数测试 ✅
     └─ helpers.test.js
```

**兼容性说明**:
- ✅ Vitest/Jest: 自动递归扫描，无需配置
- ✅ Mocha: 支持子目录，无需额外配置
- ✅ CI/CD: 测试命令不变（npm test）
- ✅ 覆盖率: 正常工作，无影响

---

#### 验证优先级决策矩阵

**按操作类型**：

| 操作类型 | 单元测试 | 示例 | 文档 | 覆盖率 | 集成测试 | 性能测试 |
|---------|---------|------|------|--------|---------|---------|
| **新增功能** | 🔴 强制 | 🔴 强制 | 🔴 强制 | 🟠 必须 | 🟡 推荐 | 🟢 可选 |
| **修改功能** | 🔴 强制 | 🔴 强制 | 🟠 必须 | 🟠 必须 | 🟡 推荐 | 🟢 可选 |
| **Bug修复** | 🟠 必须 | 🟢 可选 | 🔴 强制 | 🟠 必须 | 🟢 可选 | 🟢 可选 |
| **内部重构** | 🟠 必须 | 🟢 可选 | 🟢 可选 | 🟠 必须 | 🟡 推荐 | 🟢 可选 |
| **性能优化** | 🟠 必须 | 🟡 推荐 | 🔴 强制 | 🟠 必须 | 🟡 推荐 | 🔴 强制 |
| **文档修改** | 🟢 可选 | 🟠 必须 | 🟠 必须 | 🟢 可选 | 🟢 可选 | 🟢 可选 |

**按验证阶段**：

| 验证阶段 | 执行时机 | 强制项 | 必须项 | 推荐项 |
|---------|---------|--------|--------|--------|
| **开发阶段** | 代码修改后 | 单元测试、示例运行 | 覆盖率、Lint | 集成测试 |
| **提交阶段** | Git commit前 | 测试通过、文档同步 | Lint通过 | 类型检查 |
| **CI/CD** | PR提交后 | 矩阵测试、文档完整 | 示例验证、安全扫描 | 性能测试 |

---

#### 验证失败处理流程

**本地验证失败**：

```yaml
单元测试失败:
  1. 检查错误信息
  2. 定位失败的测试用例
  3. 修复代码或更新测试
  4. 重新运行: npm test
  5. 确保全部通过

示例运行失败:
  1. 手动运行示例: node examples/<功能>.examples.js
  2. 检查输出与预期是否一致
  3. 修复代码或更新示例
  4. 更新 README 中的示例引用
  5. 重新验证

覆盖率不达标:
  1. 运行: npm run coverage
  2. 查看覆盖率报告
  3. 补充测试用例（边界/异常路径）
  4. 重新运行验证覆盖率

文档不一致:
  1. 对比 README 与代码
  2. 对比 CHANGELOG [Unreleased]
  3. 对比类型声明文件（如 index.d.ts）
  4. 更新不一致的部分
  5. 手动验证示例可运行
```

**CI 验证失败**：

```yaml
矩阵测试失败:
  1. 检查 CI 日志
  2. 识别失败的运行时/OS组合
  3. 本地复现问题（使用相同环境）
  4. 修复后推送
  5. 等待 CI 重新运行

文档完整性检查失败:
  1. 检查缺失的文件（README/CHANGELOG/STATUS）
  2. 补充缺失的文档
  3. 或在 Profile 中声明例外
  4. 重新推送

依赖安全扫描失败:
  1. 查看漏洞详情（npm audit 或 Dependabot）
  2. 评估影响范围
  3. 升级依赖版本
  4. 或添加 .npmrc / package.json 配置忽略（需说明理由）
  5. 重新验证

包体检查失败:
  1. 运行本地: npm pack
  2. 检查包体内容: tar -tzf *.tgz
  3. 更新 .npmignore 或 package.json files 字段
  4. 重新打包验证
```

---

#### 自动化验证工具

**测试框架**（参见第7章）：
```yaml
Node.js:
  - Vitest / Jest (推荐)
  - Mocha + Chai (备选)

Python:
  - pytest (推荐)

Go:
  - testing 包 (内置)

Java:
  - JUnit (标准)

Rust:
  - cargo test (内置)
```

**覆盖率工具**：
```yaml
Node.js:
  - c8 (Vitest 默认)
  - nyc (Jest/Mocha)

Python:
  - pytest-cov

Go:
  - go test -cover

Java:
  - JaCoCo

Rust:
  - tarpaulin / grcov
```

**代码质量工具**：
```yaml
Lint:
  - ESLint (JavaScript/TypeScript)
  - Pylint (Python)
  - golangci-lint (Go)
  - Clippy (Rust)

格式化:
  - Prettier (JavaScript/TypeScript)
  - Black (Python)
  - gofmt (Go)
  - rustfmt (Rust)

类型检查:
  - TypeScript tsc
  - mypy (Python)
```

**安全扫描工具**：
```yaml
依赖扫描:
  - npm audit (Node.js)
  - Dependabot (GitHub)
  - Snyk (多语言)

Secret 扫描:
  - Gitleaks
  - TruffleHog
  - GitHub Secret Scanning

SAST:
  - CodeQL (GitHub)
  - SonarQube
  - Semgrep
```

---

#### 验证命令速查表

**Node.js 项目**：
```bash
# 本地验证
npm ci                           # 安装依赖
npm test                         # 运行测试
npm run coverage                 # 覆盖率检查
npm run lint                     # 代码风格
node examples/<功能>.examples.js # 示例验证

# 构建验证
npm run build                    # 构建
npm pack                         # 包体检查

# 安全验证
npm audit                        # 依赖扫描
```

**Python 项目**：
```bash
# 本地验证
pip install -r requirements.txt  # 安装依赖
pytest                           # 运行测试
pytest --cov                     # 覆盖率检查
pylint src/                      # 代码风格
python examples/<功能>.py        # 示例验证

# 构建验证
python -m build                  # 构建

# 安全验证
safety check                     # 依赖扫描
```

**Go 项目**：
```bash
# 本地验证
go mod download                  # 安装依赖
go test ./...                    # 运行测试
go test -cover ./...             # 覆盖率检查
golangci-lint run                # 代码风格
go run examples/<功能>.go        # 示例验证

# 构建验证
go build                         # 构建

# 安全验证
go list -json -m all | nancy     # 依赖扫描
```

---

#### 验证最佳实践

**1. 测试优先**（Test-First）：
```yaml
新增功能:
  1. 先写测试用例（描述预期行为）
  2. 实现功能代码
  3. 运行测试验证
  4. 重构优化
  5. 再次验证

优势:
  - ✅ 明确功能边界
  - ✅ 防止过度设计
  - ✅ 自动回归保护
```

**2. 持续验证**（Continuous Verification）：
```yaml
开发过程:
  - 每次修改后立即运行单元测试
  - 使用 watch 模式自动测试
  - 提交前运行完整验证

工具支持:
  - npm run test:watch (Vitest/Jest)
  - pytest --watch (pytest-watch)
  - git hooks (husky + lint-staged)
```

**3. 分层验证**（Layered Verification）：
```yaml
第1层 - 快速反馈:
  - 单元测试（秒级）
  - Lint 检查（秒级）

第2层 - 完整验证:
  - 集成测试（分钟级）
  - 示例验证（分钟级）

第3层 - 全面验证:
  - E2E测试（分钟到小时级）
  - 性能测试（分钟到小时级）
  - 矩阵测试（CI自动）
```

**4. 失败快速**（Fail Fast）：
```yaml
验证顺序:
  1. 最快的检查先执行（Lint）
  2. 单元测试次之
  3. 集成测试最后

CI 策略:
  - 并行运行不同验证
  - 快速失败的任务优先
  - 保存失败日志和截图
```

**5. 可视化覆盖率**：
```yaml
工具:
  - Codecov (云端)
  - Coveralls (云端)
  - c8 html reporter (本地)

PR 集成:
  - 显示覆盖率变化
  - 标注未覆盖的代码行
  - 阻止覆盖率下降
```

---

#### 验证与规范其他章节的关系

本章节整合以下章节的验证要求：

| 规范章节 | 验证内容 | 本章对应 |
|---------|---------|---------|
| 场景A | 功能验证（测试+示例） | 开发阶段验证 |
| 第3.1章 | 自检与验证 | 提交阶段验证 |
| 第5章 | 示例验证 | 示例运行验证 |
| 第6章 | 文档一致性 | 文档验证 |
| 第7章 | 测试框架和覆盖率 | 测试分类和工具 |
| 第11章 | CI 矩阵 | CI/CD 验证 |
| 第15章 | 文档自检 | 文档完整性 |
| 第16章 | PR 门禁清单 | 验证决策矩阵 |
| 第18章 | 示例目录 | 示例验证 |

**使用建议**：
- 🔴 新增/修改功能 → 参考"验证优先级决策矩阵"
- 🟠 验证失败 → 参考"验证失败处理流程"
- 🟡 设置CI → 参考"CI/CD验证"章节
- 🟢 选择工具 → 参考"自动化验证工具"章节

---

### 22) 验证脚本与工具目录规范

> **章节目标**: 规范验证脚本、构建脚本、部署脚本等工具的目录结构和命名规范

#### 目录结构

**标准目录**:
```
<项目>/
  scripts/                         # 所有脚本的根目录
    ├─ README.md                   # 脚本使用说明
    ├─ verify/                     # 验证脚本
    │  ├─ README.md
    │  ├─ compliance/              # 合规性验证（一次性）
    │  ├─ docs/                    # 文档完整性验证（CI）
    │  └─ data/                    # 数据验证（运维）
    ├─ build/                      # 构建脚本
    ├─ deploy/                     # 部署脚本
    ├─ migration/                  # 数据迁移脚本
    └─ utils/                      # 辅助工具
```

**与现有目录的关系**:
- `test/` → 测试用例（npm test 执行）
- `examples/` → 功能示例（可运行代码）
- `scripts/` → 工具脚本（手动或CI按需执行）

---

#### 验证脚本分类

**1. 合规性验证脚本**（scripts/verify/compliance/）

**用途**: 验证项目改进、重构是否正确实施

**特点**:
- ✅ 一次性执行（改进完成后）
- ❌ 不纳入 CI 持续集成
- ✅ 验证规范遵守情况

**示例**:
```javascript
// scripts/verify/compliance/verify-p0-improvements.js
// 验证 P0 优先级改进是否完整实施

// scripts/verify/compliance/verify-error-code-system.js
// 验证错误码系统是否正确实现

// scripts/verify/compliance/verify-config-changes.js
// 验证配置项变更是否符合规范
```

**命名规范**:
```
verify-<目标>-<方面>.js

示例:
✅ verify-p0-improvements.js
✅ verify-error-code-system.js
✅ verify-log-enhancement.js
✅ verify-constants-migration.js

❌ verifyP0.js              # 不使用驼峰
❌ check-p0.js              # 统一使用 verify 前缀
❌ p0-verify.js             # 前缀应该是 verify
```

---

**2. 文档完整性验证脚本**（scripts/verify/docs/）

**用途**: 验证文档与代码一致性（CI 自动执行）

**特点**:
- ✅ CI 持续执行
- ✅ 属于质量门禁
- ✅ 验证文档完整性

**示例**:
```javascript
// scripts/verify/docs/verify-docs-completeness.js
// 验证 README/CHANGELOG/STATUS 存在

// scripts/verify/docs/verify-examples-runnable.js
// 验证 examples/ 中的示例可运行

// scripts/verify/docs/verify-api-docs-sync.js
// 验证 API 文档与代码同步

// scripts/verify/docs/verify-changelog-format.js
// 验证 CHANGELOG.md 格式符合 Keep a Changelog
```

**CI 集成示例**:
```yaml
# .github/workflows/ci.yml
name: CI

on: [push, pull_request]

jobs:
  verify:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Verify Documentation Completeness
        run: node scripts/verify/docs/verify-docs-completeness.js
      
      - name: Verify Examples Runnable
        run: node scripts/verify/docs/verify-examples-runnable.js
      
      - name: Verify CHANGELOG Format
        run: node scripts/verify/docs/verify-changelog-format.js
```

---

**3. 数据验证脚本**（scripts/verify/data/）

**用途**: 验证数据迁移、数据库 schema（部署/迁移时执行）

**特点**:
- ✅ 部署/迁移时执行
- ⚠️ 环境特定
- ⚠️ 可能访问生产数据

**示例**:
```javascript
// scripts/verify/data/verify-migration-success.js
// 验证数据迁移成功

// scripts/verify/data/verify-schema-consistency.js
// 验证数据库 schema 一致性

// scripts/verify/data/verify-data-integrity.js
// 验证数据完整性和关联关系
```

---

#### 其他脚本目录

**构建脚本**（scripts/build/）:
```
scripts/build/
  ├─ build.js              # 构建项目
  ├─ pack.js               # 打包
  ├─ minify.js             # 压缩
  └─ generate-docs.js      # 生成文档
```

**部署脚本**（scripts/deploy/）:
```
scripts/deploy/
  ├─ deploy.js             # 部署到服务器
  ├─ rollback.js           # 回滚
  ├─ health-check.js       # 健康检查
  └─ backup.js             # 备份
```

**迁移脚本**（scripts/migration/）:
```
scripts/migration/
  ├─ migrate-v1-to-v2.js
  ├─ rollback-v2-to-v1.js
  └─ seed-data.js
```

---

#### scripts/README.md 模板

每个项目的 `scripts/` 目录应包含 `README.md` 说明文档：

```markdown
# 项目脚本说明

本目录包含项目的各类脚本工具。

## 📁 目录结构

- `verify/` - 验证脚本
  - `compliance/` - 合规性验证（改进完成后执行）
  - `docs/` - 文档完整性验证（CI 自动执行）
  - `data/` - 数据验证（部署/迁移时执行）
- `build/` - 构建脚本
- `deploy/` - 部署脚本
- `migration/` - 数据迁移脚本
- `utils/` - 辅助工具

## 🚀 使用方法

### 验证脚本

**合规性验证**（手动执行）:
```bash
# 验证 P0 改进
node scripts/verify/compliance/verify-p0-improvements.js

# 验证错误码系统
node scripts/verify/compliance/verify-error-code-system.js
```

**文档完整性验证**（CI 自动执行）:
```bash
# 验证文档完整性
node scripts/verify/docs/verify-docs-completeness.js

# 验证示例可运行
node scripts/verify/docs/verify-examples-runnable.js
```

**数据验证**（部署/迁移时执行）:
```bash
# 验证数据迁移
node scripts/verify/data/verify-migration-success.js
```

### 构建脚本

```bash
# 构建项目
node scripts/build/build.js

# 打包
node scripts/build/pack.js
```

### 部署脚本

```bash
# 部署到生产环境
node scripts/deploy/deploy.js --env production

# 回滚
node scripts/deploy/rollback.js --version 1.0.0
```

## 📝 规范参考

详细规范请参考：[第22章 验证脚本与工具目录规范](../../guidelines/guidelines/v2.md#22-验证脚本与工具目录规范)
```

---

#### 验证脚本编写最佳实践

**1. 脚本应该自包含，明确返回退出码**:
```javascript
// ✅ 好的做法
const results = verifyP0Improvements();

if (results.failed.length > 0) {
    console.error('❌ 验证失败:', results.failed);
    process.exit(1);  // 失败返回 1
}

console.log('✅ 验证通过');
process.exit(0);  // 成功返回 0
```

**2. 提供详细的错误信息和修复建议**:
```javascript
// ✅ 好的做法
console.error(`
❌ 错误码系统验证失败

未找到的错误码:
  - VALIDATION_ERROR
  - INVALID_COLLECTION_NAME

修复建议:
  1. 检查 lib/errors.js 是否导出所有错误码
  2. 检查 test/ 目录是否有对应测试
  3. 运行 npm test 确保测试覆盖

参考文档: guidelines/analysis-reports/P0-improvements-report.md
`);
```

**3. 支持选项参数**:
```javascript
// ✅ 好的做法
const args = process.argv.slice(2);
const verbose = args.includes('--verbose');
const fix = args.includes('--fix');
const output = args.find(arg => arg.startsWith('--output='));

if (verbose) {
    console.log('详细模式已启用');
}

if (fix) {
    console.log('自动修复模式');
    // 执行自动修复
}
```

**4. 记录验证结果**:
```javascript
// ✅ 好的做法
const results = {
    timestamp: new Date().toISOString(),
    passed: [...],
    failed: [...],
    warnings: [...],
    summary: {
        total: 10,
        passed: 8,
        failed: 2,
        warnings: 1
    }
};

// 支持输出到文件
if (args.includes('--output')) {
    const fs = require('fs');
    fs.writeFileSync(
        'verify-results.json',
        JSON.stringify(results, null, 2)
    );
}

// 输出到控制台
console.log('\n📊 验证结果:');
console.log(`  通过: ${results.summary.passed}/${results.summary.total}`);
console.log(`  失败: ${results.summary.failed}`);
console.log(`  警告: ${results.summary.warnings}`);
```

---

#### 从 test/ 迁移到 scripts/verify/

**迁移步骤**（针对现有项目）:

```bash
# 1. 创建目录结构
mkdir -p scripts/verify/compliance
mkdir -p scripts/verify/docs
mkdir -p scripts/verify/data

# 2. 移动现有验证脚本
# monSQLize 项目示例
mv test/verify-p0.js scripts/verify/compliance/verify-p0-improvements.js

# vsse 项目示例
mv test/verify-config-changes.js scripts/verify/compliance/

# 3. 更新 package.json 脚本引用
# 从: "verify:p0": "node test/verify-p0.js"
# 到: "verify:p0": "node scripts/verify/compliance/verify-p0-improvements.js"

# 4. 更新 CI 配置（如果有）
# 更新 .github/workflows/*.yml 中的脚本路径

# 5. 创建 scripts/README.md
# 添加脚本使用说明

# 6. 测试验证
node scripts/verify/compliance/verify-p0-improvements.js
```

**迁移前后对比**:

迁移前:
```
<项目>/
  test/
    verify-p0.js          # 与测试用例混在一起
    run-tests.js
    unit/
    integration/
```

迁移后:
```
<项目>/
  test/                   # 纯测试用例
    run-tests.js
    unit/
    integration/
  scripts/                # 独立脚本目录
    README.md
    verify/
      compliance/
        verify-p0-improvements.js
```

---

#### 与第21章的关系

| 维度 | 第21章（验证与测试策略） | 第22章（验证脚本目录） |
|------|---------------------|-------------------|
| **焦点** | 测试用例的验证流程 | 验证脚本的组织管理 |
| **范围** | test/ 目录中的测试 | scripts/ 目录中的脚本 |
| **执行** | npm test / CI 自动 | 手动 / CI 按需 |
| **目的** | 保证代码质量 | 保证规范遵守 |
| **工具** | 测试框架（Vitest/Jest） | Node.js 脚本 |

**互补关系**:
- 第21章：**如何验证**（测试用例、覆盖率、CI）
- 第22章：**如何组织验证工具**（脚本目录、命名、分类）

**协同使用**:
```yaml
场景: 实施 P0 改进

第21章指导:
  - 添加单元测试到 test/unit/
  - 验证覆盖率 ≥60%
  - CI 自动运行测试

第22章指导:
  - 创建验证脚本 scripts/verify/compliance/verify-p0-improvements.js
  - 手动执行验证改进是否完整
  - 记录验证结果
```

---

#### 命名规范总结

**验证脚本**:
```
verify-<目标>-<方面>.js

规则:
- 使用 kebab-case
- 动词-名词结构
- 清晰表达验证目的

示例:
✅ verify-p0-improvements.js
✅ verify-docs-completeness.js
✅ verify-examples-runnable.js
✅ verify-migration-success.js

❌ verifyP0.js              # 不使用驼峰
❌ check-p0.js              # 统一使用 verify 前缀
❌ p0-verify.js             # 前缀应该是 verify
❌ verify_p0.js             # 使用 - 而非 _
```

**其他脚本**:
```
<动词>-<名词>.js

示例:
✅ build-project.js
✅ deploy-production.js
✅ migrate-database.js
✅ generate-docs.js
✅ rollback-deployment.js

❌ projectBuild.js          # 不使用驼峰
❌ prod_deploy.js           # 使用 - 而非 _
```

---

#### 实施建议

**新项目**:
- ✅ 立即采用 scripts/ 目录结构
- ✅ 按类型分类（verify/build/deploy等）
- ✅ 创建 scripts/README.md

**现有项目**:
- 🟡 推荐迁移（工作量小，约 5-10 分钟）
- 🟡 优先迁移验证脚本（verify-*.js）
- 🟢 可选：保持现状直到下次重构

**CI 集成**:
- ✅ 文档完整性验证纳入 CI（scripts/verify/docs/）
- ❌ 合规性验证不纳入 CI（scripts/verify/compliance/）
- ⚠️ 数据验证按需纳入 CI（scripts/verify/data/）

---

#### Git 管理策略

**scripts/ 目录** (✅ 应该提交):

验证脚本和工具应该提交到 Git 版本控制：

```yaml
目录:
  - scripts/verify/        # 验证脚本（应该提交）
  - scripts/build/         # 构建脚本（应该提交）
  - scripts/deploy/        # 部署脚本（应该提交）
  - scripts/migration/     # 迁移脚本（应该提交）
  - scripts/utils/         # 工具脚本（应该提交）

理由:
  1. 人工编写的代码，项目基础设施的一部分
  2. 团队共享的工具，需要版本控制
  3. 有版本管理需求，需要追踪变更
  4. CI/CD 依赖这些脚本
  5. 部署和迁移需要这些工具
```

**验证结果和日志** (❌ 不应该提交):

验证执行产生的结果文件不应提交：

```yaml
文件/目录:
  - verify-results.json    # 验证结果输出
  - verify-*.log           # 验证日志
  - test-results/          # 测试结果目录
  - build-output/          # 构建输出
  - deploy-logs/           # 部署日志

理由:
  - 自动生成，每次运行都不同
  - 可以重新生成
  - 文件可能很大
  - 无版本管理意义
```

**.gitignore 配置**:

```gitignore
# ====================
# 脚本代码（应该提交）
# ====================

# scripts/             ← 不要忽略

# ====================
# 脚本执行结果（不提交）
# ====================

# 验证结果
verify-results.json
verify-*.log
*-verify-report.json

# 测试结果
test-results/
test-output/
*.test-results.xml

# 构建产物（根据项目需要）
dist/
build/
*.build.log

# 部署日志
deploy-logs/
*.deploy.log
```

**注意事项**:

1. **脚本中的敏感信息**:
   ```yaml
   scripts/ 中不应包含:
     ❌ 硬编码的密码、API keys
     ❌ 生产环境连接串
     ❌ 真实的服务器地址（可使用占位符）
   
   推荐做法:
     ✅ 使用环境变量: process.env.API_KEY
     ✅ 使用配置文件: require('./.env')
     ✅ 使用占位符注释: // API_KEY=your_key_here
   ```

2. **脚本可执行权限**:
   ```bash
   # Git 可以记录文件的可执行权限
   chmod +x scripts/deploy/deploy.sh
   git add scripts/deploy/deploy.sh
   # Git 会保存可执行权限
   ```

3. **跨平台兼容**:
   ```yaml
   建议:
     ✅ 使用 Node.js 脚本（跨平台）
     ✅ 或提供 .sh 和 .ps1 两个版本
     ✅ 在 scripts/README.md 中说明平台要求
   
   避免:
     ❌ 仅提供 Windows 脚本（.bat, .cmd）
     ❌ 仅提供 Unix 脚本（.sh）
   ```

**scripts/README.md 模板**:

在 scripts/ 目录中应该包含 README.md 说明文档（参见本章前面的模板），该文档也应该提交到 Git。

---

---

## 附录：模板与脚本

详细模板和自动化脚本已移至独立文件，按需查阅：

- 📄 [文件模板](../templates/file-templates.md) - .editorconfig、.gitattributes、README、CHANGELOG、STATUS、Profile 模板
- 🤖 [自动化脚本](../templates/automation-scripts.md) - PowerShell 自检脚本、GitHub Actions 配置
