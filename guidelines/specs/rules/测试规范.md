# v3 测试规范

> **文件**: specs/rules/测试规范.md  
> **版本**: v3.0  
> **日期**: 2025-11-25  
> **说明**: AI 生成测试的质量规范（简化版）

---

## 📋 核心原则

```yaml
🔴 强制规则:
  1. 测试目录结构固定，不可选择
  2. 测试类型明确，不可混用
  3. 必须先查阅本规范，再编写测试
  4. 有路由配置的项目使用 API 测试，不配置数据库
```

---

## 📂 测试目录结构（🔴 固定，不可更改）

**参考 monSQLize 项目，严格遵守以下结构**:

```
test/
├── unit/                      # 单元测试目录
│   ├── features/             # 功能测试
│   │   ├── findOne.test.js
│   │   ├── find.test.js
│   │   └── ...
│   ├── cache/                # 缓存测试
│   └── utils/                # 工具函数测试
│
├── integration/              # 集成测试目录
│   ├── database.test.js
│   └── ...
│
├── performance/              # 性能测试目录
│   └── benchmark.test.js
│
└── run-tests.js             # 测试运行器（可选）
```

**文件命名规则（🔴 严格遵守）**:

```yaml
单元测试:
  - 位置: test/unit/features/{功能名}.test.js
  - 示例: test/unit/features/findOne.test.js
  - 规则: 功能名使用 camelCase

集成测试:
  - 位置: test/integration/{模块名}.test.js
  - 示例: test/integration/database.test.js

性能测试:
  - 位置: test/performance/benchmark.test.js
```

---

## 🎯 测试类型判断（🔴 严格区分）

### 判断规则：何时使用 API 测试 vs 单元测试

```yaml
API 测试（发起 HTTP 请求）:
  ✅ 必须使用 API 测试的情况:
    - 项目有路由配置（如 routes/ 目录）
    - 测试完整的 HTTP 请求流程
    - 测试需要经过中间件（认证/参数校验/错误处理）
    - 测试涉及数据库操作 且 项目有路由功能
  
  ✅ 优点:
    - 无需手动配置数据库连接
    - 测试真实的请求流程
    - 自动测试中间件链
  
  📍 测试位置:
    - test/integration/api.test.js

单元测试（直接导入模块）:
  ✅ 必须使用单元测试的情况:
    - 纯函数/工具函数
    - 业务逻辑函数（不涉及 HTTP）
    - 数据处理和转换
    - 算法和计算
    - 库/工具包项目（如 monSQLize）
  
  ✅ 优点:
    - 快速执行
    - 易于调试
    - 可以测试内部逻辑
  
  📍 测试位置:
    - test/unit/features/{功能名}.test.js
```

**判断流程图**:

```
是否有路由配置（routes/目录）？
    ├─ 是 → 涉及数据库操作？
    │      ├─ 是 → 使用 API 测试（test/integration/api.test.js）
    │      └─ 否 → 使用单元测试（test/unit/）
    │
    └─ 否 → 是库/工具包项目？
           ├─ 是 → 使用单元测试（test/unit/）
           └─ 否 → 根据功能判断
```

---

## 📝 测试用例编写规范（🔴 必须遵守）

### 步骤 1: 查阅本规范

```yaml
在编写任何测试前，必须:
  1. 阅读本规范文件
  2. 确认测试类型（API测试 or 单元测试）
  3. 确认测试文件位置
  4. 确认测试命名规则
```

### 步骤 2: 选择测试模板

根据测试类型，选择对应的模板：

---

## 📋 测试模板

### 模板 1: 单元测试（库/工具包项目）

**适用场景**: monSQLize、工具库、算法库

**文件位置**: `test/unit/features/{功能名}.test.js`

**完整模板**:

```javascript
const MonSQLize = require('../../../lib');
const assert = require('assert');

describe('findOne 方法测试', function () {
  this.timeout(30000);
  
  let msq;
  let collection;
  let nativeCollection;
  
  // ==================== 测试前准备 ====================
  before(async function () {
    console.log('🔧 初始化测试环境...');
    
    // 1. 创建实例（使用内存数据库）
    msq = new MonSQLize({
      type: 'mongodb',
      databaseName: 'test_findOne',
      config: { useMemoryServer: true }  // ⭐ 自动管理内存数据库
    });
    
    // 2. 连接数据库
    const conn = await msq.connect();
    collection = conn.collection;
    
    // 3. 获取原生集合对象用于准备数据
    const db = msq._adapter.db;
    nativeCollection = db.collection('users');
    
    // 4. 准备测试数据
    await nativeCollection.deleteMany({});
    await nativeCollection.insertMany([
      { userId: 'USER-001', name: '测试用户1', status: 'active' },
      { userId: 'USER-002', name: '测试用户2', status: 'inactive' }
    ]);
    
    console.log('✅ 测试数据准备完成');
  });
  
  // ==================== 测试后清理 ====================
  after(async function () {
    console.log('🧹 清理测试环境...');
    if (msq && nativeCollection) {
      await nativeCollection.deleteMany({});
      await msq.close();
    }
    console.log('✅ 清理完成');
  });
  
  // ==================== 测试用例 ====================
  describe('1. 基础查询', function () {
    it('1.1 应该返回匹配的文档', async function () {
      // Arrange（准备）
      const userId = 'USER-001';
      
      // Act（执行）
      const result = await collection('users').findOne({ userId });
      
      // Assert（断言）
      assert.ok(result, '应该返回结果');
      assert.equal(result.userId, userId, 'userId 应该匹配');
      assert.equal(result.name, '测试用户1', 'name 应该匹配');
    });
    
    it('1.2 应该返回 null 当无匹配时', async function () {
      const result = await collection('users').findOne({ 
        userId: 'NONEXISTENT' 
      });
      
      assert.strictEqual(result, null, '应该返回 null');
    });
  });
  
  describe('2. 边界情况', function () {
    it('2.1 应该处理空查询条件', async function () {
      const result = await collection('users').findOne({});
      assert.ok(result !== undefined, '应该返回结果');
    });
  });
});
```

**必须遵守的规则**:

```yaml
✅ 必须:
  - 使用 describe 嵌套组织测试
  - 使用 before/after 管理生命周期
  - 使用内存数据库（useMemoryServer: true）
  - 使用 assert 断言库
  - 测试用例编号（1.1, 1.2, 2.1...）
  - AAA 模式（Arrange/Act/Assert）

❌ 禁止:
  - 连接真实数据库
  - 测试之间相互依赖
  - 使用全局变量共享状态
  - 跳过清理步骤
```

---

### 模板 2: API 测试（有路由的项目）

**适用场景**: Express/Egg.js 等 Web 项目，涉及数据库操作

**文件位置**: `test/integration/api.test.js`

---

#### 🔴 API 测试前必须完成的步骤

**步骤 1: 了解项目框架**

```yaml
必须查看:
  1. package.json 的 dependencies
     - express → Express 框架
     - egg → Egg.js 框架
     - koa → Koa 框架
     - nestjs → NestJS 框架
  
  2. 项目入口文件
     - app.js / app.ts
     - index.js / index.ts
     - server.js

示例:
  # 查看 package.json
  cat package.json | grep -E "express|egg|koa|nest"
  
  # 查看入口文件
  ls app.js app.ts index.js index.ts server.js
```

**步骤 2: 查看测试配置**

```yaml
必须查看:
  1. 测试配置文件
     - config/config.test.js
     - config/config.unittest.js
     - .env.test
     - config.test.json
  
  2. 查看配置内容:
     - 测试端口（port）
     - 测试数据库连接
     - 测试环境变量
  
  3. 查看已有测试（如果有）
     - test/ 目录下的现有测试文件
     - 查看如何启动应用
     - 查看如何获取接口地址

示例（Egg.js）:
  # 查看测试配置
  cat config/config.unittest.js
  
  输出:
    config.cluster = {
      listen: { port: 7001 }  // ← 测试端口
    }

示例（Express）:
  # 查看 .env.test
  cat .env.test
  
  输出:
    PORT=3001                  // ← 测试端口
    DB_HOST=localhost
```

**步骤 3: 查看路由定义**

```yaml
必须查看:
  1. 路由文件位置
     - routes/ 目录
     - app/router.js
     - app/routes/
  
  2. 确认接口路径
     - 前缀（如 /api, /v1）
     - 具体路径（如 /users, /auth/login）
  
  3. 确认 HTTP 方法
     - GET, POST, PUT, DELETE

示例（Egg.js）:
  # 查看路由文件
  cat app/router.js
  
  输出:
    router.get('/api/users/:id', controller.users.show);
    router.post('/api/users', controller.users.create);
    // ← 接口前缀是 /api

示例（Express）:
  # 查看路由文件
  cat routes/users.js
  
  输出:
    router.get('/:id', getUser);
    router.post('/', createUser);
    // 需要结合 app.js 查看前缀:
    // app.use('/api/users', userRoutes);
    // ← 完整路径是 /api/users/:id
```

**步骤 4: 查看现有测试（如果有）**

```yaml
如果项目已有测试:
  1. 查看测试文件
     - test/app/*.test.js
     - test/integration/*.test.js
  
  2. 学习如何启动应用
     - 如何导入 app
     - 如何获取测试实例
     - 如何清理资源
  
  3. 学习如何构造请求
     - 基础 URL
     - 认证方式
     - 请求头设置

示例:
  # 查看现有测试
  cat test/app/user.test.js
  
  学到:
    const app = require('../../app');          // ← 应用导入方式
    const request = require('supertest');
    
    await request(app)
      .get('/api/users/123')                   // ← 接口路径
      .set('Authorization', `Bearer ${token}`) // ← 认证方式
      .expect(200);
```

**🚫 禁止行为**:

```yaml
❌ 绝对禁止:
  - 猜测端口号（如随意使用 3000, 8080）
  - 猜测接口路径（如 /api/user 还是 /users）
  - 不查看配置文件就写测试
  - 复制其他项目的测试代码
  - 使用错误的应用启动方式

✅ 必须做到:
  - 查看 package.json 确认框架
  - 查看配置文件确认端口
  - 查看路由文件确认接口路径
  - 参考现有测试（如果有）
  - 验证配置正确后再编写测试
```

---

#### 完整示例：从零开始编写 API 测试

**场景**: 为一个 Egg.js 项目编写用户 API 测试

**第 1 步：查看框架**
```bash
# 查看 package.json
cat package.json

输出:
{
  "dependencies": {
    "egg": "^3.17.5",        # ← Egg.js 框架
    "egg-mongoose": "^4.0.1"
  }
}

结论: 这是 Egg.js 项目
```

**第 2 步：查看测试配置**
```bash
# 查看测试配置
cat config/config.unittest.js

输出:
module.exports = () => {
  const config = exports = {};
  
  config.cluster = {
    listen: { port: 7001 }   # ← 测试端口是 7001
  };
  
  return config;
};

结论: 测试端口是 7001
```

**第 3 步：查看路由配置**
```bash
# 查看路由文件
cat app/router.js

输出:
module.exports = app => {
  const { router, controller } = app;
  
  // 用户相关路由
  router.get('/api/users/:id', controller.users.show);
  router.post('/api/users', controller.users.create);
};

结论: 
  - 接口前缀是 /api
  - 用户路由是 /api/users
  - 支持 GET /api/users/:id 和 POST /api/users
```

**第 4 步：查看现有测试（如果有）**
```bash
# 查看是否有测试
ls test/

输出:
test/
├── app/
│   └── controller/
└── fixtures/

# 查看现有测试
cat test/app/controller/users.test.js

输出:
const { app, assert } = require('egg-mock/bootstrap');

describe('test/app/controller/users.test.js', () => {
  it('should GET /api/users/:id', () => {
    return app.httpRequest()           // ← Egg.js 使用 app.httpRequest()
      .get('/api/users/123')           // ← 完整路径
      .expect(200);
  });
});

结论:
  - Egg.js 测试使用 egg-mock/bootstrap
  - 使用 app.httpRequest() 发起请求
  - 不需要指定端口（框架自动处理）
```

**第 5 步：编写测试**

```javascript
// test/integration/user-api.test.js
const { app, assert } = require('egg-mock/bootstrap');

describe('User API 测试', () => {
  // ==================== 测试前准备 ====================
  let authToken;
  
  before(async () => {
    // 获取认证 token
    const response = await app.httpRequest()
      .post('/api/auth/login')
      .send({
        email: 'test@example.com',
        password: 'password123'
      })
      .expect(200);
    
    authToken = response.body.token;
  });
  
  // ==================== 测试用例 ====================
  describe('GET /api/users/:id', () => {
    it('应该返回用户信息', async () => {
      const response = await app.httpRequest()
        .get('/api/users/123')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);
      
      assert(response.body.id);
      assert(response.body.email);
    });
    
    it('应该返回 401 当未认证时', async () => {
      await app.httpRequest()
        .get('/api/users/123')
        .expect(401);
    });
  });
  
  describe('POST /api/users', () => {
    it('应该创建用户', async () => {
      const userData = {
        email: 'new@example.com',
        password: 'NewPass123!',
        name: 'New User'
      };
      
      const response = await app.httpRequest()
        .post('/api/users')
        .send(userData)
        .expect(201);
      
      assert(response.body.id);
      assert.equal(response.body.email, userData.email);
    });
  });
});
```

---

**模板代码**:

#### Egg.js 项目（推荐）

```javascript
// test/integration/user-api.test.js
const { app, assert } = require('egg-mock/bootstrap');

describe('User API 测试', () => {
  let authToken;
  
  before(async () => {
    // 获取认证 token（如果需要）
    const response = await app.httpRequest()
      .post('/api/auth/login')
      .send({
        email: 'test@example.com',
        password: 'password123'
      })
      .expect(200);
    
    authToken = response.body.token;
    console.log('✅ 认证完成');
  });
  
  describe('GET /api/users/:id', () => {
    it('应该返回用户信息', async () => {
      const response = await app.httpRequest()
        .get('/api/users/123')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);
      
      assert(response.body.id, '应该有 id 字段');
      assert(response.body.email, '应该有 email 字段');
      assert(!response.body.password, '不应该返回密码');
    });
    
    it('应该返回 401 当未认证时', async () => {
      await app.httpRequest()
        .get('/api/users/123')
        .expect(401);
    });
    
    it('应该返回 404 当用户不存在时', async () => {
      await app.httpRequest()
        .get('/api/users/nonexistent')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(404);
    });
  });
  
  describe('POST /api/users', () => {
    it('应该创建用户', async () => {
      const userData = {
        email: 'new@example.com',
        password: 'NewPass123!',
        name: 'New User'
      };
      
      const response = await app.httpRequest()
        .post('/api/users')
        .send(userData)
        .expect(201);
      
      assert(response.body.id, '应该返回 id');
      assert.equal(response.body.email, userData.email, 'email 应该匹配');
    });
    
    it('应该返回 400 当缺少必填字段时', async () => {
      await app.httpRequest()
        .post('/api/users')
        .send({ email: 'test@example.com' })
        .expect(400);
    });
  });
  
  describe('PUT /api/users/:id', () => {
    it('应该更新用户信息', async () => {
      const response = await app.httpRequest()
        .put('/api/users/123')
        .set('Authorization', `Bearer ${authToken}`)
        .send({ name: 'Updated Name' })
        .expect(200);
      
      assert.equal(response.body.name, 'Updated Name');
    });
  });
  
  describe('DELETE /api/users/:id', () => {
    it('应该删除用户', async () => {
      await app.httpRequest()
        .delete('/api/users/123')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(204);
    });
  });
});
```

#### Express 项目

```javascript
// test/integration/user-api.test.js
const request = require('supertest');
const app = require('../../app');  // ⚠️ 根据实际路径调整
const assert = require('assert');

describe('User API 测试', () => {
  let authToken;
  
  before(async () => {
    const response = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'test@example.com',
        password: 'password123'
      })
      .expect(200);
    
    authToken = response.body.token;
  });
  
  describe('GET /api/users/:id', () => {
    it('应该返回用户信息', async () => {
      const response = await request(app)
        .get('/api/users/123')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);
      
      assert.ok(response.body.id);
      assert.ok(response.body.email);
    });
  });
  
  describe('POST /api/users', () => {
    it('应该创建用户', async () => {
      const userData = {
        email: 'new@example.com',
        password: 'NewPass123!',
        name: 'New User'
      };
      
      const response = await request(app)
        .post('/api/users')
        .send(userData)
        .expect(201);
      
      assert.ok(response.body.id);
      assert.equal(response.body.email, userData.email);
    });
  });
});
```

---

**框架差异速查表**:

```yaml
Egg.js:
  导入方式: const { app } = require('egg-mock/bootstrap');
  发起请求: app.httpRequest().get('/path')
  断言库: assert (内置)
  配置文件: config/config.unittest.js
  无需手动启动服务器

Express:
  导入方式: const app = require('../../app');
  发起请求: request(app).get('/path')
  断言库: assert 或 chai
  配置文件: .env.test 或 config/test.js
  需要 supertest 库

Koa:
  导入方式: const app = require('../../app');
  发起请求: request(app.callback()).get('/path')
  断言库: assert 或 chai
  注意: 使用 app.callback()
```

**必须遵守的规则**:

```yaml
✅ 必须:
  - 使用 supertest 发起请求
  - 使用 .expect(statusCode) 验证状态码
  - 测试所有 HTTP 方法（GET/POST/PUT/DELETE）
  - 测试认证和权限
  - 测试错误场景（400/401/403/404）
  - 无需手动配置数据库连接（通过应用自带的连接）

❌ 禁止:
  - 直接导入 Service 或 Model
  - 手动连接数据库
  - 跳过认证测试
  - 仅测试成功场景
```

---

## 📊 测试覆盖率要求

```yaml
单元测试覆盖率:
  最低要求: 80%
  核心功能: 100%

API测试覆盖率:
  - 所有路由端点: 100%
  - HTTP 方法: 全覆盖
  - 状态码: 200/201/400/401/403/404
```

---

## ✅ 测试检查清单

**编写测试前（🔴 强制）**:
- [ ] 已阅读本测试规范
- [ ] 已确定测试类型（单元 or API）
- [ ] 已确定测试文件位置

**API 测试前必须完成（🔴 强制）**:
- [ ] 已查看 package.json 确认框架（Express/Egg.js/Koa）
- [ ] 已查看测试配置文件（config.test.js/.env.test）
- [ ] 已确认测试端口（不猜测）
- [ ] 已查看路由文件确认接口路径（不猜测）
- [ ] 已查看现有测试（如果有）学习启动方式
- [ ] 已选择正确的框架模板（Egg.js/Express）

**编写测试时**:
- [ ] 使用正确的目录结构（test/unit/ 或 test/integration/）
- [ ] 使用正确的文件命名（{功能名}.test.js）
- [ ] 使用 describe 嵌套组织
- [ ] 使用 before/after 管理生命周期
- [ ] 使用 AAA 模式（Arrange/Act/Assert）
- [ ] 测试用例有清晰的编号和描述

**API 测试特定**:
- [ ] 使用框架对应的请求方式（app.httpRequest() 或 request(app)）
- [ ] 测试所有 HTTP 方法（GET/POST/PUT/DELETE）
- [ ] 测试认证和权限
- [ ] 测试错误状态码（400/401/403/404）
- [ ] 不手动配置数据库连接

**单元测试特定**:
- [ ] 使用内存数据库（useMemoryServer: true）
- [ ] 在 before 中准备测试数据
- [ ] 在 after 中清理测试数据和关闭连接
- [ ] 测试覆盖所有分支（正常/边界/异常）

---

## 🚫 常见错误

```yaml
❌ 错误 1: 不查看配置就写测试（最严重）
  错误做法: 
    - 猜测端口号（如随意用 3000, 8080, 7001）
    - 猜测接口路径（如 /api/user 还是 /users）
    - 不看框架类型就复制模板
  
  正确做法:
    - 查看 package.json 确认框架
    - 查看配置文件确认端口
    - 查看路由文件确认接口路径
    - 参考现有测试确认启动方式

❌ 错误 2: 测试类型混用
  错误: 在单元测试中发起 HTTP 请求
  正确: 单元测试直接导入模块，API测试才发起请求

❌ 错误 3: 目录结构不规范
  错误: test/user-api.test.js
  正确: test/integration/user-api.test.js

❌ 错误 4: API测试手动配置数据库
  错误: 在 API 测试中手动连接 MongoDB
  正确: 使用应用自带的数据库连接

❌ 错误 5: 缺少清理步骤
  错误: 没有 after() 清理资源
  正确: 必须在 after() 中清理数据和关闭连接

❌ 错误 6: 使用错误的框架方法
  错误: Egg.js 项目使用 request(app).get()
  正确: Egg.js 使用 app.httpRequest().get()

❌ 错误 7: 测试相互依赖
  错误: test2 依赖 test1 创建的数据
  正确: 每个测试独立准备和清理数据
```

---

## 📚 示例参考

**参考项目**:
- 单元测试: `D:/OneDrive/Project/MySelf/monSQLize/test/`
- API测试: `D:/OneDrive/Project/Worker/chat/test/` (如果有)

**快速启动**:

1. 确定测试类型
2. 复制对应模板
3. 修改测试数据和断言
4. 运行测试验证

---

**最后更新**: 2025-11-25

