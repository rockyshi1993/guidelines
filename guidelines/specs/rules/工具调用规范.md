# v3 工具调用规范

> **文件**: specs/rules/工具调用规范.md  
> **版本**: v3.0  
> **日期**: 2025-11-21  
> **说明**: AI助手的工具调用权限、边界和安全约束

---

## 📑 目录导航

> 🔴 = 必须遵守 | 🟡 = 建议遵守 | 🟢 = 参考

- [工具调用原则](#-工具调用原则) 🔴 - 核心原则和安全要求
- [允许使用的工具](#-允许使用的工具) 🔴 - 工具清单和使用场景
  - [文件操作工具](#文件操作工具) 🔴 - 读取/创建/编辑文件
  - [代码分析工具](#代码分析工具) 🔴 - 搜索/错误检测
  - [执行工具](#执行工具) 🔴 - 终端命令执行(高风险)
  - [专业代理工具](#专业代理工具) 🟡 - 调用专业AI代理
  - [数据库工具](#数据库工具) 🟡 - MongoDB操作(MCP)
- [禁止使用的工具](#-禁止使用的工具) 🔴 - 明确禁止的操作
- [确认要求](#-确认要求) 🔴 - 哪些操作必须用户确认
- [审计日志](#-审计日志) 🔴 - 工具调用必须记录
- [错误处理](#-错误处理) 🟡 - 工具调用失败的处理
- [Profile 优先](#-profile-优先) 🟡 - 项目可自定义工具权限

---

## 📚 相关规范文件

**工具调用在执行流程中的使用**:
- 📦 [执行流程](../core/流程.md) 🔴 - STEP 9/11/13/15使用工具
- 📐 [安全规范](./安全规范.md) 🔴 - 敏感操作的安全约束
- 📐 [代码规范](./代码规范.md) 🟡 - 代码生成时使用工具
- 📐 [测试规范](./测试规范.md) 🟡 - 测试执行时使用工具

**Profile可以覆盖**:
- 🔴 如果 `guidelines/profiles/{project}.md` 定义了不同的工具权限，优先使用项目规范

---

## 🎯 工具调用原则

### 核心原则

```yaml
原则1: 安全第一
  - 所有敏感操作必须用户确认
  - 删除/部署/数据库变更必须P0确认
  - 未确认的敏感操作必须拒绝执行

原则2: 透明可追溯
  - 所有工具调用记录审计日志
  - 关键工具调用需向用户说明
  - 失败时提供明确错误信息

原则3: 最小权限
  - 只使用完成任务必需的工具
  - 优先使用低风险工具
  - 避免过度自动化

原则4: 错误容错
  - 工具调用失败不应中断整个流程
  - 提供降级方案
  - 记录失败原因和上下文

原则5: Profile优先
  - 项目Profile可以限制或扩展工具权限
  - Profile定义的禁止项优先级最高
```

---

## 🛠️ 允许使用的工具

### 文件操作工具

#### 1. read_file - 读取文件内容 ✅

**用途**: 读取项目文件内容，用于分析、理解上下文

**使用场景**:
```yaml
STEP 0: 读取Profile文件
STEP 5: 读取现有代码理解上下文
STEP 9: 读取相关模块代码
STEP 17: 读取生成的文件进行质量检查
```

**参数**:
```typescript
read_file({
  filePath: string,              // 文件绝对路径
  startLineNumberBaseZero: number, // 开始行号(0-based)
  endLineNumberBaseZero: number    // 结束行号(0-based)
})
```

**限制**:
- ✅ 无需确认，可以自由读取
- ⚠️ 不要读取二进制文件
- ⚠️ 大文件应分段读取

**示例**:
```javascript
// STEP 0: 读取Profile
const profile = await read_file({
  filePath: 'guidelines/profiles/ndsk_core.md',
  startLineNumberBaseZero: 0,
  endLineNumberBaseZero: 100
});
```

---

#### 2. create_file - 创建新文件 ⚠️

**用途**: 创建新的代码/测试/文档文件

**使用场景**:
```yaml
STEP 9: 创建新代码文件
STEP 11: 创建测试文件
STEP 15: 创建文档文件
STEP 6/18: 创建报告文件
```

**参数**:
```typescript
create_file({
  filePath: string,  // 文件绝对路径
  content: string    // 文件内容
})
```

**限制**:
- ⚠️ 如果文件已存在，会报错
- ✅ 新建文件通常无需确认(已在STEP 10确认代码)
- 🔴 创建配置文件/部署脚本需要确认

**示例**:
```javascript
// STEP 9: 创建新代码文件
await create_file({
  filePath: 'src/services/user-service.js',
  content: generatedCode
});
```

---

#### 3. insert_edit_into_file / replace_string_in_file - 编辑文件 ⚠️

**用途**: 修改现有文件内容

**使用场景**:
```yaml
STEP 9: 修改现有代码
STEP 15: 更新文档
STEP 14: 修复测试失败的代码
```

**参数**:
```typescript
// 方式1: 智能编辑
insert_edit_into_file({
  filePath: string,
  code: string,      // 改动内容(使用注释表示未改动部分)
  explanation: string
})

// 方式2: 精确替换
replace_string_in_file({
  filePath: string,
  oldString: string,  // 要替换的内容(需包含上下文)
  newString: string,  // 新内容
  explanation: string
})
```

**限制**:
- 🔴 **必须遵守"禁止删除保护"规则**
- 🔴 删除现有import/require → 需要用户确认
- 🔴 删除现有路由/函数 → 需要用户确认
- 🔴 删除现有配置 → 需要用户确认
- ✅ 新增代码/优化代码 → 无需额外确认(已在STEP 10确认)

**示例**:
```javascript
// ✅ 允许: 新增代码
await insert_edit_into_file({
  filePath: 'src/app.js',
  code: `
// ...existing code...
app.use('/api/users', userRouter);
// ...existing code...
  `,
  explanation: '添加用户路由'
});

// 🔴 需确认: 删除代码
// 必须先在STEP 10展示删除清单，用户明确同意
```

---

#### 4. file_search - 搜索文件 ✅

**用途**: 按文件名或路径模式搜索文件

**使用场景**:
```yaml
STEP 5: 查找相关模块文件
STEP 9: 查找需要修改的文件
STEP 17: 验证文件是否已生成
```

**参数**:
```typescript
file_search({
  query: string,      // Glob模式，如 "**/*.js"
  maxResults?: number // 最大返回数量
})
```

**限制**:
- ✅ 无需确认，可以自由使用

**示例**:
```javascript
// 查找所有测试文件
const testFiles = await file_search({
  query: 'test/**/*.test.js'
});
```

---

### 代码分析工具

#### 5. grep_search - 代码内容搜索 ✅

**用途**: 在代码中搜索特定字符串或正则表达式

**使用场景**:
```yaml
STEP 5: 分析现有代码结构
STEP 9: 查找函数/类定义
STEP 11: 了解测试覆盖情况
STEP 17: 验证代码是否符合规范
```

**参数**:
```typescript
grep_search({
  query: string,        // 搜索内容(支持正则)
  isRegexp?: boolean,   // 是否为正则表达式
  includePattern?: string // 文件过滤(Glob模式)
})
```

**限制**:
- ✅ 无需确认，可以自由使用

**示例**:
```javascript
// 查找所有async函数
await grep_search({
  query: 'async function',
  includePattern: 'src/**/*.js'
});
```

---

#### 6. get_errors - 获取编译/Lint错误 ✅

**用途**: 检查文件的编译错误、Lint错误

**使用场景**:
```yaml
STEP 10: 验证生成的代码质量
STEP 14: 检查修复后的代码
STEP 17: 最终质量验证
```

**参数**:
```typescript
get_errors({
  filePaths: string[]  // 要检查的文件路径数组
})
```

**限制**:
- ✅ 无需确认，可以自由使用
- ✅ 应该在STEP 10/17中自动调用

**示例**:
```javascript
// 检查生成的代码
const errors = await get_errors({
  filePaths: ['src/user-service.js', 'src/validator.js']
});

if (errors.length > 0) {
  // 修复错误
}
```

---

### 执行工具

#### 7. run_in_terminal - 执行终端命令 🔴

**用途**: 执行shell命令，如运行测试、Lint检查、构建等

**使用场景**:
```yaml
STEP 13: 运行测试
  - npm test
  - npm run test:coverage

STEP 10: Lint检查
  - npm run lint

STEP 17: 构建验证
  - npm run build

⚠️ 警告场景:
  - npm install (安装依赖)
  - git commit (提交代码)
  - 删除文件/目录
  - 部署命令
```

**参数**:
```typescript
run_in_terminal({
  command: string,     // 要执行的命令
  explanation: string, // 命令说明
  isBackground: boolean // 是否后台运行
})
```

**限制和确认要求**:

```yaml
✅ 无需确认的命令(安全命令):
  - npm test / yarn test / pnpm test
  - npm run lint / eslint
  - npm run build (仅构建)
  - git status / git diff
  - ls / dir / pwd

⚠️ 需要提示的命令(潜在风险):
  - npm install / yarn add
  - npm run deploy:staging
  - 建议: "即将执行: npm install，是否继续?"

🔴 必须确认的命令(高风险):
  - rm -rf / del
  - git push
  - npm run deploy:production
  - 数据库迁移命令
  - 必须: 在STEP 7的P0清单中展示，用户明确同意

❌ 禁止执行的命令:
  - sudo 相关命令
  - chmod 777
  - 修改系统文件
```

**示例**:
```javascript
// ✅ 允许: 运行测试
await run_in_terminal({
  command: 'npm test',
  explanation: '运行测试验证代码',
  isBackground: false
});

// 🔴 需确认: 部署到生产
// 必须在STEP 7的P0操作清单中明确列出
await run_in_terminal({
  command: 'npm run deploy:production',
  explanation: '部署到生产环境',
  isBackground: false
});
```

---

### 专业代理工具

#### 8. run_subagent - 调用专业AI代理 🟡

**用途**: 将复杂任务委托给专业AI代理处理

**可用代理**:
```yaml
代码专家 (codestral):
  - 代码生成和重构
  - 技术债务分析
  - 代码审查

推理专家 (magistral):
  - 复杂问题分析
  - 逻辑推理
  - 方案评估

视觉专家 (pixtral):
  - 图像分析
  - UI/UX评审
  - 架构图解析

最强推理 (mistral_large):
  - 最复杂的推理任务
  - 多维度综合分析
  - 战略决策建议
```

**使用场景**:
```yaml
✅ 适合使用subagent:
  - STEP 5: 复杂的系统分析(调用magistral)
  - STEP 9: 大规模代码重构(调用codestral)
  - 需要多个专业视角的评审
  - 任务可以清晰拆分和委托

⚠️ 不适合使用subagent:
  - 简单的代码生成(AI自己完成更快)
  - 主流程执行(必须由主AI控制)
  - 需要连续上下文的任务
```

**参数**:
```typescript
run_subagent({
  agentName: string,  // 代理名称: codestral/magistral/pixtral等
  task: string        // 任务描述(需清晰具体)
})
```

**限制**:
- 🟡 建议在复杂任务时使用，不强制
- ✅ 无需用户确认(因为结果由主AI验证)
- 🔴 **必须在审计日志中记录**
- 🔴 **必须在报告中说明使用了哪些代理**

**示例**:
```javascript
// STEP 5: 复杂系统分析
const analysis = await run_subagent({
  agentName: 'magistral',
  task: `分析以下系统架构的潜在问题:
         ${systemDescription}
         
         请从以下角度分析:
         1. 性能瓶颈
         2. 安全风险
         3. 可扩展性
         4. 技术债务`
});

// 记录到审计日志
auditLog.push({
  step: 'STEP 5',
  action: '调用专业代理',
  agent: 'magistral',
  task: '系统架构分析',
  timestamp: Date.now()
});
```

---

### 数据库工具

#### 9. mcp_mongodb-chat_* - MongoDB操作 🟡

**用途**: 通过MCP与MongoDB交互(仅当项目使用MongoDB时)

**重要说明**: ⚠️
- 系统中可能配置了**多个MongoDB MCP连接**
- AI在调用前**必须让用户选择**使用哪个连接
- 不同连接可能指向不同的数据库实例(开发/测试/生产)

---

**何时调用MongoDB MCP**:

```yaml
✅ 必须调用的场景:
  
  Intent-18: 数据库查询
    - 用户明确要求"查询数据库"
    - 用户要求"查看MongoDB中的数据"
    - 用户要求"统计数据"
    → 操作: 直接调用MCP查询数据
    
  Intent-14: 数据迁移
    - 用户要求"迁移数据"
    - 用户要求"导入数据到MongoDB"
    - 用户要求"数据库初始化"
    → 操作: 调用MCP创建集合/插入数据
    
  Intent-05: 系统分析 (涉及数据库)
    - 用户要求"分析数据库结构"
    - 用户要求"查看集合Schema"
    - 用户要求"分析数据库性能"
    → 操作: 调用MCP分析结构和索引

✅ 强烈建议调用的场景 (⭐ 关键改进):
  
  Intent-02: 开发新功能 (涉及数据库)
    - 用户要求"开发用户管理功能" (涉及users集合)
    - 用户要求"实现订单查询接口" (涉及orders集合)
    - 用户要求"添加数据统计功能" (涉及多个集合)
    
    → 🔴 必须先做:
      1. 提示用户选择MongoDB连接
      2. 调用 list-databases 查看可用数据库
      3. 调用 list-collections 查看集合
      4. 调用 collection-schema 查看Schema
      5. 调用 collection-indexes 查看索引
      6. 基于真实结构编写代码
    
    → ✅ 好处:
      - 字段名100%准确
      - 数据类型正确匹配
      - 了解现有索引(优化查询)
      - 理解关联关系
    
    → ❌ 不查询的风险:
      - 字段名错误 (如猜测email实际是userEmail)
      - 类型不匹配 (如猜测String实际是ObjectId)
      - 缺少索引导致性能问题
      - 不了解关联字段
  
  Intent-01: 修复Bug (涉及数据库)
    - 用户报告"查询用户数据有问题"
    - 用户反馈"数据统计不准确"
    - 用户说"某个接口返回错误数据"
    
    → 🔴 必须先做:
      1. 提示用户选择MongoDB连接
      2. 调用 collection-schema 查看实际Schema
      3. 调用 find 查询几条示例数据
      4. 对比代码中的查询条件与实际数据
      5. 基于真实数据修复Bug
    
    → ✅ 好处:
      - 理解数据的实际结构
      - 看到真实的数据样例
      - 快速定位问题原因
    
    → ❌ 不查询的风险:
      - 基于假设修复，可能修不对
      - 不了解数据实际情况
      - 修复后仍有问题
  
  Intent-10: 性能优化 (涉及数据库)
    - 用户要求"优化查询性能"
    - 用户反馈"接口响应慢"
    - 用户要求"数据库查询优化"
    
    → 🔴 必须先做:
      1. 提示用户选择MongoDB连接
      2. 调用 collection-indexes 查看现有索引
      3. 调用 explain 分析查询计划
      4. 调用 collection-storage-size 查看数据量
      5. 基于分析结果优化
    
    → ✅ 好处:
      - 了解现有索引情况
      - 分析查询是否使用索引
      - 评估是否需要新建索引
    
    → ❌ 不查询的风险:
      - 盲目添加索引(可能已存在)
      - 不了解查询瓶颈
      - 优化方向错误

❌ 不应该调用的场景:
  
  - 纯代码生成任务(不涉及数据库操作)
  - 文档生成任务(除非要生成数据库文档)
  - 纯前端组件开发
  - 工具脚本开发(不访问数据库)

⚠️ 需要询问用户的场景:
  
  场景1: 需求不明确
    - 用户说"开发一个用户列表页面"
    - 不确定是纯前端还是需要数据库
    - 询问: "这个功能需要从MongoDB查询数据吗？如果需要，我建议先查询数据库结构以确保代码质量。"
  
  场景2: 可能涉及数据库
    - 用户说"修复用户模块Bug"
    - 可能涉及数据库也可能不涉及
    - 询问: "这个Bug是否涉及数据库查询？如果是，我建议先查询数据库了解实际数据情况。"
  
  场景3: 性能问题
    - 用户说"系统有点慢"
    - 不确定是否数据库问题
    - 询问: "是否需要分析数据库查询性能？我可以查询索引和执行计划。"
```

---

**调用前的连接选择流程**:

```yaml
STEP 1: 检测可用连接
  调用: mcp_mongodb-chat_list-connections (如果有此工具)
  或检查: 系统配置中的MongoDB连接列表
  
  可能的连接示例:
    - mongodb-local: 本地开发数据库
    - mongodb-staging: 测试环境数据库
    - mongodb-production: 生产环境数据库 (⚠️ 高风险)

STEP 2: 向用户展示连接选项
  格式:
    检测到以下MongoDB连接:
    1. mongodb-local (本地开发环境) 🟢
    2. mongodb-staging (测试环境) 🟡
    3. mongodb-production (生产环境) 🔴 高风险
    
    请选择要使用的连接 (输入数字):

STEP 3: 等待用户选择
  - 用户输入数字 → 使用对应连接
  - 用户拒绝 → 终止数据库操作
  - 默认不选择 → 不执行数据库操作

STEP 4: 记录连接选择
  auditLog.push({
    step: currentStep,
    action: 'MongoDB连接选择',
    connection: selectedConnection,
    environment: connectionEnvironment,
    userConfirmed: true,
    timestamp: Date.now()
  });

STEP 5: 如果是生产环境连接
  IF selectedConnection === 'production'
    必须: 在P0操作清单中展示
    必须: 用户明确确认"我理解这将操作生产数据库"
    建议: 限制为只读操作(list/find/count)
```

---

**查询数据库结构的标准流程** ⭐ (用于代码开发/Bug修复):

```yaml
场景: Intent-02 开发新功能，涉及users集合

STEP 1: 提示用户
  💡 检测到此功能需要操作MongoDB的users集合。
  
  为确保代码质量，建议先查询数据库结构:
  ✅ 获取准确的字段名和类型
  ✅ 了解现有索引情况
  ✅ 避免字段名错误导致Bug
  
  是否查询数据库结构？
  [Y] 是，查询后再编写代码 (推荐)
  [N] 否，直接编写代码 (可能有风险)

STEP 2: 如果用户选择Y，执行查询流程
  
  2.1 选择MongoDB连接:
    检测到以下MongoDB连接:
    1. mongodb-local (本地开发) 🟢 推荐
    2. mongodb-staging (测试环境) 🟡
    
    请选择 (输入数字):
  
  2.2 查询数据库列表:
    const dbs = await mcp_mongodb-chat_list-databases();
    展示: 
      找到以下数据库:
      - myapp
      - test
  
  2.3 查询集合列表:
    const collections = await mcp_mongodb-chat_list-collections({
      database: 'myapp'
    });
    展示:
      myapp数据库包含以下集合:
      - users ⭐ (目标集合)
      - orders
      - products
  
  2.4 查询目标集合的Schema:
    const schema = await mcp_mongodb-chat_collection-schema({
      database: 'myapp',
      collection: 'users',
      sampleSize: 50  // 采样50条数据分析
    });
    
    展示:
      users集合Schema分析 (基于50条数据):
      
      字段列表:
      ✅ _id: ObjectId (100%)
      ✅ username: String (100%)
      ✅ email: String (98%, 2%为null)
      ✅ password: String (100%)
      ✅ role: String (100%, 值: "user" | "admin")
      ✅ createdAt: Date (100%)
      ✅ updatedAt: Date (98%)
      ⚠️ phoneNumber: String (45%, 可选字段)
  
  2.5 查询索引情况:
    const indexes = await mcp_mongodb-chat_collection-indexes({
      database: 'myapp',
      collection: 'users'
    });
    
    展示:
      users集合索引:
      ✅ _id_ (默认索引)
      ✅ email_1 (唯一索引)
      ✅ username_1 (唯一索引)
      ⚠️ 缺少createdAt索引 (如需按时间查询建议添加)
  
  2.6 查询示例数据 (可选):
    const samples = await mcp_mongodb-chat_find({
      database: 'myapp',
      collection: 'users',
      limit: 3,
      projection: { password: 0 }  // 不返回敏感字段
    });
    
    展示:
      示例数据 (已脱敏):
      {
        "_id": "507f1f77bcf86cd799439011",
        "username": "john_doe",
        "email": "john@example.com",
        "role": "user",
        "createdAt": "2025-01-15T10:30:00Z"
      }

STEP 3: 基于查询结果编写代码
  
  现在我已了解users集合的结构:
  
  ✅ 字段信息:
    - _id (ObjectId)
    - username (String, 必填, 有唯一索引)
    - email (String, 98%填充, 有唯一索引)
    - role (String, 值为"user"或"admin")
    - phoneNumber (String, 可选, 45%填充)
  
  ✅ 索引信息:
    - email和username都有唯一索引
    - 可以安全地用email查询(有索引)
  
  现在开始编写代码...
  
  [生成基于真实Schema的准确代码]

STEP 4: 记录到审计日志
  auditLog.push({
    step: 'STEP 9',
    action: 'MongoDB结构查询',
    connection: 'mongodb-local',
    collections: ['users'],
    purpose: '开发新功能前查询结构',
    fieldsDiscovered: ['_id', 'username', 'email', 'role', ...],
    indexesFound: ['email_1', 'username_1'],
    timestamp: Date.now()
  });
```

**完整示例 - 开发用户查询接口**:

```javascript
// 场景: Intent-02 开发"根据email查询用户"接口

// ❌ 不查询数据库的做法:
async function getUserByEmail_Wrong(email) {
  // 猜测字段名，可能错误
  const user = await db.collection('users').findOne({
    userEmail: email  // ❌ 错误！实际字段是email
  });
  return user;
}

// ✅ 查询数据库后的做法:
// 1. 先查询Schema，确认字段名是 "email"
// 2. 查询索引，确认email有唯一索引(查询性能好)
// 3. 查询示例数据，了解数据格式

async function getUserByEmail_Correct(email) {
  // 基于真实Schema编写
  const user = await db.collection('users').findOne({
    email: email  // ✅ 正确！字段名确认为email
  });
  
  // 知道有email唯一索引，查询性能有保证
  // 知道phoneNumber是可选字段，访问时要判断
  if (user && user.phoneNumber) {
    // 安全访问可选字段
  }
  
  return user;
}
```

---

```yaml
STEP 1: 检测可用连接
  调用: mcp_mongodb-chat_list-connections (如果有此工具)
  或检查: 系统配置中的MongoDB连接列表
  
  可能的连接示例:
    - mongodb-local: 本地开发数据库
    - mongodb-staging: 测试环境数据库
    - mongodb-production: 生产环境数据库 (⚠️ 高风险)

STEP 2: 向用户展示连接选项
  格式:
    检测到以下MongoDB连接:
    1. mongodb-local (本地开发环境)
    2. mongodb-staging (测试环境)
    3. mongodb-production (生产环境) 🔴 高风险
    
    请选择要使用的连接 (输入数字):

STEP 3: 等待用户选择
  - 用户输入数字 → 使用对应连接
  - 用户拒绝 → 终止数据库操作
  - 默认不选择 → 不执行数据库操作

STEP 4: 记录连接选择
  auditLog.push({
    step: currentStep,
    action: 'MongoDB连接选择',
    connection: selectedConnection,
    environment: connectionEnvironment,
    userConfirmed: true,
    timestamp: Date.now()
  });

STEP 5: 如果是生产环境连接
  IF selectedConnection === 'production'
    必须: 在P0操作清单中展示
    必须: 用户明确确认"我理解这将操作生产数据库"
    建议: 限制为只读操作(list/find/count)
```

---

**可用工具分类**:

```yaml
查询操作 (安全，✅ 无需确认):
  - mcp_mongodb-chat_list-databases: 列出所有数据库
  - mcp_mongodb-chat_list-collections: 列出集合
  - mcp_mongodb-chat_find: 查询数据
  - mcp_mongodb-chat_count: 统计数量
  - mcp_mongodb-chat_collection-schema: 查看Schema
  - mcp_mongodb-chat_collection-indexes: 查看索引
  - mcp_mongodb-chat_explain: 查询计划分析
  - mcp_mongodb-chat_aggregate: 聚合查询

写入操作 (需确认，⚠️):
  - mcp_mongodb-chat_insert-many: 插入数据
  - mcp_mongodb-chat_update-many: 更新数据
  - mcp_mongodb-chat_create-collection: 创建集合
  - mcp_mongodb-chat_create-index: 创建索引

删除操作 (必须P0确认，🔴):
  - mcp_mongodb-chat_delete-many: 删除数据
  - mcp_mongodb-chat_drop-collection: 删除集合
  - mcp_mongodb-chat_drop-index: 删除索引
  - mcp_mongodb-chat_drop-database: 删除数据库 (❌ 强烈不建议)

连接管理:
  - mcp_mongodb-chat_switch-connection: 切换连接
  - mcp_mongodb-chat_atlas-local-*: Atlas本地部署管理
```

---

**使用场景详解**:

```yaml
场景1: 数据库结构分析 (Intent-05)
  触发: 用户要求"分析MongoDB结构"
  
  流程:
    1. 选择连接 → 建议使用开发环境
    2. 调用 list-databases
    3. 对每个database调用 list-collections
    4. 对关键collection调用 collection-schema
    5. 生成分析报告
    
  示例:
    const dbs = await mcp_mongodb-chat_list-databases();
    const collections = await mcp_mongodb-chat_list-collections({
      database: 'myapp'
    });
    const schema = await mcp_mongodb-chat_collection-schema({
      database: 'myapp',
      collection: 'users'
    });

场景2: 数据查询 (Intent-18)
  触发: 用户要求"查询users表中的管理员"
  
  流程:
    1. 选择连接 → 用户确认环境
    2. 调用 find 查询数据
    3. 展示结果
    4. 如果需要导出，使用 export 工具
    
  示例:
    const admins = await mcp_mongodb-chat_find({
      database: 'myapp',
      collection: 'users',
      filter: { role: 'admin' },
      limit: 10
    });

场景3: 数据迁移 (Intent-14)
  触发: 用户要求"导入用户数据到MongoDB"
  
  流程:
    1. 选择连接 → 建议使用开发/测试环境
    2. 检查目标collection是否存在
    3. 展示要插入的数据预览
    4. STEP 7确认: 在P0清单中列出
    5. 执行 insert-many
    6. 验证插入结果
    
  示例:
    // ⚠️ 需要在P0清单中确认
    await mcp_mongodb-chat_insert-many({
      database: 'myapp',
      collection: 'users',
      documents: userData // 预览已展示给用户
    });

场景4: 数据库初始化 (Intent-14)
  触发: 用户要求"初始化数据库"
  
  流程:
    1. 选择连接 → 必须使用开发环境
    2. 创建必要的collection
    3. 创建索引
    4. 插入初始数据
    5. 每个操作都在P0清单中列出
    
  示例:
    await mcp_mongodb-chat_create-collection({
      database: 'myapp',
      collection: 'users'
    });
    
    await mcp_mongodb-chat_create-index({
      database: 'myapp',
      collection: 'users',
      definition: [{
        type: 'classic',
        keys: { email: 1 }
      }],
      name: 'email_unique'
    });
```

---

**环境判断和风险控制**:

```yaml
连接环境识别:
  通过连接名称判断:
    - 包含 'local' / 'dev' / 'development' → 🟢 低风险
    - 包含 'test' / 'staging' / 'uat' → 🟡 中风险
    - 包含 'prod' / 'production' → 🔴 高风险
    - 无法判断 → ⚠️ 询问用户
  
  通过连接字符串判断:
    - localhost / 127.0.0.1 → 🟢 本地环境
    - 内网IP → 🟡 测试环境
    - 公网域名 → ⚠️ 需要用户确认

风险级别对应的限制:
  🟢 低风险 (开发环境):
    - ✅ 允许所有读写操作
    - ✅ 允许创建/删除collection
    - ⚠️ drop-database需要确认
  
  🟡 中风险 (测试环境):
    - ✅ 允许读操作
    - ⚠️ 写入操作需要提示
    - 🔴 删除操作需要P0确认
  
  🔴 高风险 (生产环境):
    - ✅ 仅允许只读操作 (list/find/count)
    - 🔴 任何写入操作必须P0确认
    - ❌ 强烈建议不要删除操作
    - 必须: 在审计日志中记录所有操作
```

---

**限制和确认矩阵**:

| 操作类型 | 开发环境 | 测试环境 | 生产环境 |
|---------|---------|---------|---------|
| **查询** (find/list) | ✅ 无需确认 | ✅ 无需确认 | ✅ 无需确认 |
| **聚合** (aggregate) | ✅ 无需确认 | ✅ 无需确认 | ✅ 无需确认 |
| **插入** (<100条) | ✅ 自动执行 | ⚠️ 需提示 | 🔴 必须P0确认 |
| **插入** (>100条) | ⚠️ 需提示 | 🔴 必须确认 | 🔴 必须P0确认 |
| **更新** | ✅ 自动执行 | ⚠️ 需提示 | 🔴 必须P0确认 |
| **删除** | ⚠️ 需提示 | 🔴 必须确认 | ❌ 强烈不建议 |
| **创建索引** | ✅ 自动执行 | ⚠️ 需提示 | 🔴 必须P0确认 |
| **删除集合** | 🔴 必须确认 | 🔴 必须P0确认 | ❌ 禁止 |
| **删除数据库** | 🔴 必须P0确认 | ❌ 禁止 | ❌ 禁止 |

---

**完整示例**:

```javascript
// 场景: 用户要求"查询MongoDB中所有管理员用户"
async function queryAdminUsers() {
  // STEP 1: 检测用户意图
  const intent = 'Intent-18'; // 数据库查询
  
  // STEP 2: 检测可用MongoDB连接
  const connections = [
    { name: 'mongodb-local', env: 'development' },
    { name: 'mongodb-staging', env: 'staging' },
    { name: 'mongodb-production', env: 'production' }
  ];
  
  // STEP 3: 向用户展示连接选项
  console.log(`
检测到以下MongoDB连接:
1. mongodb-local (开发环境) 🟢
2. mongodb-staging (测试环境) 🟡
3. mongodb-production (生产环境) 🔴 高风险

请选择要使用的连接 (输入数字 1-3):
  `);
  
  // STEP 4: 等待用户选择
  const userChoice = await getUserInput(); // 假设用户选择 "1"
  const selectedConnection = connections[userChoice - 1];
  
  // STEP 5: 记录审计日志
  auditLog.push({
    step: 'STEP 5',
    action: 'MongoDB连接选择',
    connection: selectedConnection.name,
    environment: selectedConnection.env,
    timestamp: Date.now()
  });
  
  // STEP 6: 执行查询 (开发环境，无需额外确认)
  const admins = await mcp_mongodb-chat_find({
    database: 'myapp',
    collection: 'users',
    filter: { role: 'admin' },
    limit: 10,
    projection: { password: 0 } // 不返回敏感字段
  });
  
  // STEP 7: 记录查询日志
  auditLog.push({
    step: 'STEP 5',
    action: 'MongoDB查询',
    connection: selectedConnection.name,
    operation: 'find',
    database: 'myapp',
    collection: 'users',
    resultCount: admins.length,
    timestamp: Date.now()
  });
  
  // STEP 8: 返回结果
  return admins;
}
```

---

**错误处理**:

```yaml
常见错误和处理:

1. 连接失败:
   错误: "Cannot connect to MongoDB"
   处理:
     - 检查MCP服务是否运行
     - 检查连接配置是否正确
     - 提示用户检查网络连接
     - 建议使用其他连接

2. 认证失败:
   错误: "Authentication failed"
   处理:
     - 检查用户名密码是否正确
     - 提示用户更新连接配置
     - 不要在日志中记录密码

3. 权限不足:
   错误: "Not authorized"
   处理:
     - 说明需要的权限
     - 建议联系数据库管理员
     - 提供降级方案(如仅查询)

4. 数据库/集合不存在:
   错误: "Database/Collection not found"
   处理:
     - 列出可用的数据库/集合
     - 询问用户是否创建
     - 如果创建，需要P0确认

5. 查询超时:
   错误: "Query timeout"
   处理:
     - 建议优化查询条件
     - 建议添加索引
     - 提供分页查询方案
```

---

## ❌ 禁止使用的工具

### 明确禁止的操作

```yaml
🔴 系统级操作:
  - 修改系统文件
  - 修改环境变量(永久)
  - 修改网络配置
  - 修改用户权限

🔴 破坏性操作(未经确认):
  - 删除文件/目录
  - 删除数据库/集合
  - 删除Git分支
  - 强制推送(git push -f)

🔴 未授权的外部访问:
  - 访问外部API(除非Profile允许)
  - 下载外部资源
  - 发送网络请求(除非必要)

🔴 隐私侵犯:
  - 读取用户敏感信息(密码/密钥)
  - 上传用户数据到外部
  - 泄露项目敏感信息
```

---

## ⚠️ 确认要求

### 工具调用的确认级别

```yaml
级别0: 无需确认(绿灯)
  工具:
    - read_file
    - file_search
    - grep_search
    - get_errors
  条件:
    - 只读操作
    - 无风险

级别1: 自动执行，需记录(黄灯)
  工具:
    - create_file (新建代码/测试)
    - insert_edit_into_file (新增代码)
    - run_in_terminal (安全命令: npm test)
  条件:
    - 在STEP 10/12/14已确认
    - 记录到审计日志

级别2: 需要提示(橙灯)
  工具:
    - run_in_terminal (npm install)
    - insert_edit_into_file (修改配置)
  条件:
    - 生成提示信息
    - 用户可以看到将执行什么

级别3: 必须确认(红灯)
  工具:
    - replace_string_in_file (删除代码)
    - run_in_terminal (部署/删除)
    - mcp_mongodb-chat_delete-many
    - mcp_mongodb-chat_drop-*
  条件:
    - 在STEP 7的P0操作清单中列出
    - 用户明确同意
    - 记录到审计日志
```

---

## 📋 审计日志

### 工具调用必须记录

**所有工具调用都要记录到审计日志**:

```javascript
// 审计日志格式
auditLog.push({
  step: 'STEP 9',           // 哪个STEP调用的
  action: '创建文件',        // 操作类型
  tool: 'create_file',      // 工具名称
  target: 'src/user-service.js', // 操作对象
  result: 'success',        // 结果: success/failed
  timestamp: Date.now(),    // 时间戳
  details: {                // 详细信息(可选)
    fileSize: '150行',
    lintErrors: 0
  }
});
```

**关键工具调用需要向用户说明**:

```markdown
## STEP 9: 代码开发

我使用了以下工具:
1. ✅ read_file: 读取了3个现有文件理解上下文
2. ✅ create_file: 创建了2个新文件
3. ✅ get_errors: 验证了代码质量(0错误)

生成的文件:
- src/user-service.js (新建, 150行)
- src/utils/validator.js (新建, 80行)
```

---

## 🔧 错误处理

### 工具调用失败的处理

```yaml
工具调用失败处理流程:

1. 记录错误:
   auditLog.push({
     step: currentStep,
     action: '工具调用失败',
     tool: toolName,
     error: error.message,
     timestamp: Date.now()
   });

2. 分析错误类型:
   可恢复错误:
     - 文件不存在 → 尝试其他路径
     - 权限不足 → 提示用户检查权限
     - 命令失败 → 提供错误信息和建议
   
   致命错误:
     - 系统故障
     - 环境配置问题
     - → 终止流程，生成错误报告

3. 提供降级方案:
   IF run_in_terminal('npm test') 失败
   THEN 提示用户手动运行测试
   
   IF create_file 失败(文件已存在)
   THEN 尝试 insert_edit_into_file

4. 向用户报告:
   ⚠️ 工具调用失败
   
   工具: create_file
   目标: src/user-service.js
   错误: 文件已存在
   
   建议:
   1. 如果要覆盖文件，请明确告诉我
   2. 如果要修改现有文件，我可以使用edit功能
```

---

## 🎨 Profile 优先

### 项目可以自定义工具权限

**Profile可以限制或扩展工具权限**:

```yaml
# guidelines/profiles/high-security-project.md

工具调用规范覆盖:
  
  禁止的工具:
    - run_in_terminal: 完全禁止执行命令
    - run_subagent: 不允许调用外部代理
    - mcp_mongodb-chat_*: 禁止数据库操作
  
  额外确认要求:
    - create_file: 创建任何文件都需要确认
    - insert_edit_into_file: 任何编辑都需要确认
  
  原因: 高安全项目，需要人工审核所有变更
```

```yaml
# guidelines/profiles/rapid-development.md

工具调用规范覆盖:
  
  放宽限制:
    - run_in_terminal: 允许执行npm install无需确认
    - create_file: 允许创建配置文件无需确认
  
  启用工具:
    - run_subagent: 鼓励使用专业代理提升质量
  
  原因: 快速开发项目，注重效率
```

**AI应用Profile规则**:

```javascript
// STEP 0: 加载Profile时
if (profile.toolCallRules) {
  // 合并工具权限规则
  this.toolPermissions = {
    ...defaultToolPermissions,
    ...profile.toolCallRules
  };
}

// 调用工具前检查权限
async callTool(toolName, args) {
  if (this.toolPermissions.forbidden?.includes(toolName)) {
    throw new Error(`工具 ${toolName} 被Profile禁止`);
  }
  
  if (this.toolPermissions.requireConfirm?.includes(toolName)) {
    // 需要用户确认
    await this.confirmWithUser(`是否允许调用 ${toolName}?`);
  }
  
  // 执行工具调用
  const result = await tool[toolName](args);
  
  // 记录审计日志
  this.auditLog.push({...});
  
  return result;
}
```

---

## 📝 总结

### 工具调用规范要点

```yaml
✅ 允许自由使用(无需确认):
  - read_file: 读取文件
  - file_search: 搜索文件
  - grep_search: 代码搜索
  - get_errors: 错误检测
  - 数据库查询(只读)

⚠️ 自动执行，需记录:
  - create_file: 创建新文件
  - insert_edit_into_file: 新增代码
  - run_in_terminal: 安全命令(npm test)

🔴 必须确认:
  - 删除代码/文件
  - 部署到生产
  - 数据库删除操作
  - 敏感配置修改

🟡 建议使用:
  - run_subagent: 复杂任务委托

❌ 禁止操作:
  - 系统级操作
  - 破坏性操作(未确认)
  - 隐私侵犯

📋 必须记录:
  - 所有工具调用记录审计日志
  - 关键操作向用户说明
  - Profile覆盖的规则
```

---

**最后更新**: 2025-11-21  
**下一版本**: 根据实际使用反馈优化

