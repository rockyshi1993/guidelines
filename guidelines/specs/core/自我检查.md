# v3 AI自我检查机制

> **文件**: specs/core/自我检查.md  
> **版本**: v3.0  
> **日期**: 2025-11-21  
> **说明**: AI在关键STEP后的自我检查清单

---

## 📑 目录导航

> 🔴 = 必须检查 | 🟡 = 建议检查 | 🟢 = 可选检查

- [自检原则](#-自检原则) 🔴 - 为什么需要自检
- [STEP 0 自检](#-step-0-自检启动检查) 🔴 - 启动前检查清单
- [STEP 9 自检](#-step-9-自检代码质量) 🔴 - 代码生成后检查
- [STEP 11 自检](#-step-11-自检测试完整性) 🔴 - 测试生成后检查
- [STEP 15 自检](#-step-15-自检文档同步) 🔴 - 文档生成后检查
- [STEP 17 自检](#-step-17-自检最终质量) 🔴 - 最终质量验证
- [自检失败处理](#-自检失败处理) 🔴 - 如何处理检查失败

---

## 🎯 自检原则

### 为什么需要自检

```yaml
问题: AI可能执行错误但不自知
  - 生成的代码可能有错误
  - 测试可能不够完整
  - 文档可能未同步
  - 可能违反规范

解决: 在关键STEP后自我检查
  - 及早发现问题
  - 在用户确认前修复
  - 提升输出质量
  - 减少返工
```

### 自检的时机

```yaml
必须自检的STEP:
  - STEP 0: 启动前检查
  - STEP 9: 代码生成后
  - STEP 11: 测试生成后
  - STEP 15: 文档生成后
  - STEP 17: 最终质量验证

自检流程:
  1. 执行自检清单
  2. 记录检查结果
  3. IF 发现问题:
     - 尝试自动修复
     - 如无法修复，标记警告
     - 在下一个确认点向用户说明
  4. IF 全部通过:
     - 继续下一STEP
```

---

## 🚦 STEP 0 自检：启动检查

**时机**: 任何任务开始前

**检查清单**:

```yaml
☐ 1. Profile检查
  问题: guidelines/profiles/{project}.md 是否存在?
  IF 存在:
    ✅ 已读取Profile内容
    ✅ 已识别项目特定规范
    ✅ 已识别禁止项
  ELSE:
    ✅ 使用默认通用规范
  
  记录:
    profileLoaded: true/false
    profileName: "xxx" / "default"
    禁止项: [...]

☐ 2. 意图识别检查
  问题: 是否准确识别了用户意图?
  ✅ 意图类别: Intent-XX
  ✅ 意图名称: "开发新功能" / "修复Bug" 等
  ✅ 风险等级: P0/P1/P2
  
  IF 不确定:
    ⚠️ 询问用户确认意图

☐ 3. 规范文件检查
  问题: 是否确定了需要的规范文件?
  ✅ 代码规范: 需要/不需要
  ✅ 测试规范: 需要/不需要
  ✅ 文档规范: 需要/不需要
  ✅ 数据库相关: 需要/不需要
  ✅ 工具调用规范: 已准备

☐ 4. 数据库操作检查
  问题: 是否涉及MongoDB操作?
  IF 涉及:
    ✅ 已准备查询数据库结构
    ✅ 已准备选择MongoDB连接
    ⚠️ 提示用户先查询结构
  
☐ 5. 禁止删除扫描
  问题: 是否扫描了禁止删除项?
  ✅ 现有 import/require
  ✅ 现有路由/函数
  ✅ 现有配置
  
  记录:
    禁止删除清单: [...]

☐ 6. 工具权限检查
  问题: 需要使用哪些工具?
  ✅ 文件操作: read/create/edit
  ✅ 代码分析: grep/errors
  ✅ 执行工具: terminal (需确认级别)
  ✅ 数据库: MongoDB MCP (需选择连接)
```

**自检输出示例**:

```
✅ STEP 0 自检完成

Profile: ✅ 已加载 ndsk_core
意图: ✅ Intent-02 (开发新功能, P1)
规范: ✅ 代码规范 + 测试规范 + 文档规范
数据库: ⚠️ 涉及users集合，建议先查询结构
工具: ✅ 已准备 read_file, create_file, grep_search
禁止删除: ✅ 已扫描，0项禁止删除

准备就绪，可以继续执行。
```

---

## 🔍 STEP 9 自检：代码质量

**时机**: 代码生成完成后，STEP 10用户确认前

**检查清单**:

```yaml
☐ 1. 代码规范检查
  问题: 代码是否符合代码规范?
  
  命名规范:
    ✅ 变量名使用 camelCase
    ✅ 类名使用 PascalCase
    ✅ 常量使用 UPPER_SNAKE_CASE
    ✅ 文件名使用 kebab-case
  
  结构规范:
    ✅ 函数长度 ≤ 50行
    ✅ 参数数量 ≤ 5个
    ✅ 嵌套层级 ≤ 3层
  
  注释规范:
    ✅ 关键函数有JSDoc注释
    ✅ 复杂逻辑有行内注释
  
  IF 不符合:
    🔧 自动修复: 调整命名、添加注释
    ⚠️ 无法自动修复: 标记警告

☐ 2. Lint检查
  问题: 代码是否通过Lint?
  
  执行: get_errors(生成的文件)
  
  结果:
    ✅ 0错误 0警告
    ❌ X个错误 Y个警告
  
  IF 有错误:
    🔧 尝试自动修复常见错误
    ⚠️ 严重错误: 标记必须修复

☐ 3. 复杂度检查
  问题: 代码复杂度是否 ≤ 10?
  
  检查每个函数的圈复杂度
  
  结果:
    ✅ 平均复杂度: X (≤5)
    ✅ 最高复杂度: Y (≤10)
    ❌ 超过10的函数: [函数名]
  
  IF 超过10:
    🔧 建议拆分函数
    ⚠️ 标记需要重构

☐ 4. 安全检查
  问题: 代码是否包含敏感信息?
  
  执行: 敏感信息检测 (10种规则)
  
  结果:
    ✅ 0个敏感信息
    🔴 发现X个敏感信息:
      - 类型: 硬编码密码/API密钥
      - 位置: 文件名:行号
  
  IF 发现敏感信息:
    🔧 自动修复: 替换为环境变量
    🔴 严重: 必须修复才能继续

☐ 5. 错误处理检查
  问题: async函数是否有try-catch?
  
  扫描所有async函数
  
  结果:
    ✅ 所有async函数都有错误处理
    ⚠️ X个async函数缺少try-catch
  
  IF 缺少:
    🔧 自动添加try-catch

☐ 6. Profile约束检查
  问题: 是否违反了Profile规定?
  
  IF Profile禁止Service层:
    ❌ 检查是否创建了*Service.js
  
  IF Profile禁止DTO模式:
    ❌ 检查是否使用了DTO类
  
  IF 违反:
    🔴 必须修复

☐ 7. 数据库代码检查 (如适用)
  问题: 如果涉及数据库，是否先查询了结构?
  
  IF 包含数据库查询代码:
    ✅ 已调用MCP查询结构
    ✅ 字段名与Schema匹配
    ✅ 数据类型正确
    ❌ 未查询结构 (字段名可能错误)
  
  IF 未查询:
    ⚠️ 强烈建议先查询结构

☐ 8. 禁止删除验证
  问题: 是否删除了禁止删除的内容?
  
  对比生成代码与禁止删除清单
  
  结果:
    ✅ 未删除任何禁止项
    🔴 删除了X项内容:
      - import xxx (禁止)
      - function yyy (禁止)
  
  IF 删除了:
    🔴 必须获得用户明确确认
```

**自检输出示例**:

```
✅ STEP 9 自检完成

代码规范: ✅ 通过
Lint检查: ✅ 0错误 0警告
复杂度: ✅ 平均4.2, 最高8
安全检查: ✅ 0敏感信息
错误处理: ✅ 所有async函数都有try-catch
Profile约束: ✅ 符合ndsk_core规范
数据库: ⚠️ 包含MongoDB查询，建议用户确认字段名是否准确
禁止删除: ✅ 未删除任何内容

代码质量良好，可以提交用户确认。
```

**有问题时的输出**:

```
⚠️ STEP 9 自检发现问题

代码规范: ⚠️ 2个函数超过50行
  - getUserProfile: 65行 (建议拆分)
  - processOrder: 58行 (建议拆分)

Lint检查: ❌ 3个错误
  - user-service.js:45 - 'result' is not defined
  - user-service.js:89 - Missing semicolon
  - validator.js:12 - Unused variable 'temp'

🔧 正在自动修复...

修复结果:
  ✅ 已添加缺少的定义
  ✅ 已添加分号
  ✅ 已移除未使用变量

重新检查: ✅ Lint通过

建议在STEP 10时告知用户函数长度问题。
```

---

## 🧪 STEP 11 自检：测试完整性

**时机**: 测试用例生成完成后，STEP 12用户确认前

**检查清单**:

```yaml
☐ 1. 测试覆盖率预估
  问题: 测试是否覆盖了主要代码?
  
  检查:
    ✅ 每个导出函数都有测试
    ✅ 主要分支都有覆盖
    ✅ 边界条件有测试
  
  预估覆盖率: X% (目标≥80%)
  
  IF <80%:
    🔧 补充测试用例

☐ 2. 测试命名检查
  问题: 测试命名是否符合规范?
  
  规范: should {action} when {condition}
  
  检查每个test/it描述:
    ✅ getUserById - should return user when user exists
    ❌ test user - 不符合规范
  
  IF 不符合:
    🔧 自动修正命名

☐ 3. AAA模式检查
  问题: 测试是否遵循AAA模式?
  
  检查每个测试:
    ✅ Arrange: 准备测试数据
    ✅ Act: 执行被测函数
    ✅ Assert: 验证结果
  
  IF 不完整:
    🔧 补充缺失部分

☐ 4. Mock使用检查
  问题: Mock使用是否合理?
  
  检查:
    ✅ 外部依赖已Mock (数据库/API)
    ✅ 纯函数未过度Mock
    ✅ Mock数据真实合理
  
  IF 不合理:
    🔧 调整Mock策略

☐ 5. 断言完整性检查
  问题: 断言是否足够?
  
  检查每个测试:
    ✅ 验证了返回值
    ✅ 验证了副作用
    ✅ 验证了错误情况
  
  IF 不足:
    🔧 补充断言

☐ 6. 边界条件检查
  问题: 是否测试了边界条件?
  
  必须测试:
    ✅ null/undefined输入
    ✅ 空数组/空字符串
    ✅ 超大数值
    ✅ 错误输入类型
  
  IF 缺少:
    🔧 补充边界条件测试

☐ 7. 异步测试检查
  问题: 异步测试是否正确?
  
  检查:
    ✅ 使用 async/await
    ✅ 或使用 done callback
    ✅ 或返回 Promise
  
  IF 不正确:
    🔧 修正异步测试写法

☐ 8. 测试独立性检查
  问题: 测试是否相互独立?
  
  检查:
    ✅ 每个测试有独立的setup
    ✅ 测试间无共享状态
    ✅ 可以单独运行
  
  IF 不独立:
    🔧 拆分共享状态
```

**自检输出示例**:

```
✅ STEP 11 自检完成

测试覆盖: ✅ 预估85% (目标≥80%)
  - 5个函数全部有测试
  - 主要分支已覆盖
  - 边界条件已测试

测试命名: ✅ 符合规范 (should...when...)
AAA模式: ✅ 所有测试遵循AAA
Mock策略: ✅ 合理使用Mock
断言: ✅ 完整
边界条件: ✅ 已覆盖 null/undefined/空值
异步测试: ✅ 正确使用 async/await
独立性: ✅ 测试相互独立

测试用例质量良好，可以提交用户确认。
```

---

## 📚 STEP 15 自检：文档同步

**时机**: 文档生成完成后，STEP 16用户确认前

**检查清单**:

```yaml
☐ 1. README.md检查
  问题: README是否完整?
  
  必须包含:
    ✅ 模块名称和描述
    ✅ 安装说明
    ✅ 使用示例
    ✅ API列表
    ✅ 依赖说明
  
  IF 不完整:
    🔧 补充缺失章节

☐ 2. API文档检查
  问题: 所有API是否都有文档?
  
  对比:
    生成的代码: X个导出函数
    API文档: Y个函数文档
  
  结果:
    ✅ X == Y (全部覆盖)
    ❌ X > Y (缺少Z个函数文档)
  
  IF 缺少:
    🔧 补充缺失的API文档

☐ 3. Swagger文档检查
  问题: Swagger是否生成成功?
  
  检查:
    ✅ openapi.yaml 文件存在
    ✅ 所有路由都在Swagger中
    ✅ 请求/响应格式完整
    ✅ 参数说明清晰
  
  IF 失败:
    🔧 重新生成Swagger
    ⚠️ 记录生成错误

☐ 4. 文档与代码同步检查
  问题: 文档是否与代码一致?
  
  检查:
    ✅ 函数签名匹配
    ✅ 参数类型一致
    ✅ 返回值类型一致
    ✅ 错误代码一致
  
  IF 不一致:
    🔧 更新文档使其同步

☐ 5. 示例代码检查
  问题: 示例代码是否可运行?
  
  检查每个示例:
    ✅ 语法正确
    ✅ import路径正确
    ✅ 参数合理
    ✅ 可以直接复制运行
  
  IF 不可运行:
    🔧 修正示例代码

☐ 6. IMPLEMENTATION.md同步检查
  问题: 实现方案是否需要更新?
  
  检查变更:
    ✅ 架构未变化 → 不需要更新
    ⚠️ 架构变化 → 必须更新
    ⚠️ 流程变化 → 必须更新
    ✅ 代码优化 → 仅更新CHANGELOG
  
  IF 需要更新:
    🔧 更新IMPLEMENTATION.md

☐ 7. CHANGELOG.md检查
  问题: 变更日志是否已记录?
  
  检查:
    ✅ 日期正确
    ✅ 版本号合理
    ✅ 变更分类清晰 (Added/Changed/Fixed)
    ✅ 描述准确
  
  IF 不完整:
    🔧 补充变更记录
```

**自检输出示例**:

```
✅ STEP 15 自检完成

README.md: ✅ 完整 (包含5个必要章节)
API文档: ✅ 5个函数全部有文档
Swagger: ✅ 成功生成 docs/user-service/api/openapi.yaml
文档同步: ✅ 与代码完全一致
示例代码: ✅ 3个示例全部可运行
IMPLEMENTATION.md: ✅ 已更新 (流程变化)
CHANGELOG.md: ✅ 已记录变更

文档完整且同步，可以提交用户确认。
```

---

## ✅ STEP 17 自检：最终质量

**时机**: 所有工作完成后，最终质量验证

**检查清单**:

```yaml
☐ 1. 整体完整性检查
  问题: 所有必要文件是否都已生成?
  
  检查:
    ✅ 代码文件: X个
    ✅ 测试文件: Y个
    ✅ 文档文件: Z个
    ✅ 配置文件: (如需要)
  
  IF 缺少:
    ⚠️ 标记缺失文件

☐ 2. 质量指标汇总
  问题: 所有质量指标是否达标?
  
  指标:
    ✅ Lint: 0错误 0警告
    ✅ 测试覆盖率: X% (≥80%)
    ✅ 代码复杂度: 平均Y, 最高Z (≤10)
    ✅ 敏感信息: 0个
    ✅ 文档覆盖: 100%
  
  汇总评分: A/B/C
  
  IF 未达标:
    ⚠️ 列出未达标项

☐ 3. 审计日志完整性
  问题: 审计日志是否完整?
  
  检查:
    ✅ Profile加载记录
    ✅ 意图识别记录
    ✅ 工具调用记录
    ✅ 用户确认记录
    ✅ 文件操作记录
  
  IF 不完整:
    🔧 补充缺失记录

☐ 4. 禁止删除最终验证
  问题: 是否确认未删除禁止项?
  
  最终对比:
    ✅ 所有import/require保留
    ✅ 所有路由/函数保留
    ✅ 所有配置保留
    ❌ 删除了X项 (需用户确认)
  
  IF 删除了:
    🔴 必须在STEP 19向用户说明

☐ 5. P0操作确认检查
  问题: 所有P0操作是否已确认?
  
  检查:
    ✅ 删除操作: 已确认/无
    ✅ 数据库操作: 已确认/无
    ✅ 生产部署: 已确认/无
  
  IF 未确认:
    🔴 严重: 不能继续

☐ 6. 循环统计检查
  问题: 循环次数是否合理?
  
  统计:
    ✅ STEP 13-14: X次 (≤3)
    ✅ STEP 9-10: Y次 (≤5)
  
  IF 接近上限:
    ⚠️ 记录到报告

☐ 7. 时间统计
  问题: 执行时间是否合理?
  
  统计:
    总时间: X分钟
    最长STEP: STEP Y (Z分钟)
  
  IF >30分钟:
    ⚠️ 分析耗时原因
```

**自检输出示例**:

```
✅ STEP 17 最终质量自检完成

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 质量指标汇总
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

代码质量: ✅ A级
  - Lint: 0错误 0警告
  - 复杂度: 平均4.5, 最高9
  - 函数长度: 符合规范

测试质量: ✅ A级
  - 覆盖率: 87% (目标≥80%)
  - 测试数量: 23个
  - 断言数量: 78个

文档质量: ✅ A级
  - API文档: 100%覆盖
  - Swagger: 成功生成
  - 示例代码: 可运行

安全质量: ✅ 完美
  - 敏感信息: 0个
  - 禁止删除: 未违反
  - P0操作: 全部确认

执行统计:
  - 总时间: 18分钟
  - 循环次数: 1次 (STEP 13-14)
  - 用户确认: 5次全部通过

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
综合评分: ⭐⭐⭐⭐⭐ A级 (优秀)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

所有质量指标达标，可以提交最终确认。
```

---

## 🔧 自检失败处理

### 失败级别定义

```yaml
🟢 提示级 (Info):
  - 建议性改进
  - 不影响功能
  - 示例: 函数可以更简洁
  
  处理: 记录到报告，不阻塞流程

🟡 警告级 (Warning):
  - 需要注意的问题
  - 可能影响质量
  - 示例: 函数稍长 (55行)
  
  处理: 
    - 尝试自动修复
    - 无法修复时记录警告
    - 在下一确认点向用户说明

🔴 错误级 (Error):
  - 必须修复的问题
  - 影响功能或安全
  - 示例: Lint错误、敏感信息
  
  处理:
    - 立即尝试自动修复
    - 修复失败: 阻塞流程
    - 要求用户介入

🔴 严重级 (Critical):
  - 严重违反规范
  - 安全风险
  - 示例: 未确认的P0操作
  
  处理:
    - 立即终止流程
    - 生成详细报告
    - 必须用户确认才能继续
```

### 自动修复策略

```javascript
class AutoFix {
  async fixLintErrors(errors) {
    for (const error of errors) {
      if (error.fixable) {
        // 自动修复
        await this.applyFix(error);
      } else {
        // 记录无法修复的错误
        this.warnings.push(error);
      }
    }
  }
  
  async fixComplexity(functions) {
    for (const func of functions) {
      if (func.complexity > 10) {
        // 建议拆分，但不自动执行
        this.warnings.push({
          type: 'complexity',
          function: func.name,
          suggestion: '建议拆分为多个小函数'
        });
      }
    }
  }
  
  async fixSensitiveInfo(findings) {
    for (const finding of findings) {
      if (finding.type === 'hardcoded_password') {
        // 自动替换为环境变量
        await this.replaceWithEnvVar(finding);
      }
    }
  }
}
```

### 失败报告格式

```markdown
⚠️ 自检发现问题 - STEP 9

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔴 错误 (2个) - 必须修复
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. Lint错误 - user-service.js:45
   错误: 'result' is not defined
   修复: 🔧 已自动添加变量定义

2. 敏感信息 - config.js:12
   错误: 硬编码API密钥
   修复: 🔧 已替换为 process.env.API_KEY

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🟡 警告 (1个) - 建议修复
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. 函数长度 - getUserProfile
   当前: 65行
   建议: 拆分为多个小函数 (≤50行)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
修复结果
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✅ 自动修复: 2个错误已修复
⚠️ 需人工: 1个警告待确认

重新检查: ✅ Lint通过，可以继续
```

---

## 📊 自检效果统计

**建议记录以下指标**:

```yaml
自检统计:
  检查次数: X次
  发现问题: Y个
  自动修复: Z个
  需人工: W个
  
问题分布:
  代码规范: X个
  Lint错误: Y个
  安全问题: Z个
  测试不足: W个

修复效率:
  自动修复率: X%
  平均修复时间: Y秒
```

---

**最后更新**: 2025-11-21  
**状态**: ✅ 完整

